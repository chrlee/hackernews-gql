// @bun
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getProtoOf = Object.getPrototypeOf;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __toESM = (mod, isNodeMode, target) => {
  target = mod != null ? __create(__getProtoOf(mod)) : {};
  const to = isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target;
  for (let key of __getOwnPropNames(mod))
    if (!__hasOwnProp.call(to, key))
      __defProp(to, key, {
        get: () => mod[key],
        enumerable: true
      });
  return to;
};
var __commonJS = (cb, mod) => () => (mod || cb((mod = { exports: {} }).exports, mod), mod.exports);
var __require = (id) => {
  return import.meta.require(id);
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, {
      get: all[name],
      enumerable: true,
      configurable: true,
      set: (newValue) => all[name] = () => newValue
    });
};

// node_modules/tslib/tslib.js
var require_tslib = __commonJS((exports, module) => {
  var __extends;
  var __assign;
  var __rest;
  var __decorate;
  var __param;
  var __esDecorate;
  var __runInitializers;
  var __propKey;
  var __setFunctionName;
  var __metadata;
  var __awaiter;
  var __generator;
  var __exportStar;
  var __values;
  var __read;
  var __spread;
  var __spreadArrays;
  var __spreadArray;
  var __await;
  var __asyncGenerator;
  var __asyncDelegator;
  var __asyncValues;
  var __makeTemplateObject;
  var __importStar;
  var __importDefault;
  var __classPrivateFieldGet;
  var __classPrivateFieldSet;
  var __classPrivateFieldIn;
  var __createBinding;
  var __addDisposableResource;
  var __disposeResources;
  (function(factory) {
    var root = typeof global === "object" ? global : typeof self === "object" ? self : typeof this === "object" ? this : {};
    if (typeof define === "function" && define.amd) {
      define("tslib", ["exports"], function(exports2) {
        factory(createExporter(root, createExporter(exports2)));
      });
    } else if (typeof module === "object" && typeof exports === "object") {
      factory(createExporter(root, createExporter(exports)));
    } else {
      factory(createExporter(root));
    }
    function createExporter(exports2, previous) {
      if (exports2 !== root) {
        if (typeof Object.create === "function") {
          Object.defineProperty(exports2, "__esModule", { value: true });
        } else {
          exports2.__esModule = true;
        }
      }
      return function(id, v) {
        return exports2[id] = previous ? previous(id, v) : v;
      };
    }
  })(function(exporter) {
    var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d, b) {
      d.__proto__ = b;
    } || function(d, b) {
      for (var p in b)
        if (Object.prototype.hasOwnProperty.call(b, p))
          d[p] = b[p];
    };
    __extends = function(d, b) {
      if (typeof b !== "function" && b !== null)
        throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
      extendStatics(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __);
    };
    __assign = Object.assign || function(t) {
      for (var s, i = 1, n = arguments.length;i < n; i++) {
        s = arguments[i];
        for (var p in s)
          if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
      }
      return t;
    };
    __rest = function(s, e) {
      var t = {};
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
          t[p] = s[p];
      if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s);i < p.length; i++) {
          if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
            t[p[i]] = s[p[i]];
        }
      return t;
    };
    __decorate = function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1;i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    __param = function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    __esDecorate = function(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
      function accept(f) {
        if (f !== undefined && typeof f !== "function")
          throw new TypeError("Function expected");
        return f;
      }
      var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
      var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
      var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
      var _, done = false;
      for (var i = decorators.length - 1;i >= 0; i--) {
        var context = {};
        for (var p in contextIn)
          context[p] = p === "access" ? {} : contextIn[p];
        for (var p in contextIn.access)
          context.access[p] = contextIn.access[p];
        context.addInitializer = function(f) {
          if (done)
            throw new TypeError("Cannot add initializers after decoration has completed");
          extraInitializers.push(accept(f || null));
        };
        var result = (0, decorators[i])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);
        if (kind === "accessor") {
          if (result === undefined)
            continue;
          if (result === null || typeof result !== "object")
            throw new TypeError("Object expected");
          if (_ = accept(result.get))
            descriptor.get = _;
          if (_ = accept(result.set))
            descriptor.set = _;
          if (_ = accept(result.init))
            initializers.unshift(_);
        } else if (_ = accept(result)) {
          if (kind === "field")
            initializers.unshift(_);
          else
            descriptor[key] = _;
        }
      }
      if (target)
        Object.defineProperty(target, contextIn.name, descriptor);
      done = true;
    };
    __runInitializers = function(thisArg, initializers, value) {
      var useValue = arguments.length > 2;
      for (var i = 0;i < initializers.length; i++) {
        value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
      }
      return useValue ? value : undefined;
    };
    __propKey = function(x) {
      return typeof x === "symbol" ? x : "".concat(x);
    };
    __setFunctionName = function(f, name, prefix) {
      if (typeof name === "symbol")
        name = name.description ? "[".concat(name.description, "]") : "";
      return Object.defineProperty(f, "name", { configurable: true, value: prefix ? "".concat(prefix, " ", name) : name });
    };
    __metadata = function(metadataKey, metadataValue) {
      if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
        return Reflect.metadata(metadataKey, metadataValue);
    };
    __awaiter = function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    __generator = function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1)
          throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f, y, t, g;
      return g = { next: verb(0), throw: verb(1), return: verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _)
          try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            if (y = 0, t)
              op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _.label++;
                return { value: op[1], done: false };
              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2];
                  _.ops.push(op);
                  break;
                }
                if (t[2])
                  _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : undefined, done: true };
      }
    };
    __exportStar = function(m, o) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p))
          __createBinding(o, m, p);
    };
    __createBinding = Object.create ? function(o, m, k, k2) {
      if (k2 === undefined)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === undefined)
        k2 = k;
      o[k2] = m[k];
    };
    __values = function(o) {
      var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
      if (m)
        return m.call(o);
      if (o && typeof o.length === "number")
        return {
          next: function() {
            if (o && i >= o.length)
              o = undefined;
            return { value: o && o[i++], done: !o };
          }
        };
      throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    };
    __read = function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m)
        return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === undefined || n-- > 0) && !(r = i.next()).done)
          ar.push(r.value);
      } catch (error) {
        e = { error };
      } finally {
        try {
          if (r && !r.done && (m = i["return"]))
            m.call(i);
        } finally {
          if (e)
            throw e.error;
        }
      }
      return ar;
    };
    __spread = function() {
      for (var ar = [], i = 0;i < arguments.length; i++)
        ar = ar.concat(__read(arguments[i]));
      return ar;
    };
    __spreadArrays = function() {
      for (var s = 0, i = 0, il = arguments.length;i < il; i++)
        s += arguments[i].length;
      for (var r = Array(s), k = 0, i = 0;i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length;j < jl; j++, k++)
          r[k] = a[j];
      return r;
    };
    __spreadArray = function(to, from, pack) {
      if (pack || arguments.length === 2)
        for (var i = 0, l = from.length, ar;i < l; i++) {
          if (ar || !(i in from)) {
            if (!ar)
              ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
          }
        }
      return to.concat(ar || Array.prototype.slice.call(from));
    };
    __await = function(v) {
      return this instanceof __await ? (this.v = v, this) : new __await(v);
    };
    __asyncGenerator = function(thisArg, _arguments, generator) {
      if (!Symbol.asyncIterator)
        throw new TypeError("Symbol.asyncIterator is not defined.");
      var g = generator.apply(thisArg, _arguments || []), i, q = [];
      return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
        return this;
      }, i;
      function verb(n) {
        if (g[n])
          i[n] = function(v) {
            return new Promise(function(a, b) {
              q.push([n, v, a, b]) > 1 || resume(n, v);
            });
          };
      }
      function resume(n, v) {
        try {
          step(g[n](v));
        } catch (e) {
          settle(q[0][3], e);
        }
      }
      function step(r) {
        r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
      }
      function fulfill(value) {
        resume("next", value);
      }
      function reject(value) {
        resume("throw", value);
      }
      function settle(f, v) {
        if (f(v), q.shift(), q.length)
          resume(q[0][0], q[0][1]);
      }
    };
    __asyncDelegator = function(o) {
      var i, p;
      return i = {}, verb("next"), verb("throw", function(e) {
        throw e;
      }), verb("return"), i[Symbol.iterator] = function() {
        return this;
      }, i;
      function verb(n, f) {
        i[n] = o[n] ? function(v) {
          return (p = !p) ? { value: __await(o[n](v)), done: false } : f ? f(v) : v;
        } : f;
      }
    };
    __asyncValues = function(o) {
      if (!Symbol.asyncIterator)
        throw new TypeError("Symbol.asyncIterator is not defined.");
      var m = o[Symbol.asyncIterator], i;
      return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
        return this;
      }, i);
      function verb(n) {
        i[n] = o[n] && function(v) {
          return new Promise(function(resolve, reject) {
            v = o[n](v), settle(resolve, reject, v.done, v.value);
          });
        };
      }
      function settle(resolve, reject, d, v) {
        Promise.resolve(v).then(function(v2) {
          resolve({ value: v2, done: d });
        }, reject);
      }
    };
    __makeTemplateObject = function(cooked, raw) {
      if (Object.defineProperty) {
        Object.defineProperty(cooked, "raw", { value: raw });
      } else {
        cooked.raw = raw;
      }
      return cooked;
    };
    var __setModuleDefault = Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    };
    __importStar = function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    __importDefault = function(mod) {
      return mod && mod.__esModule ? mod : { default: mod };
    };
    __classPrivateFieldGet = function(receiver, state, kind, f) {
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a getter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot read private member from an object whose class did not declare it");
      return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    };
    __classPrivateFieldSet = function(receiver, state, value, kind, f) {
      if (kind === "m")
        throw new TypeError("Private method is not writable");
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a setter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot write private member to an object whose class did not declare it");
      return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
    };
    __classPrivateFieldIn = function(state, receiver) {
      if (receiver === null || typeof receiver !== "object" && typeof receiver !== "function")
        throw new TypeError("Cannot use 'in' operator on non-object");
      return typeof state === "function" ? receiver === state : state.has(receiver);
    };
    __addDisposableResource = function(env, value, async) {
      if (value !== null && value !== undefined) {
        if (typeof value !== "object" && typeof value !== "function")
          throw new TypeError("Object expected.");
        var dispose;
        if (async) {
          if (!Symbol.asyncDispose)
            throw new TypeError("Symbol.asyncDispose is not defined.");
          dispose = value[Symbol.asyncDispose];
        }
        if (dispose === undefined) {
          if (!Symbol.dispose)
            throw new TypeError("Symbol.dispose is not defined.");
          dispose = value[Symbol.dispose];
        }
        if (typeof dispose !== "function")
          throw new TypeError("Object not disposable.");
        env.stack.push({ value, dispose, async });
      } else if (async) {
        env.stack.push({ async: true });
      }
      return value;
    };
    var _SuppressedError = typeof SuppressedError === "function" ? SuppressedError : function(error, suppressed, message) {
      var e = new Error(message);
      return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
    };
    __disposeResources = function(env) {
      function fail(e) {
        env.error = env.hasError ? new _SuppressedError(e, env.error, "An error was suppressed during disposal.") : e;
        env.hasError = true;
      }
      function next() {
        while (env.stack.length) {
          var rec = env.stack.pop();
          try {
            var result = rec.dispose && rec.dispose.call(rec.value);
            if (rec.async)
              return Promise.resolve(result).then(next, function(e) {
                fail(e);
                return next();
              });
          } catch (e) {
            fail(e);
          }
        }
        if (env.hasError)
          throw env.error;
      }
      return next();
    };
    exporter("__extends", __extends);
    exporter("__assign", __assign);
    exporter("__rest", __rest);
    exporter("__decorate", __decorate);
    exporter("__param", __param);
    exporter("__esDecorate", __esDecorate);
    exporter("__runInitializers", __runInitializers);
    exporter("__propKey", __propKey);
    exporter("__setFunctionName", __setFunctionName);
    exporter("__metadata", __metadata);
    exporter("__awaiter", __awaiter);
    exporter("__generator", __generator);
    exporter("__exportStar", __exportStar);
    exporter("__createBinding", __createBinding);
    exporter("__values", __values);
    exporter("__read", __read);
    exporter("__spread", __spread);
    exporter("__spreadArrays", __spreadArrays);
    exporter("__spreadArray", __spreadArray);
    exporter("__await", __await);
    exporter("__asyncGenerator", __asyncGenerator);
    exporter("__asyncDelegator", __asyncDelegator);
    exporter("__asyncValues", __asyncValues);
    exporter("__makeTemplateObject", __makeTemplateObject);
    exporter("__importStar", __importStar);
    exporter("__importDefault", __importDefault);
    exporter("__classPrivateFieldGet", __classPrivateFieldGet);
    exporter("__classPrivateFieldSet", __classPrivateFieldSet);
    exporter("__classPrivateFieldIn", __classPrivateFieldIn);
    exporter("__addDisposableResource", __addDisposableResource);
    exporter("__disposeResources", __disposeResources);
  });
});

// node_modules/nexus/package.json
var require_package = __commonJS((exports, module) => {
  module.exports = {
    name: "nexus",
    version: "1.3.0",
    description: "Scalable, strongly typed GraphQL schema development",
    keywords: [
      "graphql",
      "schema",
      "types",
      "typescript"
    ],
    homepage: "https://nexusjs.org",
    repository: {
      type: "git",
      url: "git://github.com/graphql-nexus/nexus.git"
    },
    license: "MIT",
    author: {
      name: "Tim Griesser",
      url: "https://github.com/tgriesser"
    },
    files: [
      "src",
      "dist",
      "dist-esm",
      "LICENSE.md",
      "README.md",
      "yarn.lock"
    ],
    main: "dist",
    module: "dist-esm",
    types: "dist/index.d.ts",
    scripts: {
      build: "yarn -s clean && tsc -p tsconfig.cjs.json && tsc -p tsconfig.esm.json",
      clean: "rm -rf dist*",
      "deploy-site": "yarn && yarn build",
      dev: "tsc -p tsconfig.cjs.json -w",
      "dev:examples": "yarn -s link-examples && yarn dev",
      "dev:test": "jest --watch",
      examples: "yarn link-examples && yarn gulp run-examples",
      format: "prettier --write 'src/**/*.ts' 'tests/**/*.ts' 'examples/*/src/**.ts'",
      "format:ci": "prettier --check 'src/**/*.ts' 'tests/**/*.ts' 'examples/*/src/**.ts'",
      "link-examples": "yarn && yarn gulp link-examples",
      lint: "tslint -p tsconfig.json",
      prepublish: "yarn clean && yarn build",
      postpublish: "yarn upgrade-deps || echo 'Oops...'",
      "release:pr": "dripip pr",
      "release:preview": "dripip preview",
      "release:stable": "dripip stable",
      test: "yarn test:types && jest --testTimeout 10000",
      "test:ci": "yarn test:types && jest --maxWorkers 2 --coverage --testTimeout 10000",
      "test:debug": "node --inspect-brk $(yarn bin)/jest -i --watch",
      "test:types": "tsc -p tsconfig.spec.types.json",
      "ts-ast-reader": "cd examples/ts-ast-reader && yarn start",
      "unlink-examples": "yarn && yarn gulp unlink-examples",
      "upgrade-deps": "yarn && yarn gulp upgrade-deps"
    },
    husky: {
      hooks: {
        "pre-commit": "lint-staged"
      }
    },
    "lint-staged": {
      "*.{ts,js,graphql,json,css,md}": [
        "prettier --write",
        "git add"
      ],
      "*package.json": [
        "sort-package-json",
        "git add"
      ]
    },
    dependencies: {
      iterall: "^1.3.0",
      tslib: "^2.0.3"
    },
    devDependencies: {
      "@types/graphql-iso-date": "^3.4.0",
      "@types/graphql-relay": "^0.4.11",
      "@types/jest": "^26.0.15",
      "@types/node": "^10.12.2",
      "@types/prettier": "^1.18.3",
      "@typescript-eslint/eslint-plugin": "2.7.0",
      dripip: "^0.10.0",
      eslint: "^6.6.0",
      "get-port": "^5.1.1",
      graphql: "^16.3.0",
      "graphql-relay": "^0.10.0",
      "graphql-scalars": "^1.14.1",
      gulp: "4.0.2",
      husky: "^1.1.2",
      jest: "^26.6.3",
      "jest-watch-typeahead": "^0.6.1",
      "lint-staged": "^7.3.0",
      prettier: "^2.5.1",
      "sort-package-json": "^1.22.1",
      "ts-jest": "^26.4.4",
      "ts-morph": "^13.0.3",
      "ts-node": "^9.0.0",
      tsd: "^0.13.1",
      tslint: "^5.11.0",
      "tslint-config-prettier": "^1.15.0",
      typescript: "^4.5.5"
    },
    peerDependencies: {
      graphql: "15.x || 16.x"
    }
  };
});

// node_modules/safe-buffer/index.js
var require_safe_buffer = __commonJS((exports, module) => {
  var copyProps = function(src, dst) {
    for (var key in src) {
      dst[key] = src[key];
    }
  };
  var SafeBuffer = function(arg2, encodingOrOffset, length) {
    return Buffer2(arg2, encodingOrOffset, length);
  };
  /*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
  var buffer = import.meta.require("buffer");
  var Buffer2 = buffer.Buffer;
  if (Buffer2.from && Buffer2.alloc && Buffer2.allocUnsafe && Buffer2.allocUnsafeSlow) {
    module.exports = buffer;
  } else {
    copyProps(buffer, exports);
    exports.Buffer = SafeBuffer;
  }
  SafeBuffer.prototype = Object.create(Buffer2.prototype);
  copyProps(Buffer2, SafeBuffer);
  SafeBuffer.from = function(arg2, encodingOrOffset, length) {
    if (typeof arg2 === "number") {
      throw new TypeError("Argument must not be a number");
    }
    return Buffer2(arg2, encodingOrOffset, length);
  };
  SafeBuffer.alloc = function(size, fill, encoding) {
    if (typeof size !== "number") {
      throw new TypeError("Argument must be a number");
    }
    var buf = Buffer2(size);
    if (fill !== undefined) {
      if (typeof encoding === "string") {
        buf.fill(fill, encoding);
      } else {
        buf.fill(fill);
      }
    } else {
      buf.fill(0);
    }
    return buf;
  };
  SafeBuffer.allocUnsafe = function(size) {
    if (typeof size !== "number") {
      throw new TypeError("Argument must be a number");
    }
    return Buffer2(size);
  };
  SafeBuffer.allocUnsafeSlow = function(size) {
    if (typeof size !== "number") {
      throw new TypeError("Argument must be a number");
    }
    return buffer.SlowBuffer(size);
  };
});

// node_modules/websocket-driver/lib/websocket/streams.js
var require_streams = __commonJS((exports) => {
  var Stream = import.meta.require("stream").Stream;
  var util = import.meta.require("util");
  var IO = function(driver) {
    this.readable = this.writable = true;
    this._paused = false;
    this._driver = driver;
  };
  util.inherits(IO, Stream);
  IO.prototype.pause = function() {
    this._paused = true;
    this._driver.messages._paused = true;
  };
  IO.prototype.resume = function() {
    this._paused = false;
    this.emit("drain");
    var messages5 = this._driver.messages;
    messages5._paused = false;
    messages5.emit("drain");
  };
  IO.prototype.write = function(chunk) {
    if (!this.writable)
      return false;
    this._driver.parse(chunk);
    return !this._paused;
  };
  IO.prototype.end = function(chunk) {
    if (!this.writable)
      return;
    if (chunk !== undefined)
      this.write(chunk);
    this.writable = false;
    var messages5 = this._driver.messages;
    if (messages5.readable) {
      messages5.readable = messages5.writable = false;
      messages5.emit("end");
    }
  };
  IO.prototype.destroy = function() {
    this.end();
  };
  var Messages = function(driver) {
    this.readable = this.writable = true;
    this._paused = false;
    this._driver = driver;
  };
  util.inherits(Messages, Stream);
  Messages.prototype.pause = function() {
    this._driver.io._paused = true;
  };
  Messages.prototype.resume = function() {
    this._driver.io._paused = false;
    this._driver.io.emit("drain");
  };
  Messages.prototype.write = function(message) {
    if (!this.writable)
      return false;
    if (typeof message === "string")
      this._driver.text(message);
    else
      this._driver.binary(message);
    return !this._paused;
  };
  Messages.prototype.end = function(message) {
    if (message !== undefined)
      this.write(message);
  };
  Messages.prototype.destroy = function() {
  };
  exports.IO = IO;
  exports.Messages = Messages;
});

// node_modules/websocket-driver/lib/websocket/driver/headers.js
var require_headers = __commonJS((exports, module) => {
  var Headers = function() {
    this.clear();
  };
  Headers.prototype.ALLOWED_DUPLICATES = ["set-cookie", "set-cookie2", "warning", "www-authenticate"];
  Headers.prototype.clear = function() {
    this._sent = {};
    this._lines = [];
  };
  Headers.prototype.set = function(name, value) {
    if (value === undefined)
      return;
    name = this._strip(name);
    value = this._strip(value);
    var key = name.toLowerCase();
    if (!this._sent.hasOwnProperty(key) || this.ALLOWED_DUPLICATES.indexOf(key) >= 0) {
      this._sent[key] = true;
      this._lines.push(name + ": " + value + "\r\n");
    }
  };
  Headers.prototype.toString = function() {
    return this._lines.join("");
  };
  Headers.prototype._strip = function(string) {
    return string.toString().replace(/^ */, "").replace(/ *$/, "");
  };
  module.exports = Headers;
});

// node_modules/websocket-driver/lib/websocket/driver/stream_reader.js
var require_stream_reader = __commonJS((exports, module) => {
  var Buffer2 = require_safe_buffer().Buffer;
  var StreamReader = function() {
    this._queue = [];
    this._queueSize = 0;
    this._offset = 0;
  };
  StreamReader.prototype.put = function(buffer) {
    if (!buffer || buffer.length === 0)
      return;
    if (!Buffer2.isBuffer(buffer))
      buffer = Buffer2.from(buffer);
    this._queue.push(buffer);
    this._queueSize += buffer.length;
  };
  StreamReader.prototype.read = function(length) {
    if (length > this._queueSize)
      return null;
    if (length === 0)
      return Buffer2.alloc(0);
    this._queueSize -= length;
    var queue = this._queue, remain = length, first = queue[0], buffers, buffer;
    if (first.length >= length) {
      if (first.length === length) {
        return queue.shift();
      } else {
        buffer = first.slice(0, length);
        queue[0] = first.slice(length);
        return buffer;
      }
    }
    for (var i = 0, n = queue.length;i < n; i++) {
      if (remain < queue[i].length)
        break;
      remain -= queue[i].length;
    }
    buffers = queue.splice(0, i);
    if (remain > 0 && queue.length > 0) {
      buffers.push(queue[0].slice(0, remain));
      queue[0] = queue[0].slice(remain);
    }
    return Buffer2.concat(buffers, length);
  };
  StreamReader.prototype.eachByte = function(callback, context) {
    var buffer, n, index;
    while (this._queue.length > 0) {
      buffer = this._queue[0];
      n = buffer.length;
      while (this._offset < n) {
        index = this._offset;
        this._offset += 1;
        callback.call(context, buffer[index]);
      }
      this._offset = 0;
      this._queue.shift();
    }
  };
  module.exports = StreamReader;
});

// node_modules/websocket-driver/lib/websocket/driver/base.js
var require_base = __commonJS((exports, module) => {
  var Buffer2 = require_safe_buffer().Buffer;
  var Emitter = import.meta.require("events").EventEmitter;
  var util = import.meta.require("util");
  var streams = require_streams();
  var Headers = require_headers();
  var Reader = require_stream_reader();
  var Base = function(request, url, options) {
    Emitter.call(this);
    Base.validateOptions(options || {}, ["maxLength", "masking", "requireMasking", "protocols"]);
    this._request = request;
    this._reader = new Reader;
    this._options = options || {};
    this._maxLength = this._options.maxLength || this.MAX_LENGTH;
    this._headers = new Headers;
    this.__queue = [];
    this.readyState = 0;
    this.url = url;
    this.io = new streams.IO(this);
    this.messages = new streams.Messages(this);
    this._bindEventListeners();
  };
  util.inherits(Base, Emitter);
  Base.isWebSocket = function(request) {
    var connection = request.headers.connection || "", upgrade = request.headers.upgrade || "";
    return request.method === "GET" && connection.toLowerCase().split(/ *, */).indexOf("upgrade") >= 0 && upgrade.toLowerCase() === "websocket";
  };
  Base.validateOptions = function(options, validKeys) {
    for (var key2 in options) {
      if (validKeys.indexOf(key2) < 0)
        throw new Error("Unrecognized option: " + key2);
    }
  };
  var instance = {
    MAX_LENGTH: 67108863,
    STATES: ["connecting", "open", "closing", "closed"],
    _bindEventListeners: function() {
      var self2 = this;
      this.messages.on("error", function() {
      });
      this.on("message", function(event) {
        var messages5 = self2.messages;
        if (messages5.readable)
          messages5.emit("data", event.data);
      });
      this.on("error", function(error) {
        var messages5 = self2.messages;
        if (messages5.readable)
          messages5.emit("error", error);
      });
      this.on("close", function() {
        var messages5 = self2.messages;
        if (!messages5.readable)
          return;
        messages5.readable = messages5.writable = false;
        messages5.emit("end");
      });
    },
    getState: function() {
      return this.STATES[this.readyState] || null;
    },
    addExtension: function(extension) {
      return false;
    },
    setHeader: function(name, value) {
      if (this.readyState > 0)
        return false;
      this._headers.set(name, value);
      return true;
    },
    start: function() {
      if (this.readyState !== 0)
        return false;
      if (!Base.isWebSocket(this._request))
        return this._failHandshake(new Error("Not a WebSocket request"));
      var response;
      try {
        response = this._handshakeResponse();
      } catch (error) {
        return this._failHandshake(error);
      }
      this._write(response);
      if (this._stage !== -1)
        this._open();
      return true;
    },
    _failHandshake: function(error) {
      var headers = new Headers;
      headers.set("Content-Type", "text/plain");
      headers.set("Content-Length", Buffer2.byteLength(error.message, "utf8"));
      headers = ["HTTP/1.1 400 Bad Request", headers.toString(), error.message];
      this._write(Buffer2.from(headers.join("\r\n"), "utf8"));
      this._fail("protocol_error", error.message);
      return false;
    },
    text: function(message) {
      return this.frame(message);
    },
    binary: function(message) {
      return false;
    },
    ping: function() {
      return false;
    },
    pong: function() {
      return false;
    },
    close: function(reason, code) {
      if (this.readyState !== 1)
        return false;
      this.readyState = 3;
      this.emit("close", new Base.CloseEvent(null, null));
      return true;
    },
    _open: function() {
      this.readyState = 1;
      this.__queue.forEach(function(args7) {
        this.frame.apply(this, args7);
      }, this);
      this.__queue = [];
      this.emit("open", new Base.OpenEvent);
    },
    _queue: function(message) {
      this.__queue.push(message);
      return true;
    },
    _write: function(chunk) {
      var io = this.io;
      if (io.readable)
        io.emit("data", chunk);
    },
    _fail: function(type, message) {
      this.readyState = 2;
      this.emit("error", new Error(message));
      this.close();
    }
  };
  for (key in instance)
    Base.prototype[key] = instance[key];
  var key;
  Base.ConnectEvent = function() {
  };
  Base.OpenEvent = function() {
  };
  Base.CloseEvent = function(code, reason) {
    this.code = code;
    this.reason = reason;
  };
  Base.MessageEvent = function(data) {
    this.data = data;
  };
  Base.PingEvent = function(data) {
    this.data = data;
  };
  Base.PongEvent = function(data) {
    this.data = data;
  };
  module.exports = Base;
});

// node_modules/http-parser-js/http-parser.js
var require_http_parser = __commonJS((exports) => {
  var HTTPParser = function(type) {
    assert.ok(type === HTTPParser.REQUEST || type === HTTPParser.RESPONSE || type === undefined);
    if (type === undefined) {
    } else {
      this.initialize(type);
    }
    this.maxHeaderSize = HTTPParser.maxHeaderSize;
  };
  var parseErrorCode = function(code) {
    var err = new Error("Parse Error");
    err.code = code;
    return err;
  };
  var assert = import.meta.require("assert");
  exports.HTTPParser = HTTPParser;
  HTTPParser.prototype.initialize = function(type, async_resource) {
    assert.ok(type === HTTPParser.REQUEST || type === HTTPParser.RESPONSE);
    this.type = type;
    this.state = type + "_LINE";
    this.info = {
      headers: [],
      upgrade: false
    };
    this.trailers = [];
    this.line = "";
    this.isChunked = false;
    this.connection = "";
    this.headerSize = 0;
    this.body_bytes = null;
    this.isUserCall = false;
    this.hadError = false;
  };
  HTTPParser.encoding = "ascii";
  HTTPParser.maxHeaderSize = 80 * 1024;
  HTTPParser.REQUEST = "REQUEST";
  HTTPParser.RESPONSE = "RESPONSE";
  var kOnHeaders = HTTPParser.kOnHeaders = 1;
  var kOnHeadersComplete = HTTPParser.kOnHeadersComplete = 2;
  var kOnBody = HTTPParser.kOnBody = 3;
  var kOnMessageComplete = HTTPParser.kOnMessageComplete = 4;
  HTTPParser.prototype[kOnHeaders] = HTTPParser.prototype[kOnHeadersComplete] = HTTPParser.prototype[kOnBody] = HTTPParser.prototype[kOnMessageComplete] = function() {
  };
  var compatMode0_12 = true;
  Object.defineProperty(HTTPParser, "kOnExecute", {
    get: function() {
      compatMode0_12 = false;
      return 99;
    }
  });
  var methods = exports.methods = HTTPParser.methods = [
    "DELETE",
    "GET",
    "HEAD",
    "POST",
    "PUT",
    "CONNECT",
    "OPTIONS",
    "TRACE",
    "COPY",
    "LOCK",
    "MKCOL",
    "MOVE",
    "PROPFIND",
    "PROPPATCH",
    "SEARCH",
    "UNLOCK",
    "BIND",
    "REBIND",
    "UNBIND",
    "ACL",
    "REPORT",
    "MKACTIVITY",
    "CHECKOUT",
    "MERGE",
    "M-SEARCH",
    "NOTIFY",
    "SUBSCRIBE",
    "UNSUBSCRIBE",
    "PATCH",
    "PURGE",
    "MKCALENDAR",
    "LINK",
    "UNLINK",
    "SOURCE"
  ];
  var method_connect = methods.indexOf("CONNECT");
  HTTPParser.prototype.reinitialize = HTTPParser;
  HTTPParser.prototype.close = HTTPParser.prototype.pause = HTTPParser.prototype.resume = HTTPParser.prototype.free = function() {
  };
  HTTPParser.prototype._compatMode0_11 = false;
  HTTPParser.prototype.getAsyncId = function() {
    return 0;
  };
  var headerState = {
    REQUEST_LINE: true,
    RESPONSE_LINE: true,
    HEADER: true
  };
  HTTPParser.prototype.execute = function(chunk, start, length) {
    if (!(this instanceof HTTPParser)) {
      throw new TypeError("not a HTTPParser");
    }
    start = start || 0;
    length = typeof length === "number" ? length : chunk.length;
    this.chunk = chunk;
    this.offset = start;
    var end = this.end = start + length;
    try {
      while (this.offset < end) {
        if (this[this.state]()) {
          break;
        }
      }
    } catch (err) {
      if (this.isUserCall) {
        throw err;
      }
      this.hadError = true;
      return err;
    }
    this.chunk = null;
    length = this.offset - start;
    if (headerState[this.state]) {
      this.headerSize += length;
      if (this.headerSize > (this.maxHeaderSize || HTTPParser.maxHeaderSize)) {
        return new Error("max header size exceeded");
      }
    }
    return length;
  };
  var stateFinishAllowed = {
    REQUEST_LINE: true,
    RESPONSE_LINE: true,
    BODY_RAW: true
  };
  HTTPParser.prototype.finish = function() {
    if (this.hadError) {
      return;
    }
    if (!stateFinishAllowed[this.state]) {
      return new Error("invalid state for EOF");
    }
    if (this.state === "BODY_RAW") {
      this.userCall()(this[kOnMessageComplete]());
    }
  };
  HTTPParser.prototype.consume = HTTPParser.prototype.unconsume = HTTPParser.prototype.getCurrentBuffer = function() {
  };
  HTTPParser.prototype.userCall = function() {
    this.isUserCall = true;
    var self2 = this;
    return function(ret) {
      self2.isUserCall = false;
      return ret;
    };
  };
  HTTPParser.prototype.nextRequest = function() {
    this.userCall()(this[kOnMessageComplete]());
    this.reinitialize(this.type);
  };
  HTTPParser.prototype.consumeLine = function() {
    var end = this.end, chunk = this.chunk;
    for (var i = this.offset;i < end; i++) {
      if (chunk[i] === 10) {
        var line = this.line + chunk.toString(HTTPParser.encoding, this.offset, i);
        if (line.charAt(line.length - 1) === "\r") {
          line = line.substr(0, line.length - 1);
        }
        this.line = "";
        this.offset = i + 1;
        return line;
      }
    }
    this.line += chunk.toString(HTTPParser.encoding, this.offset, this.end);
    this.offset = this.end;
  };
  var headerExp = /^([^: \t]+):[ \t]*((?:.*[^ \t])|)/;
  var headerContinueExp = /^[ \t]+(.*[^ \t])/;
  HTTPParser.prototype.parseHeader = function(line, headers) {
    if (line.indexOf("\r") !== -1) {
      throw parseErrorCode("HPE_LF_EXPECTED");
    }
    var match = headerExp.exec(line);
    var k = match && match[1];
    if (k) {
      headers.push(k);
      headers.push(match[2]);
    } else {
      var matchContinue = headerContinueExp.exec(line);
      if (matchContinue && headers.length) {
        if (headers[headers.length - 1]) {
          headers[headers.length - 1] += " ";
        }
        headers[headers.length - 1] += matchContinue[1];
      }
    }
  };
  var requestExp = /^([A-Z-]+) ([^ ]+) HTTP\/(\d)\.(\d)$/;
  HTTPParser.prototype.REQUEST_LINE = function() {
    var line = this.consumeLine();
    if (!line) {
      return;
    }
    var match = requestExp.exec(line);
    if (match === null) {
      throw parseErrorCode("HPE_INVALID_CONSTANT");
    }
    this.info.method = this._compatMode0_11 ? match[1] : methods.indexOf(match[1]);
    if (this.info.method === -1) {
      throw new Error("invalid request method");
    }
    this.info.url = match[2];
    this.info.versionMajor = +match[3];
    this.info.versionMinor = +match[4];
    this.body_bytes = 0;
    this.state = "HEADER";
  };
  var responseExp = /^HTTP\/(\d)\.(\d) (\d{3}) ?(.*)$/;
  HTTPParser.prototype.RESPONSE_LINE = function() {
    var line = this.consumeLine();
    if (!line) {
      return;
    }
    var match = responseExp.exec(line);
    if (match === null) {
      throw parseErrorCode("HPE_INVALID_CONSTANT");
    }
    this.info.versionMajor = +match[1];
    this.info.versionMinor = +match[2];
    var statusCode = this.info.statusCode = +match[3];
    this.info.statusMessage = match[4];
    if ((statusCode / 100 | 0) === 1 || statusCode === 204 || statusCode === 304) {
      this.body_bytes = 0;
    }
    this.state = "HEADER";
  };
  HTTPParser.prototype.shouldKeepAlive = function() {
    if (this.info.versionMajor > 0 && this.info.versionMinor > 0) {
      if (this.connection.indexOf("close") !== -1) {
        return false;
      }
    } else if (this.connection.indexOf("keep-alive") === -1) {
      return false;
    }
    if (this.body_bytes !== null || this.isChunked) {
      return true;
    }
    return false;
  };
  HTTPParser.prototype.HEADER = function() {
    var line = this.consumeLine();
    if (line === undefined) {
      return;
    }
    var info = this.info;
    if (line) {
      this.parseHeader(line, info.headers);
    } else {
      var headers = info.headers;
      var hasContentLength = false;
      var currentContentLengthValue;
      var hasUpgradeHeader = false;
      for (var i = 0;i < headers.length; i += 2) {
        switch (headers[i].toLowerCase()) {
          case "transfer-encoding":
            this.isChunked = headers[i + 1].toLowerCase() === "chunked";
            break;
          case "content-length":
            currentContentLengthValue = +headers[i + 1];
            if (hasContentLength) {
              if (currentContentLengthValue !== this.body_bytes) {
                throw parseErrorCode("HPE_UNEXPECTED_CONTENT_LENGTH");
              }
            } else {
              hasContentLength = true;
              this.body_bytes = currentContentLengthValue;
            }
            break;
          case "connection":
            this.connection += headers[i + 1].toLowerCase();
            break;
          case "upgrade":
            hasUpgradeHeader = true;
            break;
        }
      }
      if (this.isChunked && hasContentLength) {
        hasContentLength = false;
        this.body_bytes = null;
      }
      if (hasUpgradeHeader && this.connection.indexOf("upgrade") != -1) {
        info.upgrade = this.type === HTTPParser.REQUEST || info.statusCode === 101;
      } else {
        info.upgrade = info.method === method_connect;
      }
      if (this.isChunked && info.upgrade) {
        this.isChunked = false;
      }
      info.shouldKeepAlive = this.shouldKeepAlive();
      var skipBody;
      if (compatMode0_12) {
        skipBody = this.userCall()(this[kOnHeadersComplete](info));
      } else {
        skipBody = this.userCall()(this[kOnHeadersComplete](info.versionMajor, info.versionMinor, info.headers, info.method, info.url, info.statusCode, info.statusMessage, info.upgrade, info.shouldKeepAlive));
      }
      if (skipBody === 2) {
        this.nextRequest();
        return true;
      } else if (this.isChunked && !skipBody) {
        this.state = "BODY_CHUNKHEAD";
      } else if (skipBody || this.body_bytes === 0) {
        this.nextRequest();
        return info.upgrade;
      } else if (this.body_bytes === null) {
        this.state = "BODY_RAW";
      } else {
        this.state = "BODY_SIZED";
      }
    }
  };
  HTTPParser.prototype.BODY_CHUNKHEAD = function() {
    var line = this.consumeLine();
    if (line === undefined) {
      return;
    }
    this.body_bytes = parseInt(line, 16);
    if (!this.body_bytes) {
      this.state = "BODY_CHUNKTRAILERS";
    } else {
      this.state = "BODY_CHUNK";
    }
  };
  HTTPParser.prototype.BODY_CHUNK = function() {
    var length = Math.min(this.end - this.offset, this.body_bytes);
    this.userCall()(this[kOnBody](this.chunk, this.offset, length));
    this.offset += length;
    this.body_bytes -= length;
    if (!this.body_bytes) {
      this.state = "BODY_CHUNKEMPTYLINE";
    }
  };
  HTTPParser.prototype.BODY_CHUNKEMPTYLINE = function() {
    var line = this.consumeLine();
    if (line === undefined) {
      return;
    }
    assert.equal(line, "");
    this.state = "BODY_CHUNKHEAD";
  };
  HTTPParser.prototype.BODY_CHUNKTRAILERS = function() {
    var line = this.consumeLine();
    if (line === undefined) {
      return;
    }
    if (line) {
      this.parseHeader(line, this.trailers);
    } else {
      if (this.trailers.length) {
        this.userCall()(this[kOnHeaders](this.trailers, ""));
      }
      this.nextRequest();
    }
  };
  HTTPParser.prototype.BODY_RAW = function() {
    var length = this.end - this.offset;
    this.userCall()(this[kOnBody](this.chunk, this.offset, length));
    this.offset = this.end;
  };
  HTTPParser.prototype.BODY_SIZED = function() {
    var length = Math.min(this.end - this.offset, this.body_bytes);
    this.userCall()(this[kOnBody](this.chunk, this.offset, length));
    this.offset += length;
    this.body_bytes -= length;
    if (!this.body_bytes) {
      this.nextRequest();
    }
  };
  ["Headers", "HeadersComplete", "Body", "MessageComplete"].forEach(function(name) {
    var k = HTTPParser["kOn" + name];
    Object.defineProperty(HTTPParser.prototype, "on" + name, {
      get: function() {
        return this[k];
      },
      set: function(to) {
        this._compatMode0_11 = true;
        method_connect = "CONNECT";
        return this[k] = to;
      }
    });
  });
});

// node_modules/websocket-driver/lib/websocket/http_parser.js
var require_http_parser2 = __commonJS((exports, module) => {
  var NodeHTTPParser = require_http_parser().HTTPParser;
  var Buffer2 = require_safe_buffer().Buffer;
  var TYPES = {
    request: NodeHTTPParser.REQUEST || "request",
    response: NodeHTTPParser.RESPONSE || "response"
  };
  var HttpParser = function(type) {
    this._type = type;
    this._parser = new NodeHTTPParser(TYPES[type]);
    this._complete = false;
    this.headers = {};
    var current = null, self2 = this;
    this._parser.onHeaderField = function(b, start, length) {
      current = b.toString("utf8", start, start + length).toLowerCase();
    };
    this._parser.onHeaderValue = function(b, start, length) {
      var value = b.toString("utf8", start, start + length);
      if (self2.headers.hasOwnProperty(current))
        self2.headers[current] += ", " + value;
      else
        self2.headers[current] = value;
    };
    this._parser.onHeadersComplete = this._parser[NodeHTTPParser.kOnHeadersComplete] = function(majorVersion, minorVersion, headers, method, pathname, statusCode) {
      var info = arguments[0];
      if (typeof info === "object") {
        method = info.method;
        pathname = info.url;
        statusCode = info.statusCode;
        headers = info.headers;
      }
      self2.method = typeof method === "number" ? HttpParser.METHODS[method] : method;
      self2.statusCode = statusCode;
      self2.url = pathname;
      if (!headers)
        return;
      for (var i = 0, n = headers.length, key, value;i < n; i += 2) {
        key = headers[i].toLowerCase();
        value = headers[i + 1];
        if (self2.headers.hasOwnProperty(key))
          self2.headers[key] += ", " + value;
        else
          self2.headers[key] = value;
      }
      self2._complete = true;
    };
  };
  HttpParser.METHODS = {
    0: "DELETE",
    1: "GET",
    2: "HEAD",
    3: "POST",
    4: "PUT",
    5: "CONNECT",
    6: "OPTIONS",
    7: "TRACE",
    8: "COPY",
    9: "LOCK",
    10: "MKCOL",
    11: "MOVE",
    12: "PROPFIND",
    13: "PROPPATCH",
    14: "SEARCH",
    15: "UNLOCK",
    16: "BIND",
    17: "REBIND",
    18: "UNBIND",
    19: "ACL",
    20: "REPORT",
    21: "MKACTIVITY",
    22: "CHECKOUT",
    23: "MERGE",
    24: "M-SEARCH",
    25: "NOTIFY",
    26: "SUBSCRIBE",
    27: "UNSUBSCRIBE",
    28: "PATCH",
    29: "PURGE",
    30: "MKCALENDAR",
    31: "LINK",
    32: "UNLINK"
  };
  var VERSION = process.version ? process.version.match(/[0-9]+/g).map(function(n) {
    return parseInt(n, 10);
  }) : [];
  if (VERSION[0] === 0 && VERSION[1] === 12) {
    HttpParser.METHODS[16] = "REPORT";
    HttpParser.METHODS[17] = "MKACTIVITY";
    HttpParser.METHODS[18] = "CHECKOUT";
    HttpParser.METHODS[19] = "MERGE";
    HttpParser.METHODS[20] = "M-SEARCH";
    HttpParser.METHODS[21] = "NOTIFY";
    HttpParser.METHODS[22] = "SUBSCRIBE";
    HttpParser.METHODS[23] = "UNSUBSCRIBE";
    HttpParser.METHODS[24] = "PATCH";
    HttpParser.METHODS[25] = "PURGE";
  }
  HttpParser.prototype.isComplete = function() {
    return this._complete;
  };
  HttpParser.prototype.parse = function(chunk) {
    var consumed = this._parser.execute(chunk, 0, chunk.length);
    if (typeof consumed !== "number") {
      this.error = consumed;
      this._complete = true;
      return;
    }
    if (this._complete)
      this.body = consumed < chunk.length ? chunk.slice(consumed) : Buffer2.alloc(0);
  };
  module.exports = HttpParser;
});

// node_modules/websocket-extensions/lib/parser.js
var require_parser = __commonJS((exports, module) => {
  var TOKEN = /([!#\$%&'\*\+\-\.\^_`\|~0-9A-Za-z]+)/;
  var NOTOKEN = /([^!#\$%&'\*\+\-\.\^_`\|~0-9A-Za-z])/g;
  var QUOTED = /"((?:\\[\x00-\x7f]|[^\x00-\x08\x0a-\x1f\x7f"\\])*)"/;
  var PARAM = new RegExp(TOKEN.source + "(?:=(?:" + TOKEN.source + "|" + QUOTED.source + "))?");
  var EXT = new RegExp(TOKEN.source + "(?: *; *" + PARAM.source + ")*", "g");
  var EXT_LIST = new RegExp("^" + EXT.source + "(?: *, *" + EXT.source + ")*$");
  var NUMBER = /^-?(0|[1-9][0-9]*)(\.[0-9]+)?$/;
  var hasOwnProperty2 = Object.prototype.hasOwnProperty;
  var Parser2 = {
    parseHeader: function(header) {
      var offers = new Offers;
      if (header === "" || header === undefined)
        return offers;
      if (!EXT_LIST.test(header))
        throw new SyntaxError("Invalid Sec-WebSocket-Extensions header: " + header);
      var values2 = header.match(EXT);
      values2.forEach(function(value) {
        var params = value.match(new RegExp(PARAM.source, "g")), name = params.shift(), offer = {};
        params.forEach(function(param) {
          var args7 = param.match(PARAM), key = args7[1], data;
          if (args7[2] !== undefined) {
            data = args7[2];
          } else if (args7[3] !== undefined) {
            data = args7[3].replace(/\\/g, "");
          } else {
            data = true;
          }
          if (NUMBER.test(data))
            data = parseFloat(data);
          if (hasOwnProperty2.call(offer, key)) {
            offer[key] = [].concat(offer[key]);
            offer[key].push(data);
          } else {
            offer[key] = data;
          }
        }, this);
        offers.push(name, offer);
      }, this);
      return offers;
    },
    serializeParams: function(name, params) {
      var values2 = [];
      var print2 = function(key2, value) {
        if (value instanceof Array) {
          value.forEach(function(v) {
            print2(key2, v);
          });
        } else if (value === true) {
          values2.push(key2);
        } else if (typeof value === "number") {
          values2.push(key2 + "=" + value);
        } else if (NOTOKEN.test(value)) {
          values2.push(key2 + '="' + value.replace(/"/g, '\\"') + '"');
        } else {
          values2.push(key2 + "=" + value);
        }
      };
      for (var key in params)
        print2(key, params[key]);
      return [name].concat(values2).join("; ");
    }
  };
  var Offers = function() {
    this._byName = {};
    this._inOrder = [];
  };
  Offers.prototype.push = function(name, params) {
    if (!hasOwnProperty2.call(this._byName, name))
      this._byName[name] = [];
    this._byName[name].push(params);
    this._inOrder.push({ name, params });
  };
  Offers.prototype.eachOffer = function(callback, context) {
    var list5 = this._inOrder;
    for (var i = 0, n = list5.length;i < n; i++)
      callback.call(context, list5[i].name, list5[i].params);
  };
  Offers.prototype.byName = function(name) {
    return this._byName[name] || [];
  };
  Offers.prototype.toArray = function() {
    return this._inOrder.slice();
  };
  module.exports = Parser2;
});

// node_modules/websocket-extensions/lib/pipeline/ring_buffer.js
var require_ring_buffer = __commonJS((exports, module) => {
  var RingBuffer = function(bufferSize) {
    this._bufferSize = bufferSize;
    this.clear();
  };
  RingBuffer.prototype.clear = function() {
    this._buffer = new Array(this._bufferSize);
    this._ringOffset = 0;
    this._ringSize = this._bufferSize;
    this._head = 0;
    this._tail = 0;
    this.length = 0;
  };
  RingBuffer.prototype.push = function(value) {
    var expandBuffer = false, expandRing = false;
    if (this._ringSize < this._bufferSize) {
      expandBuffer = this._tail === 0;
    } else if (this._ringOffset === this._ringSize) {
      expandBuffer = true;
      expandRing = this._tail === 0;
    }
    if (expandBuffer) {
      this._tail = this._bufferSize;
      this._buffer = this._buffer.concat(new Array(this._bufferSize));
      this._bufferSize = this._buffer.length;
      if (expandRing)
        this._ringSize = this._bufferSize;
    }
    this._buffer[this._tail] = value;
    this.length += 1;
    if (this._tail < this._ringSize)
      this._ringOffset += 1;
    this._tail = (this._tail + 1) % this._bufferSize;
  };
  RingBuffer.prototype.peek = function() {
    if (this.length === 0)
      return;
    return this._buffer[this._head];
  };
  RingBuffer.prototype.shift = function() {
    if (this.length === 0)
      return;
    var value = this._buffer[this._head];
    this._buffer[this._head] = undefined;
    this.length -= 1;
    this._ringOffset -= 1;
    if (this._ringOffset === 0 && this.length > 0) {
      this._head = this._ringSize;
      this._ringOffset = this.length;
      this._ringSize = this._bufferSize;
    } else {
      this._head = (this._head + 1) % this._ringSize;
    }
    return value;
  };
  module.exports = RingBuffer;
});

// node_modules/websocket-extensions/lib/pipeline/functor.js
var require_functor = __commonJS((exports, module) => {
  var RingBuffer = require_ring_buffer();
  var Functor = function(session, method) {
    this._session = session;
    this._method = method;
    this._queue = new RingBuffer(Functor.QUEUE_SIZE);
    this._stopped = false;
    this.pending = 0;
  };
  Functor.QUEUE_SIZE = 8;
  Functor.prototype.call = function(error, message, callback, context) {
    if (this._stopped)
      return;
    var record = { error, message, callback, context, done: false }, called = false, self2 = this;
    this._queue.push(record);
    if (record.error) {
      record.done = true;
      this._stop();
      return this._flushQueue();
    }
    var handler = function(err, msg) {
      if (!(called ^ (called = true)))
        return;
      if (err) {
        self2._stop();
        record.error = err;
        record.message = null;
      } else {
        record.message = msg;
      }
      record.done = true;
      self2._flushQueue();
    };
    try {
      this._session[this._method](message, handler);
    } catch (err) {
      handler(err);
    }
  };
  Functor.prototype._stop = function() {
    this.pending = this._queue.length;
    this._stopped = true;
  };
  Functor.prototype._flushQueue = function() {
    var queue = this._queue, record;
    while (queue.length > 0 && queue.peek().done) {
      record = queue.shift();
      if (record.error) {
        this.pending = 0;
        queue.clear();
      } else {
        this.pending -= 1;
      }
      record.callback.call(record.context, record.error, record.message);
    }
  };
  module.exports = Functor;
});

// node_modules/websocket-extensions/lib/pipeline/pledge.js
var require_pledge = __commonJS((exports, module) => {
  var RingBuffer = require_ring_buffer();
  var Pledge = function() {
    this._complete = false;
    this._callbacks = new RingBuffer(Pledge.QUEUE_SIZE);
  };
  Pledge.QUEUE_SIZE = 4;
  Pledge.all = function(list5) {
    var pledge = new Pledge, pending = list5.length, n = pending;
    if (pending === 0)
      pledge.done();
    while (n--)
      list5[n].then(function() {
        pending -= 1;
        if (pending === 0)
          pledge.done();
      });
    return pledge;
  };
  Pledge.prototype.then = function(callback) {
    if (this._complete)
      callback();
    else
      this._callbacks.push(callback);
  };
  Pledge.prototype.done = function() {
    this._complete = true;
    var callbacks = this._callbacks, callback;
    while (callback = callbacks.shift())
      callback();
  };
  module.exports = Pledge;
});

// node_modules/websocket-extensions/lib/pipeline/cell.js
var require_cell = __commonJS((exports, module) => {
  var Functor = require_functor();
  var Pledge = require_pledge();
  var Cell = function(tuple) {
    this._ext = tuple[0];
    this._session = tuple[1];
    this._functors = {
      incoming: new Functor(this._session, "processIncomingMessage"),
      outgoing: new Functor(this._session, "processOutgoingMessage")
    };
  };
  Cell.prototype.pending = function(direction) {
    var functor = this._functors[direction];
    if (!functor._stopped)
      functor.pending += 1;
  };
  Cell.prototype.incoming = function(error, message, callback, context) {
    this._exec("incoming", error, message, callback, context);
  };
  Cell.prototype.outgoing = function(error, message, callback, context) {
    this._exec("outgoing", error, message, callback, context);
  };
  Cell.prototype.close = function() {
    this._closed = this._closed || new Pledge;
    this._doClose();
    return this._closed;
  };
  Cell.prototype._exec = function(direction, error, message, callback, context) {
    this._functors[direction].call(error, message, function(err, msg) {
      if (err)
        err.message = this._ext.name + ": " + err.message;
      callback.call(context, err, msg);
      this._doClose();
    }, this);
  };
  Cell.prototype._doClose = function() {
    var fin = this._functors.incoming, fout = this._functors.outgoing;
    if (!this._closed || fin.pending + fout.pending !== 0)
      return;
    if (this._session)
      this._session.close();
    this._session = null;
    this._closed.done();
  };
  module.exports = Cell;
});

// node_modules/websocket-extensions/lib/pipeline/index.js
var require_pipeline = __commonJS((exports, module) => {
  var Cell = require_cell();
  var Pledge = require_pledge();
  var Pipeline = function(sessions) {
    this._cells = sessions.map(function(session) {
      return new Cell(session);
    });
    this._stopped = { incoming: false, outgoing: false };
  };
  Pipeline.prototype.processIncomingMessage = function(message, callback, context) {
    if (this._stopped.incoming)
      return;
    this._loop("incoming", this._cells.length - 1, -1, -1, message, callback, context);
  };
  Pipeline.prototype.processOutgoingMessage = function(message, callback, context) {
    if (this._stopped.outgoing)
      return;
    this._loop("outgoing", 0, this._cells.length, 1, message, callback, context);
  };
  Pipeline.prototype.close = function(callback, context) {
    this._stopped = { incoming: true, outgoing: true };
    var closed = this._cells.map(function(a) {
      return a.close();
    });
    if (callback)
      Pledge.all(closed).then(function() {
        callback.call(context);
      });
  };
  Pipeline.prototype._loop = function(direction, start, end, step, message, callback, context) {
    var cells = this._cells, n = cells.length, self2 = this;
    while (n--)
      cells[n].pending(direction);
    var pipe = function(index, error, msg) {
      if (index === end)
        return callback.call(context, error, msg);
      cells[index][direction](error, msg, function(err, m) {
        if (err)
          self2._stopped[direction] = true;
        pipe(index + step, err, m);
      });
    };
    pipe(start, null, message);
  };
  module.exports = Pipeline;
});

// node_modules/websocket-extensions/lib/websocket_extensions.js
var require_websocket_extensions = __commonJS((exports, module) => {
  var Parser2 = require_parser();
  var Pipeline = require_pipeline();
  var Extensions = function() {
    this._rsv1 = this._rsv2 = this._rsv3 = null;
    this._byName = {};
    this._inOrder = [];
    this._sessions = [];
    this._index = {};
  };
  Extensions.MESSAGE_OPCODES = [1, 2];
  var instance = {
    add: function(ext) {
      if (typeof ext.name !== "string")
        throw new TypeError("extension.name must be a string");
      if (ext.type !== "permessage")
        throw new TypeError('extension.type must be "permessage"');
      if (typeof ext.rsv1 !== "boolean")
        throw new TypeError("extension.rsv1 must be true or false");
      if (typeof ext.rsv2 !== "boolean")
        throw new TypeError("extension.rsv2 must be true or false");
      if (typeof ext.rsv3 !== "boolean")
        throw new TypeError("extension.rsv3 must be true or false");
      if (this._byName.hasOwnProperty(ext.name))
        throw new TypeError('An extension with name "' + ext.name + '" is already registered');
      this._byName[ext.name] = ext;
      this._inOrder.push(ext);
    },
    generateOffer: function() {
      var sessions = [], offer = [], index = {};
      this._inOrder.forEach(function(ext) {
        var session = ext.createClientSession();
        if (!session)
          return;
        var record = [ext, session];
        sessions.push(record);
        index[ext.name] = record;
        var offers = session.generateOffer();
        offers = offers ? [].concat(offers) : [];
        offers.forEach(function(off) {
          offer.push(Parser2.serializeParams(ext.name, off));
        }, this);
      }, this);
      this._sessions = sessions;
      this._index = index;
      return offer.length > 0 ? offer.join(", ") : null;
    },
    activate: function(header) {
      var responses = Parser2.parseHeader(header), sessions = [];
      responses.eachOffer(function(name, params) {
        var record = this._index[name];
        if (!record)
          throw new Error('Server sent an extension response for unknown extension "' + name + '"');
        var ext = record[0], session = record[1], reserved = this._reserved(ext);
        if (reserved)
          throw new Error("Server sent two extension responses that use the RSV" + reserved[0] + ' bit: "' + reserved[1] + '" and "' + ext.name + '"');
        if (session.activate(params) !== true)
          throw new Error("Server sent unacceptable extension parameters: " + Parser2.serializeParams(name, params));
        this._reserve(ext);
        sessions.push(record);
      }, this);
      this._sessions = sessions;
      this._pipeline = new Pipeline(sessions);
    },
    generateResponse: function(header) {
      var sessions = [], response = [], offers = Parser2.parseHeader(header);
      this._inOrder.forEach(function(ext) {
        var offer = offers.byName(ext.name);
        if (offer.length === 0 || this._reserved(ext))
          return;
        var session = ext.createServerSession(offer);
        if (!session)
          return;
        this._reserve(ext);
        sessions.push([ext, session]);
        response.push(Parser2.serializeParams(ext.name, session.generateResponse()));
      }, this);
      this._sessions = sessions;
      this._pipeline = new Pipeline(sessions);
      return response.length > 0 ? response.join(", ") : null;
    },
    validFrameRsv: function(frame) {
      var allowed = { rsv1: false, rsv2: false, rsv3: false }, ext;
      if (Extensions.MESSAGE_OPCODES.indexOf(frame.opcode) >= 0) {
        for (var i = 0, n = this._sessions.length;i < n; i++) {
          ext = this._sessions[i][0];
          allowed.rsv1 = allowed.rsv1 || ext.rsv1;
          allowed.rsv2 = allowed.rsv2 || ext.rsv2;
          allowed.rsv3 = allowed.rsv3 || ext.rsv3;
        }
      }
      return (allowed.rsv1 || !frame.rsv1) && (allowed.rsv2 || !frame.rsv2) && (allowed.rsv3 || !frame.rsv3);
    },
    processIncomingMessage: function(message, callback, context) {
      this._pipeline.processIncomingMessage(message, callback, context);
    },
    processOutgoingMessage: function(message, callback, context) {
      this._pipeline.processOutgoingMessage(message, callback, context);
    },
    close: function(callback, context) {
      if (!this._pipeline)
        return callback.call(context);
      this._pipeline.close(callback, context);
    },
    _reserve: function(ext) {
      this._rsv1 = this._rsv1 || ext.rsv1 && ext.name;
      this._rsv2 = this._rsv2 || ext.rsv2 && ext.name;
      this._rsv3 = this._rsv3 || ext.rsv3 && ext.name;
    },
    _reserved: function(ext) {
      if (this._rsv1 && ext.rsv1)
        return [1, this._rsv1];
      if (this._rsv2 && ext.rsv2)
        return [2, this._rsv2];
      if (this._rsv3 && ext.rsv3)
        return [3, this._rsv3];
      return false;
    }
  };
  for (key in instance)
    Extensions.prototype[key] = instance[key];
  var key;
  module.exports = Extensions;
});

// node_modules/websocket-driver/lib/websocket/driver/hybi/frame.js
var require_frame = __commonJS((exports, module) => {
  var Frame = function() {
  };
  var instance = {
    final: false,
    rsv1: false,
    rsv2: false,
    rsv3: false,
    opcode: null,
    masked: false,
    maskingKey: null,
    lengthBytes: 1,
    length: 0,
    payload: null
  };
  for (key in instance)
    Frame.prototype[key] = instance[key];
  var key;
  module.exports = Frame;
});

// node_modules/websocket-driver/lib/websocket/driver/hybi/message.js
var require_message = __commonJS((exports, module) => {
  var Buffer2 = require_safe_buffer().Buffer;
  var Message = function() {
    this.rsv1 = false;
    this.rsv2 = false;
    this.rsv3 = false;
    this.opcode = null;
    this.length = 0;
    this._chunks = [];
  };
  var instance = {
    read: function() {
      return this.data = this.data || Buffer2.concat(this._chunks, this.length);
    },
    pushFrame: function(frame) {
      this.rsv1 = this.rsv1 || frame.rsv1;
      this.rsv2 = this.rsv2 || frame.rsv2;
      this.rsv3 = this.rsv3 || frame.rsv3;
      if (this.opcode === null)
        this.opcode = frame.opcode;
      this._chunks.push(frame.payload);
      this.length += frame.length;
    }
  };
  for (key in instance)
    Message.prototype[key] = instance[key];
  var key;
  module.exports = Message;
});

// node_modules/websocket-driver/lib/websocket/driver/hybi.js
var require_hybi = __commonJS((exports, module) => {
  var Buffer2 = require_safe_buffer().Buffer;
  var crypto = import.meta.require("crypto");
  var util = import.meta.require("util");
  var Extensions = require_websocket_extensions();
  var Base = require_base();
  var Frame = require_frame();
  var Message = require_message();
  var Hybi = function(request, url, options) {
    Base.apply(this, arguments);
    this._extensions = new Extensions;
    this._stage = 0;
    this._masking = this._options.masking;
    this._protocols = this._options.protocols || [];
    this._requireMasking = this._options.requireMasking;
    this._pingCallbacks = {};
    if (typeof this._protocols === "string")
      this._protocols = this._protocols.split(/ *, */);
    if (!this._request)
      return;
    var protos = this._request.headers["sec-websocket-protocol"], supported = this._protocols;
    if (protos !== undefined) {
      if (typeof protos === "string")
        protos = protos.split(/ *, */);
      this.protocol = protos.filter(function(p) {
        return supported.indexOf(p) >= 0;
      })[0];
    }
    this.version = "hybi-" + Hybi.VERSION;
  };
  util.inherits(Hybi, Base);
  Hybi.VERSION = "13";
  Hybi.mask = function(payload, mask, offset) {
    if (!mask || mask.length === 0)
      return payload;
    offset = offset || 0;
    for (var i = 0, n = payload.length - offset;i < n; i++) {
      payload[offset + i] = payload[offset + i] ^ mask[i % 4];
    }
    return payload;
  };
  Hybi.generateAccept = function(key2) {
    var sha1 = crypto.createHash("sha1");
    sha1.update(key2 + Hybi.GUID);
    return sha1.digest("base64");
  };
  Hybi.GUID = "258EAFA5-E914-47DA-95CA-C5AB0DC85B11";
  var instance = {
    FIN: 128,
    MASK: 128,
    RSV1: 64,
    RSV2: 32,
    RSV3: 16,
    OPCODE: 15,
    LENGTH: 127,
    OPCODES: {
      continuation: 0,
      text: 1,
      binary: 2,
      close: 8,
      ping: 9,
      pong: 10
    },
    OPCODE_CODES: [0, 1, 2, 8, 9, 10],
    MESSAGE_OPCODES: [0, 1, 2],
    OPENING_OPCODES: [1, 2],
    ERRORS: {
      normal_closure: 1000,
      going_away: 1001,
      protocol_error: 1002,
      unacceptable: 1003,
      encoding_error: 1007,
      policy_violation: 1008,
      too_large: 1009,
      extension_error: 1010,
      unexpected_condition: 1011
    },
    ERROR_CODES: [1000, 1001, 1002, 1003, 1007, 1008, 1009, 1010, 1011],
    DEFAULT_ERROR_CODE: 1000,
    MIN_RESERVED_ERROR: 3000,
    MAX_RESERVED_ERROR: 4999,
    UTF8_MATCH: /^([\x00-\x7F]|[\xC2-\xDF][\x80-\xBF]|\xE0[\xA0-\xBF][\x80-\xBF]|[\xE1-\xEC\xEE\xEF][\x80-\xBF]{2}|\xED[\x80-\x9F][\x80-\xBF]|\xF0[\x90-\xBF][\x80-\xBF]{2}|[\xF1-\xF3][\x80-\xBF]{3}|\xF4[\x80-\x8F][\x80-\xBF]{2})*$/,
    addExtension: function(extension) {
      this._extensions.add(extension);
      return true;
    },
    parse: function(chunk) {
      this._reader.put(chunk);
      var buffer = true;
      while (buffer) {
        switch (this._stage) {
          case 0:
            buffer = this._reader.read(1);
            if (buffer)
              this._parseOpcode(buffer[0]);
            break;
          case 1:
            buffer = this._reader.read(1);
            if (buffer)
              this._parseLength(buffer[0]);
            break;
          case 2:
            buffer = this._reader.read(this._frame.lengthBytes);
            if (buffer)
              this._parseExtendedLength(buffer);
            break;
          case 3:
            buffer = this._reader.read(4);
            if (buffer) {
              this._stage = 4;
              this._frame.maskingKey = buffer;
            }
            break;
          case 4:
            buffer = this._reader.read(this._frame.length);
            if (buffer) {
              this._stage = 0;
              this._emitFrame(buffer);
            }
            break;
          default:
            buffer = null;
        }
      }
    },
    text: function(message) {
      if (this.readyState > 1)
        return false;
      return this.frame(message, "text");
    },
    binary: function(message) {
      if (this.readyState > 1)
        return false;
      return this.frame(message, "binary");
    },
    ping: function(message, callback) {
      if (this.readyState > 1)
        return false;
      message = message || "";
      if (callback)
        this._pingCallbacks[message] = callback;
      return this.frame(message, "ping");
    },
    pong: function(message) {
      if (this.readyState > 1)
        return false;
      message = message || "";
      return this.frame(message, "pong");
    },
    close: function(reason, code) {
      reason = reason || "";
      code = code || this.ERRORS.normal_closure;
      if (this.readyState <= 0) {
        this.readyState = 3;
        this.emit("close", new Base.CloseEvent(code, reason));
        return true;
      } else if (this.readyState === 1) {
        this.readyState = 2;
        this._extensions.close(function() {
          this.frame(reason, "close", code);
        }, this);
        return true;
      } else {
        return false;
      }
    },
    frame: function(buffer, type, code) {
      if (this.readyState <= 0)
        return this._queue([buffer, type, code]);
      if (this.readyState > 2)
        return false;
      if (buffer instanceof Array)
        buffer = Buffer2.from(buffer);
      if (typeof buffer === "number")
        buffer = buffer.toString();
      var message = new Message, isText = typeof buffer === "string", payload, copy;
      message.rsv1 = message.rsv2 = message.rsv3 = false;
      message.opcode = this.OPCODES[type || (isText ? "text" : "binary")];
      payload = isText ? Buffer2.from(buffer, "utf8") : buffer;
      if (code) {
        copy = payload;
        payload = Buffer2.allocUnsafe(2 + copy.length);
        payload.writeUInt16BE(code, 0);
        copy.copy(payload, 2);
      }
      message.data = payload;
      var onMessageReady = function(message2) {
        var frame = new Frame;
        frame.final = true;
        frame.rsv1 = message2.rsv1;
        frame.rsv2 = message2.rsv2;
        frame.rsv3 = message2.rsv3;
        frame.opcode = message2.opcode;
        frame.masked = !!this._masking;
        frame.length = message2.data.length;
        frame.payload = message2.data;
        if (frame.masked)
          frame.maskingKey = crypto.randomBytes(4);
        this._sendFrame(frame);
      };
      if (this.MESSAGE_OPCODES.indexOf(message.opcode) >= 0)
        this._extensions.processOutgoingMessage(message, function(error, message2) {
          if (error)
            return this._fail("extension_error", error.message);
          onMessageReady.call(this, message2);
        }, this);
      else
        onMessageReady.call(this, message);
      return true;
    },
    _sendFrame: function(frame) {
      var length = frame.length, header = length <= 125 ? 2 : length <= 65535 ? 4 : 10, offset = header + (frame.masked ? 4 : 0), buffer = Buffer2.allocUnsafe(offset + length), masked = frame.masked ? this.MASK : 0;
      buffer[0] = (frame.final ? this.FIN : 0) | (frame.rsv1 ? this.RSV1 : 0) | (frame.rsv2 ? this.RSV2 : 0) | (frame.rsv3 ? this.RSV3 : 0) | frame.opcode;
      if (length <= 125) {
        buffer[1] = masked | length;
      } else if (length <= 65535) {
        buffer[1] = masked | 126;
        buffer.writeUInt16BE(length, 2);
      } else {
        buffer[1] = masked | 127;
        buffer.writeUInt32BE(Math.floor(length / 4294967296), 2);
        buffer.writeUInt32BE(length % 4294967296, 6);
      }
      frame.payload.copy(buffer, offset);
      if (frame.masked) {
        frame.maskingKey.copy(buffer, header);
        Hybi.mask(buffer, frame.maskingKey, offset);
      }
      this._write(buffer);
    },
    _handshakeResponse: function() {
      var secKey = this._request.headers["sec-websocket-key"], version2 = this._request.headers["sec-websocket-version"];
      if (version2 !== Hybi.VERSION)
        throw new Error("Unsupported WebSocket version: " + version2);
      if (typeof secKey !== "string")
        throw new Error("Missing handshake request header: Sec-WebSocket-Key");
      this._headers.set("Upgrade", "websocket");
      this._headers.set("Connection", "Upgrade");
      this._headers.set("Sec-WebSocket-Accept", Hybi.generateAccept(secKey));
      if (this.protocol)
        this._headers.set("Sec-WebSocket-Protocol", this.protocol);
      var extensions3 = this._extensions.generateResponse(this._request.headers["sec-websocket-extensions"]);
      if (extensions3)
        this._headers.set("Sec-WebSocket-Extensions", extensions3);
      var start = "HTTP/1.1 101 Switching Protocols", headers = [start, this._headers.toString(), ""];
      return Buffer2.from(headers.join("\r\n"), "utf8");
    },
    _shutdown: function(code, reason, error) {
      delete this._frame;
      delete this._message;
      this._stage = 5;
      var sendCloseFrame = this.readyState === 1;
      this.readyState = 2;
      this._extensions.close(function() {
        if (sendCloseFrame)
          this.frame(reason, "close", code);
        this.readyState = 3;
        if (error)
          this.emit("error", new Error(reason));
        this.emit("close", new Base.CloseEvent(code, reason));
      }, this);
    },
    _fail: function(type, message) {
      if (this.readyState > 1)
        return;
      this._shutdown(this.ERRORS[type], message, true);
    },
    _parseOpcode: function(octet) {
      var rsvs = [this.RSV1, this.RSV2, this.RSV3].map(function(rsv) {
        return (octet & rsv) === rsv;
      });
      var frame = this._frame = new Frame;
      frame.final = (octet & this.FIN) === this.FIN;
      frame.rsv1 = rsvs[0];
      frame.rsv2 = rsvs[1];
      frame.rsv3 = rsvs[2];
      frame.opcode = octet & this.OPCODE;
      this._stage = 1;
      if (!this._extensions.validFrameRsv(frame))
        return this._fail("protocol_error", "One or more reserved bits are on: reserved1 = " + (frame.rsv1 ? 1 : 0) + ", reserved2 = " + (frame.rsv2 ? 1 : 0) + ", reserved3 = " + (frame.rsv3 ? 1 : 0));
      if (this.OPCODE_CODES.indexOf(frame.opcode) < 0)
        return this._fail("protocol_error", "Unrecognized frame opcode: " + frame.opcode);
      if (this.MESSAGE_OPCODES.indexOf(frame.opcode) < 0 && !frame.final)
        return this._fail("protocol_error", "Received fragmented control frame: opcode = " + frame.opcode);
      if (this._message && this.OPENING_OPCODES.indexOf(frame.opcode) >= 0)
        return this._fail("protocol_error", "Received new data frame but previous continuous frame is unfinished");
    },
    _parseLength: function(octet) {
      var frame = this._frame;
      frame.masked = (octet & this.MASK) === this.MASK;
      frame.length = octet & this.LENGTH;
      if (frame.length >= 0 && frame.length <= 125) {
        this._stage = frame.masked ? 3 : 4;
        if (!this._checkFrameLength())
          return;
      } else {
        this._stage = 2;
        frame.lengthBytes = frame.length === 126 ? 2 : 8;
      }
      if (this._requireMasking && !frame.masked)
        return this._fail("unacceptable", "Received unmasked frame but masking is required");
    },
    _parseExtendedLength: function(buffer) {
      var frame = this._frame;
      frame.length = this._readUInt(buffer);
      this._stage = frame.masked ? 3 : 4;
      if (this.MESSAGE_OPCODES.indexOf(frame.opcode) < 0 && frame.length > 125)
        return this._fail("protocol_error", "Received control frame having too long payload: " + frame.length);
      if (!this._checkFrameLength())
        return;
    },
    _checkFrameLength: function() {
      var length = this._message ? this._message.length : 0;
      if (length + this._frame.length > this._maxLength) {
        this._fail("too_large", "WebSocket frame length too large");
        return false;
      } else {
        return true;
      }
    },
    _emitFrame: function(buffer) {
      var frame = this._frame, payload = frame.payload = Hybi.mask(buffer, frame.maskingKey), opcode = frame.opcode, message, code, reason, callbacks, callback;
      delete this._frame;
      if (opcode === this.OPCODES.continuation) {
        if (!this._message)
          return this._fail("protocol_error", "Received unexpected continuation frame");
        this._message.pushFrame(frame);
      }
      if (opcode === this.OPCODES.text || opcode === this.OPCODES.binary) {
        this._message = new Message;
        this._message.pushFrame(frame);
      }
      if (frame.final && this.MESSAGE_OPCODES.indexOf(opcode) >= 0)
        return this._emitMessage(this._message);
      if (opcode === this.OPCODES.close) {
        code = payload.length >= 2 ? payload.readUInt16BE(0) : null;
        reason = payload.length > 2 ? this._encode(payload.slice(2)) : null;
        if (!(payload.length === 0) && !(code !== null && code >= this.MIN_RESERVED_ERROR && code <= this.MAX_RESERVED_ERROR) && this.ERROR_CODES.indexOf(code) < 0)
          code = this.ERRORS.protocol_error;
        if (payload.length > 125 || payload.length > 2 && !reason)
          code = this.ERRORS.protocol_error;
        this._shutdown(code || this.DEFAULT_ERROR_CODE, reason || "");
      }
      if (opcode === this.OPCODES.ping) {
        this.frame(payload, "pong");
        this.emit("ping", new Base.PingEvent(payload.toString()));
      }
      if (opcode === this.OPCODES.pong) {
        callbacks = this._pingCallbacks;
        message = this._encode(payload);
        callback = callbacks[message];
        delete callbacks[message];
        if (callback)
          callback();
        this.emit("pong", new Base.PongEvent(payload.toString()));
      }
    },
    _emitMessage: function(message) {
      var message = this._message;
      message.read();
      delete this._message;
      this._extensions.processIncomingMessage(message, function(error, message2) {
        if (error)
          return this._fail("extension_error", error.message);
        var payload = message2.data;
        if (message2.opcode === this.OPCODES.text)
          payload = this._encode(payload);
        if (payload === null)
          return this._fail("encoding_error", "Could not decode a text frame as UTF-8");
        else
          this.emit("message", new Base.MessageEvent(payload));
      }, this);
    },
    _encode: function(buffer) {
      try {
        var string = buffer.toString("binary", 0, buffer.length);
        if (!this.UTF8_MATCH.test(string))
          return null;
      } catch (e) {
      }
      return buffer.toString("utf8", 0, buffer.length);
    },
    _readUInt: function(buffer) {
      if (buffer.length === 2)
        return buffer.readUInt16BE(0);
      return buffer.readUInt32BE(0) * 4294967296 + buffer.readUInt32BE(4);
    }
  };
  for (key in instance)
    Hybi.prototype[key] = instance[key];
  var key;
  module.exports = Hybi;
});

// node_modules/websocket-driver/lib/websocket/driver/proxy.js
var require_proxy = __commonJS((exports, module) => {
  var Buffer2 = require_safe_buffer().Buffer;
  var Stream = import.meta.require("stream").Stream;
  var url = import.meta.require("url");
  var util = import.meta.require("util");
  var Base = require_base();
  var Headers = require_headers();
  var HttpParser = require_http_parser2();
  var PORTS = { "ws:": 80, "wss:": 443 };
  var Proxy2 = function(client, origin, options) {
    this._client = client;
    this._http = new HttpParser("response");
    this._origin = typeof client.url === "object" ? client.url : url.parse(client.url);
    this._url = typeof origin === "object" ? origin : url.parse(origin);
    this._options = options || {};
    this._state = 0;
    this.readable = this.writable = true;
    this._paused = false;
    this._headers = new Headers;
    this._headers.set("Host", this._origin.host);
    this._headers.set("Connection", "keep-alive");
    this._headers.set("Proxy-Connection", "keep-alive");
    var auth = this._url.auth && Buffer2.from(this._url.auth, "utf8").toString("base64");
    if (auth)
      this._headers.set("Proxy-Authorization", "Basic " + auth);
  };
  util.inherits(Proxy2, Stream);
  var instance = {
    setHeader: function(name, value) {
      if (this._state !== 0)
        return false;
      this._headers.set(name, value);
      return true;
    },
    start: function() {
      if (this._state !== 0)
        return false;
      this._state = 1;
      var origin = this._origin, port = origin.port || PORTS[origin.protocol], start = "CONNECT " + origin.hostname + ":" + port + " HTTP/1.1";
      var headers = [start, this._headers.toString(), ""];
      this.emit("data", Buffer2.from(headers.join("\r\n"), "utf8"));
      return true;
    },
    pause: function() {
      this._paused = true;
    },
    resume: function() {
      this._paused = false;
      this.emit("drain");
    },
    write: function(chunk) {
      if (!this.writable)
        return false;
      this._http.parse(chunk);
      if (!this._http.isComplete())
        return !this._paused;
      this.statusCode = this._http.statusCode;
      this.headers = this._http.headers;
      if (this.statusCode === 200) {
        this.emit("connect", new Base.ConnectEvent);
      } else {
        var message = "Can't establish a connection to the server at " + this._origin.href;
        this.emit("error", new Error(message));
      }
      this.end();
      return !this._paused;
    },
    end: function(chunk) {
      if (!this.writable)
        return;
      if (chunk !== undefined)
        this.write(chunk);
      this.readable = this.writable = false;
      this.emit("close");
      this.emit("end");
    },
    destroy: function() {
      this.end();
    }
  };
  for (key in instance)
    Proxy2.prototype[key] = instance[key];
  var key;
  module.exports = Proxy2;
});

// node_modules/websocket-driver/lib/websocket/driver/client.js
var require_client = __commonJS((exports, module) => {
  var Buffer2 = require_safe_buffer().Buffer;
  var crypto = import.meta.require("crypto");
  var url = import.meta.require("url");
  var util = import.meta.require("util");
  var HttpParser = require_http_parser2();
  var Base = require_base();
  var Hybi = require_hybi();
  var Proxy2 = require_proxy();
  var Client = function(_url, options) {
    this.version = "hybi-" + Hybi.VERSION;
    Hybi.call(this, null, _url, options);
    this.readyState = -1;
    this._key = Client.generateKey();
    this._accept = Hybi.generateAccept(this._key);
    this._http = new HttpParser("response");
    var uri = url.parse(this.url), auth = uri.auth && Buffer2.from(uri.auth, "utf8").toString("base64");
    if (this.VALID_PROTOCOLS.indexOf(uri.protocol) < 0)
      throw new Error(this.url + " is not a valid WebSocket URL");
    this._pathname = (uri.pathname || "/") + (uri.search || "");
    this._headers.set("Host", uri.host);
    this._headers.set("Upgrade", "websocket");
    this._headers.set("Connection", "Upgrade");
    this._headers.set("Sec-WebSocket-Key", this._key);
    this._headers.set("Sec-WebSocket-Version", Hybi.VERSION);
    if (this._protocols.length > 0)
      this._headers.set("Sec-WebSocket-Protocol", this._protocols.join(", "));
    if (auth)
      this._headers.set("Authorization", "Basic " + auth);
  };
  util.inherits(Client, Hybi);
  Client.generateKey = function() {
    return crypto.randomBytes(16).toString("base64");
  };
  var instance = {
    VALID_PROTOCOLS: ["ws:", "wss:"],
    proxy: function(origin, options) {
      return new Proxy2(this, origin, options);
    },
    start: function() {
      if (this.readyState !== -1)
        return false;
      this._write(this._handshakeRequest());
      this.readyState = 0;
      return true;
    },
    parse: function(chunk) {
      if (this.readyState === 3)
        return;
      if (this.readyState > 0)
        return Hybi.prototype.parse.call(this, chunk);
      this._http.parse(chunk);
      if (!this._http.isComplete())
        return;
      this._validateHandshake();
      if (this.readyState === 3)
        return;
      this._open();
      this.parse(this._http.body);
    },
    _handshakeRequest: function() {
      var extensions3 = this._extensions.generateOffer();
      if (extensions3)
        this._headers.set("Sec-WebSocket-Extensions", extensions3);
      var start = "GET " + this._pathname + " HTTP/1.1", headers = [start, this._headers.toString(), ""];
      return Buffer2.from(headers.join("\r\n"), "utf8");
    },
    _failHandshake: function(message) {
      message = "Error during WebSocket handshake: " + message;
      this.readyState = 3;
      this.emit("error", new Error(message));
      this.emit("close", new Base.CloseEvent(this.ERRORS.protocol_error, message));
    },
    _validateHandshake: function() {
      this.statusCode = this._http.statusCode;
      this.headers = this._http.headers;
      if (this._http.error)
        return this._failHandshake(this._http.error.message);
      if (this._http.statusCode !== 101)
        return this._failHandshake("Unexpected response code: " + this._http.statusCode);
      var headers = this._http.headers, upgrade = headers["upgrade"] || "", connection = headers["connection"] || "", accept = headers["sec-websocket-accept"] || "", protocol = headers["sec-websocket-protocol"] || "";
      if (upgrade === "")
        return this._failHandshake("'Upgrade' header is missing");
      if (upgrade.toLowerCase() !== "websocket")
        return this._failHandshake("'Upgrade' header value is not 'WebSocket'");
      if (connection === "")
        return this._failHandshake("'Connection' header is missing");
      if (connection.toLowerCase() !== "upgrade")
        return this._failHandshake("'Connection' header value is not 'Upgrade'");
      if (accept !== this._accept)
        return this._failHandshake("Sec-WebSocket-Accept mismatch");
      this.protocol = null;
      if (protocol !== "") {
        if (this._protocols.indexOf(protocol) < 0)
          return this._failHandshake("Sec-WebSocket-Protocol mismatch");
        else
          this.protocol = protocol;
      }
      try {
        this._extensions.activate(this.headers["sec-websocket-extensions"]);
      } catch (e) {
        return this._failHandshake(e.message);
      }
    }
  };
  for (key in instance)
    Client.prototype[key] = instance[key];
  var key;
  module.exports = Client;
});

// node_modules/websocket-driver/lib/websocket/driver/draft75.js
var require_draft75 = __commonJS((exports, module) => {
  var Buffer2 = require_safe_buffer().Buffer;
  var Base = require_base();
  var util = import.meta.require("util");
  var Draft75 = function(request, url, options) {
    Base.apply(this, arguments);
    this._stage = 0;
    this.version = "hixie-75";
    this._headers.set("Upgrade", "WebSocket");
    this._headers.set("Connection", "Upgrade");
    this._headers.set("WebSocket-Origin", this._request.headers.origin);
    this._headers.set("WebSocket-Location", this.url);
  };
  util.inherits(Draft75, Base);
  var instance = {
    close: function() {
      if (this.readyState === 3)
        return false;
      this.readyState = 3;
      this.emit("close", new Base.CloseEvent(null, null));
      return true;
    },
    parse: function(chunk) {
      if (this.readyState > 1)
        return;
      this._reader.put(chunk);
      this._reader.eachByte(function(octet) {
        var message;
        switch (this._stage) {
          case -1:
            this._body.push(octet);
            this._sendHandshakeBody();
            break;
          case 0:
            this._parseLeadingByte(octet);
            break;
          case 1:
            this._length = (octet & 127) + 128 * this._length;
            if (this._closing && this._length === 0) {
              return this.close();
            } else if ((octet & 128) !== 128) {
              if (this._length === 0) {
                this._stage = 0;
              } else {
                this._skipped = 0;
                this._stage = 2;
              }
            }
            break;
          case 2:
            if (octet === 255) {
              this._stage = 0;
              message = Buffer2.from(this._buffer).toString("utf8", 0, this._buffer.length);
              this.emit("message", new Base.MessageEvent(message));
            } else {
              if (this._length) {
                this._skipped += 1;
                if (this._skipped === this._length)
                  this._stage = 0;
              } else {
                this._buffer.push(octet);
                if (this._buffer.length > this._maxLength)
                  return this.close();
              }
            }
            break;
        }
      }, this);
    },
    frame: function(buffer) {
      if (this.readyState === 0)
        return this._queue([buffer]);
      if (this.readyState > 1)
        return false;
      if (typeof buffer !== "string")
        buffer = buffer.toString();
      var length = Buffer2.byteLength(buffer), frame = Buffer2.allocUnsafe(length + 2);
      frame[0] = 0;
      frame.write(buffer, 1);
      frame[frame.length - 1] = 255;
      this._write(frame);
      return true;
    },
    _handshakeResponse: function() {
      var start = "HTTP/1.1 101 Web Socket Protocol Handshake", headers = [start, this._headers.toString(), ""];
      return Buffer2.from(headers.join("\r\n"), "utf8");
    },
    _parseLeadingByte: function(octet) {
      if ((octet & 128) === 128) {
        this._length = 0;
        this._stage = 1;
      } else {
        delete this._length;
        delete this._skipped;
        this._buffer = [];
        this._stage = 2;
      }
    }
  };
  for (key in instance)
    Draft75.prototype[key] = instance[key];
  var key;
  module.exports = Draft75;
});

// node_modules/websocket-driver/lib/websocket/driver/draft76.js
var require_draft76 = __commonJS((exports, module) => {
  var Buffer2 = require_safe_buffer().Buffer;
  var Base = require_base();
  var Draft75 = require_draft75();
  var crypto = import.meta.require("crypto");
  var util = import.meta.require("util");
  var numberFromKey = function(key2) {
    return parseInt((key2.match(/[0-9]/g) || []).join(""), 10);
  };
  var spacesInKey = function(key2) {
    return (key2.match(/ /g) || []).length;
  };
  var Draft76 = function(request, url, options) {
    Draft75.apply(this, arguments);
    this._stage = -1;
    this._body = [];
    this.version = "hixie-76";
    this._headers.clear();
    this._headers.set("Upgrade", "WebSocket");
    this._headers.set("Connection", "Upgrade");
    this._headers.set("Sec-WebSocket-Origin", this._request.headers.origin);
    this._headers.set("Sec-WebSocket-Location", this.url);
  };
  util.inherits(Draft76, Draft75);
  var instance = {
    BODY_SIZE: 8,
    start: function() {
      if (!Draft75.prototype.start.call(this))
        return false;
      this._started = true;
      this._sendHandshakeBody();
      return true;
    },
    close: function() {
      if (this.readyState === 3)
        return false;
      if (this.readyState === 1)
        this._write(Buffer2.from([255, 0]));
      this.readyState = 3;
      this.emit("close", new Base.CloseEvent(null, null));
      return true;
    },
    _handshakeResponse: function() {
      var headers = this._request.headers, key1 = headers["sec-websocket-key1"], key2 = headers["sec-websocket-key2"];
      if (!key1)
        throw new Error("Missing required header: Sec-WebSocket-Key1");
      if (!key2)
        throw new Error("Missing required header: Sec-WebSocket-Key2");
      var number1 = numberFromKey(key1), spaces1 = spacesInKey(key1), number2 = numberFromKey(key2), spaces2 = spacesInKey(key2);
      if (number1 % spaces1 !== 0 || number2 % spaces2 !== 0)
        throw new Error("Client sent invalid Sec-WebSocket-Key headers");
      this._keyValues = [number1 / spaces1, number2 / spaces2];
      var start = "HTTP/1.1 101 WebSocket Protocol Handshake", headers = [start, this._headers.toString(), ""];
      return Buffer2.from(headers.join("\r\n"), "binary");
    },
    _handshakeSignature: function() {
      if (this._body.length < this.BODY_SIZE)
        return null;
      var md5 = crypto.createHash("md5"), buffer = Buffer2.allocUnsafe(8 + this.BODY_SIZE);
      buffer.writeUInt32BE(this._keyValues[0], 0);
      buffer.writeUInt32BE(this._keyValues[1], 4);
      Buffer2.from(this._body).copy(buffer, 8, 0, this.BODY_SIZE);
      md5.update(buffer);
      return Buffer2.from(md5.digest("binary"), "binary");
    },
    _sendHandshakeBody: function() {
      if (!this._started)
        return;
      var signature = this._handshakeSignature();
      if (!signature)
        return;
      this._write(signature);
      this._stage = 0;
      this._open();
      if (this._body.length > this.BODY_SIZE)
        this.parse(this._body.slice(this.BODY_SIZE));
    },
    _parseLeadingByte: function(octet) {
      if (octet !== 255)
        return Draft75.prototype._parseLeadingByte.call(this, octet);
      this._closing = true;
      this._length = 0;
      this._stage = 1;
    }
  };
  for (key in instance)
    Draft76.prototype[key] = instance[key];
  var key;
  module.exports = Draft76;
});

// node_modules/websocket-driver/lib/websocket/driver/server.js
var require_server = __commonJS((exports, module) => {
  var util = import.meta.require("util");
  var HttpParser = require_http_parser2();
  var Base = require_base();
  var Draft75 = require_draft75();
  var Draft76 = require_draft76();
  var Hybi = require_hybi();
  var Server = function(options) {
    Base.call(this, null, null, options);
    this._http = new HttpParser("request");
  };
  util.inherits(Server, Base);
  var instance = {
    EVENTS: ["open", "message", "error", "close", "ping", "pong"],
    _bindEventListeners: function() {
      this.messages.on("error", function() {
      });
      this.on("error", function() {
      });
    },
    parse: function(chunk) {
      if (this._delegate)
        return this._delegate.parse(chunk);
      this._http.parse(chunk);
      if (!this._http.isComplete())
        return;
      this.method = this._http.method;
      this.url = this._http.url;
      this.headers = this._http.headers;
      this.body = this._http.body;
      var self2 = this;
      this._delegate = Server.http(this, this._options);
      this._delegate.messages = this.messages;
      this._delegate.io = this.io;
      this._open();
      this.EVENTS.forEach(function(event) {
        this._delegate.on(event, function(e) {
          self2.emit(event, e);
        });
      }, this);
      this.protocol = this._delegate.protocol;
      this.version = this._delegate.version;
      this.parse(this._http.body);
      this.emit("connect", new Base.ConnectEvent);
    },
    _open: function() {
      this.__queue.forEach(function(msg) {
        this._delegate[msg[0]].apply(this._delegate, msg[1]);
      }, this);
      this.__queue = [];
    }
  };
  ["addExtension", "setHeader", "start", "frame", "text", "binary", "ping", "close"].forEach(function(method) {
    instance[method] = function() {
      if (this._delegate) {
        return this._delegate[method].apply(this._delegate, arguments);
      } else {
        this.__queue.push([method, arguments]);
        return true;
      }
    };
  });
  for (key in instance)
    Server.prototype[key] = instance[key];
  var key;
  Server.isSecureRequest = function(request) {
    if (request.connection && request.connection.authorized !== undefined)
      return true;
    if (request.socket && request.socket.secure)
      return true;
    var headers = request.headers;
    if (!headers)
      return false;
    if (headers["https"] === "on")
      return true;
    if (headers["x-forwarded-ssl"] === "on")
      return true;
    if (headers["x-forwarded-scheme"] === "https")
      return true;
    if (headers["x-forwarded-proto"] === "https")
      return true;
    return false;
  };
  Server.determineUrl = function(request) {
    var scheme = this.isSecureRequest(request) ? "wss:" : "ws:";
    return scheme + "//" + request.headers.host + request.url;
  };
  Server.http = function(request, options) {
    options = options || {};
    if (options.requireMasking === undefined)
      options.requireMasking = true;
    var headers = request.headers, version2 = headers["sec-websocket-version"], key2 = headers["sec-websocket-key"], key1 = headers["sec-websocket-key1"], key22 = headers["sec-websocket-key2"], url = this.determineUrl(request);
    if (version2 || key2)
      return new Hybi(request, url, options);
    else if (key1 || key22)
      return new Draft76(request, url, options);
    else
      return new Draft75(request, url, options);
  };
  module.exports = Server;
});

// node_modules/websocket-driver/lib/websocket/driver.js
var require_driver = __commonJS((exports, module) => {
  var Base = require_base();
  var Client = require_client();
  var Server = require_server();
  var Driver = {
    client: function(url, options) {
      options = options || {};
      if (options.masking === undefined)
        options.masking = true;
      return new Client(url, options);
    },
    server: function(options) {
      options = options || {};
      if (options.requireMasking === undefined)
        options.requireMasking = true;
      return new Server(options);
    },
    http: function() {
      return Server.http.apply(Server, arguments);
    },
    isSecureRequest: function(request) {
      return Server.isSecureRequest(request);
    },
    isWebSocket: function(request) {
      return Base.isWebSocket(request);
    },
    validateOptions: function(options, validKeys) {
      Base.validateOptions(options, validKeys);
    }
  };
  module.exports = Driver;
});

// node_modules/faye-websocket/lib/faye/websocket/api/event.js
var require_event = __commonJS((exports, module) => {
  var Event2 = function(eventType, options) {
    this.type = eventType;
    for (var key in options)
      this[key] = options[key];
  };
  Event2.prototype.initEvent = function(eventType, canBubble, cancelable) {
    this.type = eventType;
    this.bubbles = canBubble;
    this.cancelable = cancelable;
  };
  Event2.prototype.stopPropagation = function() {
  };
  Event2.prototype.preventDefault = function() {
  };
  Event2.CAPTURING_PHASE = 1;
  Event2.AT_TARGET = 2;
  Event2.BUBBLING_PHASE = 3;
  module.exports = Event2;
});

// node_modules/faye-websocket/lib/faye/websocket/api/event_target.js
var require_event_target = __commonJS((exports, module) => {
  var Event2 = require_event();
  var EventTarget2 = {
    onopen: null,
    onmessage: null,
    onerror: null,
    onclose: null,
    addEventListener: function(eventType, listener, useCapture) {
      this.on(eventType, listener);
    },
    removeEventListener: function(eventType, listener, useCapture) {
      this.removeListener(eventType, listener);
    },
    dispatchEvent: function(event) {
      event.target = event.currentTarget = this;
      event.eventPhase = Event2.AT_TARGET;
      if (this["on" + event.type])
        this["on" + event.type](event);
      this.emit(event.type, event);
    }
  };
  module.exports = EventTarget2;
});

// node_modules/faye-websocket/lib/faye/websocket/api.js
var require_api = __commonJS((exports, module) => {
  var Stream = import.meta.require("stream").Stream;
  var util = import.meta.require("util");
  var driver = require_driver();
  var EventTarget2 = require_event_target();
  var Event2 = require_event();
  var API = function(options) {
    options = options || {};
    driver.validateOptions(options, ["headers", "extensions", "maxLength", "ping", "proxy", "tls", "ca"]);
    this.readable = this.writable = true;
    var headers = options.headers;
    if (headers) {
      for (var name in headers)
        this._driver.setHeader(name, headers[name]);
    }
    var extensions3 = options.extensions;
    if (extensions3) {
      [].concat(extensions3).forEach(this._driver.addExtension, this._driver);
    }
    this._ping = options.ping;
    this._pingId = 0;
    this.readyState = API.CONNECTING;
    this.bufferedAmount = 0;
    this.protocol = "";
    this.url = this._driver.url;
    this.version = this._driver.version;
    var self2 = this;
    this._driver.on("open", function(e) {
      self2._open();
    });
    this._driver.on("message", function(e) {
      self2._receiveMessage(e.data);
    });
    this._driver.on("close", function(e) {
      self2._beginClose(e.reason, e.code);
    });
    this._driver.on("error", function(error) {
      self2._emitError(error.message);
    });
    this.on("error", function() {
    });
    this._driver.messages.on("drain", function() {
      self2.emit("drain");
    });
    if (this._ping)
      this._pingTimer = setInterval(function() {
        self2._pingId += 1;
        self2.ping(self2._pingId.toString());
      }, this._ping * 1000);
    this._configureStream();
    if (!this._proxy) {
      this._stream.pipe(this._driver.io);
      this._driver.io.pipe(this._stream);
    }
  };
  util.inherits(API, Stream);
  API.CONNECTING = 0;
  API.OPEN = 1;
  API.CLOSING = 2;
  API.CLOSED = 3;
  API.CLOSE_TIMEOUT = 30000;
  var instance = {
    write: function(data) {
      return this.send(data);
    },
    end: function(data) {
      if (data !== undefined)
        this.send(data);
      this.close();
    },
    pause: function() {
      return this._driver.messages.pause();
    },
    resume: function() {
      return this._driver.messages.resume();
    },
    send: function(data) {
      if (this.readyState > API.OPEN)
        return false;
      if (!(data instanceof Buffer))
        data = String(data);
      return this._driver.messages.write(data);
    },
    ping: function(message, callback) {
      if (this.readyState > API.OPEN)
        return false;
      return this._driver.ping(message, callback);
    },
    close: function(code, reason) {
      if (code === undefined)
        code = 1000;
      if (reason === undefined)
        reason = "";
      if (code !== 1000 && (code < 3000 || code > 4999))
        throw new Error("Failed to execute 'close' on WebSocket: The code must be either 1000, or between 3000 and 4999. " + code + " is neither.");
      if (this.readyState < API.CLOSING) {
        var self2 = this;
        this._closeTimer = setTimeout(function() {
          self2._beginClose("", 1006);
        }, API.CLOSE_TIMEOUT);
      }
      if (this.readyState !== API.CLOSED)
        this.readyState = API.CLOSING;
      this._driver.close(reason, code);
    },
    _configureStream: function() {
      var self2 = this;
      this._stream.setTimeout(0);
      this._stream.setNoDelay(true);
      ["close", "end"].forEach(function(event) {
        this._stream.on(event, function() {
          self2._finalizeClose();
        });
      }, this);
      this._stream.on("error", function(error) {
        self2._emitError("Network error: " + self2.url + ": " + error.message);
        self2._finalizeClose();
      });
    },
    _open: function() {
      if (this.readyState !== API.CONNECTING)
        return;
      this.readyState = API.OPEN;
      this.protocol = this._driver.protocol || "";
      var event = new Event2("open");
      event.initEvent("open", false, false);
      this.dispatchEvent(event);
    },
    _receiveMessage: function(data) {
      if (this.readyState > API.OPEN)
        return false;
      if (this.readable)
        this.emit("data", data);
      var event = new Event2("message", { data });
      event.initEvent("message", false, false);
      this.dispatchEvent(event);
    },
    _emitError: function(message) {
      if (this.readyState >= API.CLOSING)
        return;
      var event = new Event2("error", { message });
      event.initEvent("error", false, false);
      this.dispatchEvent(event);
    },
    _beginClose: function(reason, code) {
      if (this.readyState === API.CLOSED)
        return;
      this.readyState = API.CLOSING;
      this._closeParams = [reason, code];
      if (this._stream) {
        this._stream.destroy();
        if (!this._stream.readable)
          this._finalizeClose();
      }
    },
    _finalizeClose: function() {
      if (this.readyState === API.CLOSED)
        return;
      this.readyState = API.CLOSED;
      if (this._closeTimer)
        clearTimeout(this._closeTimer);
      if (this._pingTimer)
        clearInterval(this._pingTimer);
      if (this._stream)
        this._stream.end();
      if (this.readable)
        this.emit("end");
      this.readable = this.writable = false;
      var reason = this._closeParams ? this._closeParams[0] : "", code = this._closeParams ? this._closeParams[1] : 1006;
      var event = new Event2("close", { code, reason });
      event.initEvent("close", false, false);
      this.dispatchEvent(event);
    }
  };
  for (method in instance)
    API.prototype[method] = instance[method];
  var method;
  for (key in EventTarget2)
    API.prototype[key] = EventTarget2[key];
  var key;
  module.exports = API;
});

// node_modules/faye-websocket/lib/faye/websocket/client.js
var require_client2 = __commonJS((exports, module) => {
  var util = import.meta.require("util");
  var net = import.meta.require("net");
  var tls = import.meta.require("tls");
  var url = import.meta.require("url");
  var driver = require_driver();
  var API = require_api();
  var Event2 = require_event();
  var DEFAULT_PORTS = { "http:": 80, "https:": 443, "ws:": 80, "wss:": 443 };
  var SECURE_PROTOCOLS = ["https:", "wss:"];
  var Client = function(_url, protocols, options) {
    options = options || {};
    this.url = _url;
    this._driver = driver.client(this.url, { maxLength: options.maxLength, protocols });
    ["open", "error"].forEach(function(event) {
      this._driver.on(event, function() {
        self2.headers = self2._driver.headers;
        self2.statusCode = self2._driver.statusCode;
      });
    }, this);
    var proxy = options.proxy || {}, endpoint = url.parse(proxy.origin || this.url), port = endpoint.port || DEFAULT_PORTS[endpoint.protocol], secure = SECURE_PROTOCOLS.indexOf(endpoint.protocol) >= 0, onConnect = function() {
      self2._onConnect();
    }, netOptions = options.net || {}, originTLS = options.tls || {}, socketTLS = proxy.origin ? proxy.tls || {} : originTLS, self2 = this;
    netOptions.host = socketTLS.host = endpoint.hostname;
    netOptions.port = socketTLS.port = port;
    originTLS.ca = originTLS.ca || options.ca;
    socketTLS.servername = socketTLS.servername || endpoint.hostname;
    this._stream = secure ? tls.connect(socketTLS, onConnect) : net.connect(netOptions, onConnect);
    if (proxy.origin)
      this._configureProxy(proxy, originTLS);
    API.call(this, options);
  };
  util.inherits(Client, API);
  Client.prototype._onConnect = function() {
    var worker = this._proxy || this._driver;
    worker.start();
  };
  Client.prototype._configureProxy = function(proxy, originTLS) {
    var uri = url.parse(this.url), secure = SECURE_PROTOCOLS.indexOf(uri.protocol) >= 0, self2 = this, name;
    this._proxy = this._driver.proxy(proxy.origin);
    if (proxy.headers) {
      for (name in proxy.headers)
        this._proxy.setHeader(name, proxy.headers[name]);
    }
    this._proxy.pipe(this._stream, { end: false });
    this._stream.pipe(this._proxy);
    this._proxy.on("connect", function() {
      if (secure) {
        var options = { socket: self2._stream, servername: uri.hostname };
        for (name in originTLS)
          options[name] = originTLS[name];
        self2._stream = tls.connect(options);
        self2._configureStream();
      }
      self2._driver.io.pipe(self2._stream);
      self2._stream.pipe(self2._driver.io);
      self2._driver.start();
    });
    this._proxy.on("error", function(error) {
      self2._driver.emit("error", error);
    });
  };
  module.exports = Client;
});

// node_modules/faye-websocket/lib/faye/eventsource.js
var require_eventsource = __commonJS((exports, module) => {
  var Stream = import.meta.require("stream").Stream;
  var util = import.meta.require("util");
  var driver = require_driver();
  var Headers = require_headers();
  var API = require_api();
  var EventTarget2 = require_event_target();
  var Event2 = require_event();
  var EventSource = function(request, response, options) {
    this.writable = true;
    options = options || {};
    this._stream = response.socket;
    this._ping = options.ping || this.DEFAULT_PING;
    this._retry = options.retry || this.DEFAULT_RETRY;
    var scheme = driver.isSecureRequest(request) ? "https:" : "http:";
    this.url = scheme + "//" + request.headers.host + request.url;
    this.lastEventId = request.headers["last-event-id"] || "";
    this.readyState = API.CONNECTING;
    var headers = new Headers, self2 = this;
    if (options.headers) {
      for (var key2 in options.headers)
        headers.set(key2, options.headers[key2]);
    }
    if (!this._stream || !this._stream.writable)
      return;
    process.nextTick(function() {
      self2._open();
    });
    this._stream.setTimeout(0);
    this._stream.setNoDelay(true);
    var handshake = "HTTP/1.1 200 OK\r\nContent-Type: text/event-stream\r\nCache-Control: no-cache, no-store\r\nConnection: close\r\n" + headers.toString() + "\r\nretry: " + Math.floor(this._retry * 1000) + "\r\n\r\n";
    this._write(handshake);
    this._stream.on("drain", function() {
      self2.emit("drain");
    });
    if (this._ping)
      this._pingTimer = setInterval(function() {
        self2.ping();
      }, this._ping * 1000);
    ["error", "end"].forEach(function(event) {
      self2._stream.on(event, function() {
        self2.close();
      });
    });
  };
  util.inherits(EventSource, Stream);
  EventSource.isEventSource = function(request) {
    if (request.method !== "GET")
      return false;
    var accept = (request.headers.accept || "").split(/\s*,\s*/);
    return accept.indexOf("text/event-stream") >= 0;
  };
  var instance = {
    DEFAULT_PING: 10,
    DEFAULT_RETRY: 5,
    _write: function(chunk) {
      if (!this.writable)
        return false;
      try {
        return this._stream.write(chunk, "utf8");
      } catch (e) {
        return false;
      }
    },
    _open: function() {
      if (this.readyState !== API.CONNECTING)
        return;
      this.readyState = API.OPEN;
      var event = new Event2("open");
      event.initEvent("open", false, false);
      this.dispatchEvent(event);
    },
    write: function(message) {
      return this.send(message);
    },
    end: function(message) {
      if (message !== undefined)
        this.write(message);
      this.close();
    },
    send: function(message, options) {
      if (this.readyState > API.OPEN)
        return false;
      message = String(message).replace(/(\r\n|\r|\n)/g, "$1data: ");
      options = options || {};
      var frame = "";
      if (options.event)
        frame += "event: " + options.event + "\r\n";
      if (options.id)
        frame += "id: " + options.id + "\r\n";
      frame += "data: " + message + "\r\n\r\n";
      return this._write(frame);
    },
    ping: function() {
      return this._write(":\r\n\r\n");
    },
    close: function() {
      if (this.readyState > API.OPEN)
        return false;
      this.readyState = API.CLOSED;
      this.writable = false;
      if (this._pingTimer)
        clearInterval(this._pingTimer);
      if (this._stream)
        this._stream.end();
      var event = new Event2("close");
      event.initEvent("close", false, false);
      this.dispatchEvent(event);
      return true;
    }
  };
  for (method in instance)
    EventSource.prototype[method] = instance[method];
  var method;
  for (key in EventTarget2)
    EventSource.prototype[key] = EventTarget2[key];
  var key;
  module.exports = EventSource;
});

// node_modules/faye-websocket/lib/faye/websocket.js
var require_websocket = __commonJS((exports, module) => {
  var util = import.meta.require("util");
  var driver = require_driver();
  var API = require_api();
  var WebSocket2 = function(request, socket, body, protocols, options) {
    options = options || {};
    this._stream = socket;
    this._driver = driver.http(request, { maxLength: options.maxLength, protocols });
    var self2 = this;
    if (!this._stream || !this._stream.writable)
      return;
    if (!this._stream.readable)
      return this._stream.end();
    var catchup = function() {
      self2._stream.removeListener("data", catchup);
    };
    this._stream.on("data", catchup);
    API.call(this, options);
    process.nextTick(function() {
      self2._driver.start();
      self2._driver.io.write(body);
    });
  };
  util.inherits(WebSocket2, API);
  WebSocket2.isWebSocket = function(request) {
    return driver.isWebSocket(request);
  };
  WebSocket2.validateOptions = function(options, validKeys) {
    driver.validateOptions(options, validKeys);
  };
  WebSocket2.WebSocket = WebSocket2;
  WebSocket2.Client = require_client2();
  WebSocket2.EventSource = require_eventsource();
  module.exports = WebSocket2;
});

// node_modules/dataloader/index.js
var require_dataloader = __commonJS((exports, module) => {
  var getCurrentBatch = function(loader) {
    var existingBatch = loader._batch;
    if (existingBatch !== null && !existingBatch.hasDispatched && existingBatch.keys.length < loader._maxBatchSize) {
      return existingBatch;
    }
    var newBatch = {
      hasDispatched: false,
      keys: [],
      callbacks: []
    };
    loader._batch = newBatch;
    loader._batchScheduleFn(function() {
      dispatchBatch(loader, newBatch);
    });
    return newBatch;
  };
  var dispatchBatch = function(loader, batch) {
    batch.hasDispatched = true;
    if (batch.keys.length === 0) {
      resolveCacheHits(batch);
      return;
    }
    var batchPromise;
    try {
      batchPromise = loader._batchLoadFn(batch.keys);
    } catch (e) {
      return failedDispatch(loader, batch, new TypeError("DataLoader must be constructed with a function which accepts Array<key> and returns Promise<Array<value>>, but the function " + ("errored synchronously: " + String(e) + ".")));
    }
    if (!batchPromise || typeof batchPromise.then !== "function") {
      return failedDispatch(loader, batch, new TypeError("DataLoader must be constructed with a function which accepts Array<key> and returns Promise<Array<value>>, but the function did " + ("not return a Promise: " + String(batchPromise) + ".")));
    }
    batchPromise.then(function(values2) {
      if (!isArrayLike(values2)) {
        throw new TypeError("DataLoader must be constructed with a function which accepts Array<key> and returns Promise<Array<value>>, but the function did " + ("not return a Promise of an Array: " + String(values2) + "."));
      }
      if (values2.length !== batch.keys.length) {
        throw new TypeError("DataLoader must be constructed with a function which accepts Array<key> and returns Promise<Array<value>>, but the function did not return a Promise of an Array of the same length as the Array of keys." + ("\n\nKeys:\n" + String(batch.keys)) + ("\n\nValues:\n" + String(values2)));
      }
      resolveCacheHits(batch);
      for (var i = 0;i < batch.callbacks.length; i++) {
        var value = values2[i];
        if (value instanceof Error) {
          batch.callbacks[i].reject(value);
        } else {
          batch.callbacks[i].resolve(value);
        }
      }
    })["catch"](function(error2) {
      failedDispatch(loader, batch, error2);
    });
  };
  var failedDispatch = function(loader, batch, error2) {
    resolveCacheHits(batch);
    for (var i = 0;i < batch.keys.length; i++) {
      loader.clear(batch.keys[i]);
      batch.callbacks[i].reject(error2);
    }
  };
  var resolveCacheHits = function(batch) {
    if (batch.cacheHits) {
      for (var i = 0;i < batch.cacheHits.length; i++) {
        batch.cacheHits[i]();
      }
    }
  };
  var getValidMaxBatchSize = function(options) {
    var shouldBatch = !options || options.batch !== false;
    if (!shouldBatch) {
      return 1;
    }
    var maxBatchSize = options && options.maxBatchSize;
    if (maxBatchSize === undefined) {
      return Infinity;
    }
    if (typeof maxBatchSize !== "number" || maxBatchSize < 1) {
      throw new TypeError("maxBatchSize must be a positive number: " + maxBatchSize);
    }
    return maxBatchSize;
  };
  var getValidBatchScheduleFn = function(options) {
    var batchScheduleFn = options && options.batchScheduleFn;
    if (batchScheduleFn === undefined) {
      return enqueuePostPromiseJob;
    }
    if (typeof batchScheduleFn !== "function") {
      throw new TypeError("batchScheduleFn must be a function: " + batchScheduleFn);
    }
    return batchScheduleFn;
  };
  var getValidCacheKeyFn = function(options) {
    var cacheKeyFn = options && options.cacheKeyFn;
    if (cacheKeyFn === undefined) {
      return function(key) {
        return key;
      };
    }
    if (typeof cacheKeyFn !== "function") {
      throw new TypeError("cacheKeyFn must be a function: " + cacheKeyFn);
    }
    return cacheKeyFn;
  };
  var getValidCacheMap = function(options) {
    var shouldCache = !options || options.cache !== false;
    if (!shouldCache) {
      return null;
    }
    var cacheMap = options && options.cacheMap;
    if (cacheMap === undefined) {
      return new Map;
    }
    if (cacheMap !== null) {
      var cacheFunctions = ["get", "set", "delete", "clear"];
      var missingFunctions = cacheFunctions.filter(function(fnName) {
        return cacheMap && typeof cacheMap[fnName] !== "function";
      });
      if (missingFunctions.length !== 0) {
        throw new TypeError("Custom cacheMap missing methods: " + missingFunctions.join(", "));
      }
    }
    return cacheMap;
  };
  var getValidName = function(options) {
    if (options && options.name) {
      return options.name;
    }
    return null;
  };
  var isArrayLike = function(x) {
    return typeof x === "object" && x !== null && typeof x.length === "number" && (x.length === 0 || x.length > 0 && Object.prototype.hasOwnProperty.call(x, x.length - 1));
  };
  var DataLoader = function() {
    function DataLoader2(batchLoadFn, options) {
      if (typeof batchLoadFn !== "function") {
        throw new TypeError("DataLoader must be constructed with a function which accepts " + ("Array<key> and returns Promise<Array<value>>, but got: " + batchLoadFn + "."));
      }
      this._batchLoadFn = batchLoadFn;
      this._maxBatchSize = getValidMaxBatchSize(options);
      this._batchScheduleFn = getValidBatchScheduleFn(options);
      this._cacheKeyFn = getValidCacheKeyFn(options);
      this._cacheMap = getValidCacheMap(options);
      this._batch = null;
      this.name = getValidName(options);
    }
    var _proto = DataLoader2.prototype;
    _proto.load = function load(key) {
      if (key === null || key === undefined) {
        throw new TypeError("The loader.load() function must be called with a value, " + ("but got: " + String(key) + "."));
      }
      var batch = getCurrentBatch(this);
      var cacheMap = this._cacheMap;
      var cacheKey = this._cacheKeyFn(key);
      if (cacheMap) {
        var cachedPromise = cacheMap.get(cacheKey);
        if (cachedPromise) {
          var cacheHits = batch.cacheHits || (batch.cacheHits = []);
          return new Promise(function(resolve) {
            cacheHits.push(function() {
              resolve(cachedPromise);
            });
          });
        }
      }
      batch.keys.push(key);
      var promise = new Promise(function(resolve, reject) {
        batch.callbacks.push({
          resolve,
          reject
        });
      });
      if (cacheMap) {
        cacheMap.set(cacheKey, promise);
      }
      return promise;
    };
    _proto.loadMany = function loadMany(keys) {
      if (!isArrayLike(keys)) {
        throw new TypeError("The loader.loadMany() function must be called with Array<key> " + ("but got: " + keys + "."));
      }
      var loadPromises = [];
      for (var i = 0;i < keys.length; i++) {
        loadPromises.push(this.load(keys[i])["catch"](function(error2) {
          return error2;
        }));
      }
      return Promise.all(loadPromises);
    };
    _proto.clear = function clear(key) {
      var cacheMap = this._cacheMap;
      if (cacheMap) {
        var cacheKey = this._cacheKeyFn(key);
        cacheMap["delete"](cacheKey);
      }
      return this;
    };
    _proto.clearAll = function clearAll() {
      var cacheMap = this._cacheMap;
      if (cacheMap) {
        cacheMap.clear();
      }
      return this;
    };
    _proto.prime = function prime(key, value) {
      var cacheMap = this._cacheMap;
      if (cacheMap) {
        var cacheKey = this._cacheKeyFn(key);
        if (cacheMap.get(cacheKey) === undefined) {
          var promise;
          if (value instanceof Error) {
            promise = Promise.reject(value);
            promise["catch"](function() {
            });
          } else {
            promise = Promise.resolve(value);
          }
          cacheMap.set(cacheKey, promise);
        }
      }
      return this;
    };
    return DataLoader2;
  }();
  var enqueuePostPromiseJob = typeof process === "object" && typeof process.nextTick === "function" ? function(fn) {
    if (!resolvedPromise) {
      resolvedPromise = Promise.resolve();
    }
    resolvedPromise.then(function() {
      process.nextTick(fn);
    });
  } : typeof setImmediate === "function" ? function(fn) {
    setImmediate(fn);
  } : function(fn) {
    setTimeout(fn);
  };
  var resolvedPromise;
  module.exports = DataLoader;
});

// node_modules/urlpattern-polyfill/dist/urlpattern.cjs
var require_urlpattern = __commonJS((exports, module) => {
  var we = function(e, t) {
    return (t ? /^[\x00-\xFF]*$/ : /^[\x00-\x7F]*$/).test(e);
  };
  var D = function(e, t = false) {
    let r = [], n = 0;
    for (;n < e.length; ) {
      let a = e[n], c = function(l) {
        if (!t)
          throw new TypeError(l);
        r.push({ type: "INVALID_CHAR", index: n, value: e[n++] });
      };
      if (a === "*") {
        r.push({ type: "ASTERISK", index: n, value: e[n++] });
        continue;
      }
      if (a === "+" || a === "?") {
        r.push({ type: "OTHER_MODIFIER", index: n, value: e[n++] });
        continue;
      }
      if (a === "\\") {
        r.push({ type: "ESCAPED_CHAR", index: n++, value: e[n++] });
        continue;
      }
      if (a === "{") {
        r.push({ type: "OPEN", index: n, value: e[n++] });
        continue;
      }
      if (a === "}") {
        r.push({ type: "CLOSE", index: n, value: e[n++] });
        continue;
      }
      if (a === ":") {
        let l = "", s = n + 1;
        for (;s < e.length; ) {
          let i = e.substr(s, 1);
          if (s === n + 1 && Te.test(i) || s !== n + 1 && Ae.test(i)) {
            l += e[s++];
            continue;
          }
          break;
        }
        if (!l) {
          c(`Missing parameter name at ${n}`);
          continue;
        }
        r.push({ type: "NAME", index: n, value: l }), n = s;
        continue;
      }
      if (a === "(") {
        let l = 1, s = "", i = n + 1, o = false;
        if (e[i] === "?") {
          c(`Pattern cannot start with "?" at ${i}`);
          continue;
        }
        for (;i < e.length; ) {
          if (!we(e[i], false)) {
            c(`Invalid character '${e[i]}' at ${i}.`), o = true;
            break;
          }
          if (e[i] === "\\") {
            s += e[i++] + e[i++];
            continue;
          }
          if (e[i] === ")") {
            if (l--, l === 0) {
              i++;
              break;
            }
          } else if (e[i] === "(" && (l++, e[i + 1] !== "?")) {
            c(`Capturing groups are not allowed at ${i}`), o = true;
            break;
          }
          s += e[i++];
        }
        if (o)
          continue;
        if (l) {
          c(`Unbalanced pattern at ${n}`);
          continue;
        }
        if (!s) {
          c(`Missing pattern at ${n}`);
          continue;
        }
        r.push({ type: "REGEX", index: n, value: s }), n = i;
        continue;
      }
      r.push({ type: "CHAR", index: n, value: e[n++] });
    }
    return r.push({ type: "END", index: n, value: "" }), r;
  };
  var F = function(e, t = {}) {
    let r = D(e);
    t.delimiter ??= "/#?", t.prefixes ??= "./";
    let n = `[^${x(t.delimiter)}]+?`, a = [], c = 0, l = 0, s = "", i = new Set, o = (f) => {
      if (l < r.length && r[l].type === f)
        return r[l++].value;
    }, h = () => o("OTHER_MODIFIER") ?? o("ASTERISK"), p = (f) => {
      let u = o(f);
      if (u !== undefined)
        return u;
      let { type: d, index: T } = r[l];
      throw new TypeError(`Unexpected ${d} at ${T}, expected ${f}`);
    }, O = () => {
      let f = "", u;
      for (;u = o("CHAR") ?? o("ESCAPED_CHAR"); )
        f += u;
      return f;
    }, be = (f) => f, L = t.encodePart || be, I = "", H = (f) => {
      I += f;
    }, $ = () => {
      I.length && (a.push(new k(3, "", "", L(I), "", 3)), I = "");
    }, X = (f, u, d, T, Z) => {
      let g = 3;
      switch (Z) {
        case "?":
          g = 1;
          break;
        case "*":
          g = 0;
          break;
        case "+":
          g = 2;
          break;
      }
      if (!u && !d && g === 3) {
        H(f);
        return;
      }
      if ($(), !u && !d) {
        if (!f)
          return;
        a.push(new k(3, "", "", L(f), "", g));
        return;
      }
      let m;
      d ? d === "*" ? m = v : m = d : m = n;
      let R = 2;
      m === n ? (R = 1, m = "") : m === v && (R = 0, m = "");
      let S;
      if (u ? S = u : d && (S = c++), i.has(S))
        throw new TypeError(`Duplicate name '${S}'.`);
      i.add(S), a.push(new k(R, S, L(f), m, L(T), g));
    };
    for (;l < r.length; ) {
      let f = o("CHAR"), u = o("NAME"), d = o("REGEX");
      if (!u && !d && (d = o("ASTERISK")), u || d) {
        let g = f ?? "";
        t.prefixes.indexOf(g) === -1 && (H(g), g = ""), $();
        let m = h();
        X(g, u, d, "", m);
        continue;
      }
      let T = f ?? o("ESCAPED_CHAR");
      if (T) {
        H(T);
        continue;
      }
      if (o("OPEN")) {
        let g = O(), m = o("NAME"), R = o("REGEX");
        !m && !R && (R = o("ASTERISK"));
        let S = O();
        p("CLOSE");
        let Pe = h();
        X(g, m, R, S, Pe);
        continue;
      }
      $(), p("END");
    }
    return a;
  };
  var x = function(e) {
    return e.replace(/([.+*?^${}()[\]|/\\])/g, "\\$1");
  };
  var B = function(e) {
    return e && e.ignoreCase ? "ui" : "u";
  };
  var q = function(e, t, r) {
    return W(F(e, r), t, r);
  };
  var y = function(e) {
    switch (e) {
      case 0:
        return "*";
      case 1:
        return "?";
      case 2:
        return "+";
      case 3:
        return "";
    }
  };
  var W = function(e, t, r = {}) {
    r.delimiter ??= "/#?", r.prefixes ??= "./", r.sensitive ??= false, r.strict ??= false, r.end ??= true, r.start ??= true, r.endsWith = "";
    let n = r.start ? "^" : "";
    for (let s of e) {
      if (s.type === 3) {
        s.modifier === 3 ? n += x(s.value) : n += `(?:${x(s.value)})${y(s.modifier)}`;
        continue;
      }
      t && t.push(s.name);
      let i = `[^${x(r.delimiter)}]+?`, o = s.value;
      if (s.type === 1 ? o = i : s.type === 0 && (o = v), !s.prefix.length && !s.suffix.length) {
        s.modifier === 3 || s.modifier === 1 ? n += `(${o})${y(s.modifier)}` : n += `((?:${o})${y(s.modifier)})`;
        continue;
      }
      if (s.modifier === 3 || s.modifier === 1) {
        n += `(?:${x(s.prefix)}(${o})${x(s.suffix)})`, n += y(s.modifier);
        continue;
      }
      n += `(?:${x(s.prefix)}`, n += `((?:${o})(?:`, n += x(s.suffix), n += x(s.prefix), n += `(?:${o}))*)${x(s.suffix)})`, s.modifier === 0 && (n += "?");
    }
    let a = `[${x(r.endsWith)}]|\$`, c = `[${x(r.delimiter)}]`;
    if (r.end)
      return r.strict || (n += `${c}?`), r.endsWith.length ? n += `(?=${a})` : n += "$", new RegExp(n, B(r));
    r.strict || (n += `(?:${c}(?=${a}))?`);
    let l = false;
    if (e.length) {
      let s = e[e.length - 1];
      s.type === 3 && s.modifier === 3 && (l = r.delimiter.indexOf(s) > -1);
    }
    return l || (n += `(?=${c}|${a})`), new RegExp(n, B(r));
  };
  var ee = function(e, t) {
    return e.length ? e[0] === "/" ? true : !t || e.length < 2 ? false : (e[0] == "\\" || e[0] == "{") && e[1] == "/" : false;
  };
  var te = function(e, t) {
    return e.startsWith(t) ? e.substring(t.length, e.length) : e;
  };
  var Ce = function(e, t) {
    return e.endsWith(t) ? e.substr(0, e.length - t.length) : e;
  };
  var _ = function(e) {
    return !e || e.length < 2 ? false : e[0] === "[" || (e[0] === "\\" || e[0] === "{") && e[1] === "[";
  };
  var N = function(e) {
    if (!e)
      return true;
    for (let t of re)
      if (e.test(t))
        return true;
    return false;
  };
  var ne = function(e, t) {
    if (e = te(e, "#"), t || e === "")
      return e;
    let r = new URL("https://example.com");
    return r.hash = e, r.hash ? r.hash.substring(1, r.hash.length) : "";
  };
  var se = function(e, t) {
    if (e = te(e, "?"), t || e === "")
      return e;
    let r = new URL("https://example.com");
    return r.search = e, r.search ? r.search.substring(1, r.search.length) : "";
  };
  var ie = function(e, t) {
    return t || e === "" ? e : _(e) ? K(e) : j(e);
  };
  var ae = function(e, t) {
    if (t || e === "")
      return e;
    let r = new URL("https://example.com");
    return r.password = e, r.password;
  };
  var oe = function(e, t) {
    if (t || e === "")
      return e;
    let r = new URL("https://example.com");
    return r.username = e, r.username;
  };
  var ce = function(e, t, r) {
    if (r || e === "")
      return e;
    if (t && !re.includes(t))
      return new URL(`${t}:${e}`).pathname;
    let n = e[0] == "/";
    return e = new URL(n ? e : "/-" + e, "https://example.com").pathname, n || (e = e.substring(2, e.length)), e;
  };
  var le = function(e, t, r) {
    return z(t) === e && (e = ""), r || e === "" ? e : V(e);
  };
  var he = function(e, t) {
    return e = Ce(e, ":"), t || e === "" ? e : A(e);
  };
  var z = function(e) {
    switch (e) {
      case "ws":
      case "http":
        return "80";
      case "wws":
      case "https":
        return "443";
      case "ftp":
        return "21";
      default:
        return "";
    }
  };
  var A = function(e) {
    if (e === "")
      return e;
    if (/^[-+.A-Za-z0-9]*$/.test(e))
      return e.toLowerCase();
    throw new TypeError(`Invalid protocol '${e}'.`);
  };
  var fe = function(e) {
    if (e === "")
      return e;
    let t = new URL("https://example.com");
    return t.username = e, t.username;
  };
  var ue = function(e) {
    if (e === "")
      return e;
    let t = new URL("https://example.com");
    return t.password = e, t.password;
  };
  var j = function(e) {
    if (e === "")
      return e;
    if (/[\t\n\r #%/:<>?@[\]^\\|]/g.test(e))
      throw new TypeError(`Invalid hostname '${e}'`);
    let t = new URL("https://example.com");
    return t.hostname = e, t.hostname;
  };
  var K = function(e) {
    if (e === "")
      return e;
    if (/[^0-9a-fA-F[\]:]/g.test(e))
      throw new TypeError(`Invalid IPv6 hostname '${e}'`);
    return e.toLowerCase();
  };
  var V = function(e) {
    if (e === "" || /^[0-9]*$/.test(e) && parseInt(e) <= 65535)
      return e;
    throw new TypeError(`Invalid port '${e}'.`);
  };
  var pe = function(e) {
    if (e === "")
      return e;
    let t = new URL("https://example.com");
    return t.pathname = e[0] !== "/" ? "/-" + e : e, e[0] !== "/" ? t.pathname.substring(2, t.pathname.length) : t.pathname;
  };
  var de = function(e) {
    return e === "" ? e : new URL(`data:${e}`).pathname;
  };
  var ge = function(e) {
    if (e === "")
      return e;
    let t = new URL("https://example.com");
    return t.search = e, t.search.substring(1, t.search.length);
  };
  var me = function(e) {
    if (e === "")
      return e;
    let t = new URL("https://example.com");
    return t.hash = e, t.hash.substring(1, t.hash.length);
  };
  var xe = function(e, t) {
    if (typeof e != "string")
      throw new TypeError("parameter 1 is not of type 'string'.");
    let r = new URL(e, t);
    return { protocol: r.protocol.substring(0, r.protocol.length - 1), username: r.username, password: r.password, hostname: r.hostname, port: r.port, pathname: r.pathname, search: r.search !== "" ? r.search.substring(1, r.search.length) : undefined, hash: r.hash !== "" ? r.hash.substring(1, r.hash.length) : undefined };
  };
  var P = function(e, t) {
    return t ? C(e) : e;
  };
  var w = function(e, t, r) {
    let n;
    if (typeof t.baseURL == "string")
      try {
        n = new URL(t.baseURL), e.protocol = P(n.protocol.substring(0, n.protocol.length - 1), r), e.username = P(n.username, r), e.password = P(n.password, r), e.hostname = P(n.hostname, r), e.port = P(n.port, r), e.pathname = P(n.pathname, r), e.search = P(n.search.substring(1, n.search.length), r), e.hash = P(n.hash.substring(1, n.hash.length), r);
      } catch {
        throw new TypeError(`invalid baseURL '${t.baseURL}'.`);
      }
    if (typeof t.protocol == "string" && (e.protocol = he(t.protocol, r)), typeof t.username == "string" && (e.username = oe(t.username, r)), typeof t.password == "string" && (e.password = ae(t.password, r)), typeof t.hostname == "string" && (e.hostname = ie(t.hostname, r)), typeof t.port == "string" && (e.port = le(t.port, e.protocol, r)), typeof t.pathname == "string") {
      if (e.pathname = t.pathname, n && !ee(e.pathname, r)) {
        let a = n.pathname.lastIndexOf("/");
        a >= 0 && (e.pathname = P(n.pathname.substring(0, a + 1), r) + e.pathname);
      }
      e.pathname = ce(e.pathname, e.protocol, r);
    }
    return typeof t.search == "string" && (e.search = se(t.search, r)), typeof t.hash == "string" && (e.hash = ne(t.hash, r)), e;
  };
  var C = function(e) {
    return e.replace(/([+*?:{}()\\])/g, "\\$1");
  };
  var Le = function(e) {
    return e.replace(/([.+*?^${}()[\]|/\\])/g, "\\$1");
  };
  var Ie = function(e, t) {
    t.delimiter ??= "/#?", t.prefixes ??= "./", t.sensitive ??= false, t.strict ??= false, t.end ??= true, t.start ??= true, t.endsWith = "";
    let r = ".*", n = `[^${Le(t.delimiter)}]+?`, a = /[$_\u200C\u200D\p{ID_Continue}]/u, c = "";
    for (let l = 0;l < e.length; ++l) {
      let s = e[l];
      if (s.type === 3) {
        if (s.modifier === 3) {
          c += C(s.value);
          continue;
        }
        c += `{${C(s.value)}}${y(s.modifier)}`;
        continue;
      }
      let i = s.hasCustomName(), o = !!s.suffix.length || !!s.prefix.length && (s.prefix.length !== 1 || !t.prefixes.includes(s.prefix)), h = l > 0 ? e[l - 1] : null, p = l < e.length - 1 ? e[l + 1] : null;
      if (!o && i && s.type === 1 && s.modifier === 3 && p && !p.prefix.length && !p.suffix.length)
        if (p.type === 3) {
          let O = p.value.length > 0 ? p.value[0] : "";
          o = a.test(O);
        } else
          o = !p.hasCustomName();
      if (!o && !s.prefix.length && h && h.type === 3) {
        let O = h.value[h.value.length - 1];
        o = t.prefixes.includes(O);
      }
      o && (c += "{"), c += C(s.prefix), i && (c += `:${s.name}`), s.type === 2 ? c += `(${s.value})` : s.type === 1 ? i || (c += `(${n})`) : s.type === 0 && (!i && (!h || h.type === 3 || h.modifier !== 3 || o || s.prefix !== "") ? c += "*" : c += `(${r})`), s.type === 1 && i && s.suffix.length && a.test(s.suffix[0]) && (c += "\\"), c += C(s.suffix), o && (c += "}"), s.modifier !== 3 && (c += y(s.modifier));
    }
    return c;
  };
  var M = Object.defineProperty;
  var Se = Object.getOwnPropertyDescriptor;
  var ke = Object.getOwnPropertyNames;
  var Ee = Object.prototype.hasOwnProperty;
  var Re = (e, t) => {
    for (var r in t)
      M(e, r, { get: t[r], enumerable: true });
  };
  var ye = (e, t, r, n) => {
    if (t && typeof t == "object" || typeof t == "function")
      for (let a of ke(t))
        !Ee.call(e, a) && a !== r && M(e, a, { get: () => t[a], enumerable: !(n = Se(t, a)) || n.enumerable });
    return e;
  };
  var Oe = (e) => ye(M({}, "__esModule", { value: true }), e);
  var Ne = {};
  Re(Ne, { URLPattern: () => Y });
  module.exports = Oe(Ne);
  var k = class {
    type = 3;
    name = "";
    prefix = "";
    value = "";
    suffix = "";
    modifier = 3;
    constructor(t, r, n, a, c, l) {
      this.type = t, this.name = r, this.prefix = n, this.value = a, this.suffix = c, this.modifier = l;
    }
    hasCustomName() {
      return this.name !== "" && typeof this.name != "number";
    }
  };
  var Te = /[$_\p{ID_Start}]/u;
  var Ae = /[$_\u200C\u200D\p{ID_Continue}]/u;
  var v = ".*";
  var b = { delimiter: "", prefixes: "", sensitive: true, strict: true };
  var J = { delimiter: ".", prefixes: "", sensitive: true, strict: true };
  var Q = { delimiter: "/", prefixes: "/", sensitive: true, strict: true };
  var re = ["ftp", "file", "http", "https", "ws", "wss"];
  var U = class {
    #i;
    #n = [];
    #t = {};
    #e = 0;
    #s = 1;
    #u = 0;
    #c = 0;
    #p = 0;
    #d = 0;
    #g = false;
    constructor(t) {
      this.#i = t;
    }
    get result() {
      return this.#t;
    }
    parse() {
      for (this.#n = D(this.#i, true);this.#e < this.#n.length; this.#e += this.#s) {
        if (this.#s = 1, this.#n[this.#e].type === "END") {
          if (this.#c === 0) {
            this.#P(), this.#l() ? this.#r(9, 1) : this.#h() ? (this.#r(8, 1), this.#t.hash = "") : (this.#r(7, 0), this.#t.search = "", this.#t.hash = "");
            continue;
          } else if (this.#c === 2) {
            this.#f(5);
            continue;
          }
          this.#r(10, 0);
          break;
        }
        if (this.#p > 0)
          if (this.#T())
            this.#p -= 1;
          else
            continue;
        if (this.#O()) {
          this.#p += 1;
          continue;
        }
        switch (this.#c) {
          case 0:
            this.#S() && (this.#t.username = "", this.#t.password = "", this.#t.hostname = "", this.#t.port = "", this.#t.pathname = "", this.#t.search = "", this.#t.hash = "", this.#f(1));
            break;
          case 1:
            if (this.#S()) {
              this.#C();
              let t = 7, r = 1;
              this.#g && (this.#t.pathname = "/"), this.#E() ? (t = 2, r = 3) : this.#g && (t = 2), this.#r(t, r);
            }
            break;
          case 2:
            this.#x() ? this.#f(3) : (this.#b() || this.#h() || this.#l()) && this.#f(5);
            break;
          case 3:
            this.#R() ? this.#r(4, 1) : this.#x() && this.#r(5, 1);
            break;
          case 4:
            this.#x() && this.#r(5, 1);
            break;
          case 5:
            this.#A() ? this.#d += 1 : this.#w() && (this.#d -= 1), this.#y() && !this.#d ? this.#r(6, 1) : this.#b() ? this.#r(7, 0) : this.#h() ? this.#r(8, 1) : this.#l() && this.#r(9, 1);
            break;
          case 6:
            this.#b() ? this.#r(7, 0) : this.#h() ? this.#r(8, 1) : this.#l() && this.#r(9, 1);
            break;
          case 7:
            this.#h() ? this.#r(8, 1) : this.#l() && this.#r(9, 1);
            break;
          case 8:
            this.#l() && this.#r(9, 1);
            break;
          case 9:
            break;
          case 10:
            break;
        }
      }
    }
    #r(t, r) {
      switch (this.#c) {
        case 0:
          break;
        case 1:
          this.#t.protocol = this.#o();
          break;
        case 2:
          break;
        case 3:
          this.#t.username = this.#o();
          break;
        case 4:
          this.#t.password = this.#o();
          break;
        case 5:
          this.#t.hostname = this.#o();
          break;
        case 6:
          this.#t.port = this.#o();
          break;
        case 7:
          this.#t.pathname = this.#o();
          break;
        case 8:
          this.#t.search = this.#o();
          break;
        case 9:
          this.#t.hash = this.#o();
          break;
        case 10:
          break;
      }
      this.#k(t, r);
    }
    #k(t, r) {
      this.#c = t, this.#u = this.#e + r, this.#e += r, this.#s = 0;
    }
    #P() {
      this.#e = this.#u, this.#s = 0;
    }
    #f(t) {
      this.#P(), this.#c = t;
    }
    #m(t) {
      return t < 0 && (t = this.#n.length - t), t < this.#n.length ? this.#n[t] : this.#n[this.#n.length - 1];
    }
    #a(t, r) {
      let n = this.#m(t);
      return n.value === r && (n.type === "CHAR" || n.type === "ESCAPED_CHAR" || n.type === "INVALID_CHAR");
    }
    #S() {
      return this.#a(this.#e, ":");
    }
    #E() {
      return this.#a(this.#e + 1, "/") && this.#a(this.#e + 2, "/");
    }
    #x() {
      return this.#a(this.#e, "@");
    }
    #R() {
      return this.#a(this.#e, ":");
    }
    #y() {
      return this.#a(this.#e, ":");
    }
    #b() {
      return this.#a(this.#e, "/");
    }
    #h() {
      if (this.#a(this.#e, "?"))
        return true;
      if (this.#n[this.#e].value !== "?")
        return false;
      let t = this.#m(this.#e - 1);
      return t.type !== "NAME" && t.type !== "REGEX" && t.type !== "CLOSE" && t.type !== "ASTERISK";
    }
    #l() {
      return this.#a(this.#e, "#");
    }
    #O() {
      return this.#n[this.#e].type == "OPEN";
    }
    #T() {
      return this.#n[this.#e].type == "CLOSE";
    }
    #A() {
      return this.#a(this.#e, "[");
    }
    #w() {
      return this.#a(this.#e, "]");
    }
    #o() {
      let t = this.#n[this.#e], r = this.#m(this.#u).index;
      return this.#i.substring(r, t.index);
    }
    #C() {
      let t = {};
      Object.assign(t, b), t.encodePart = A;
      let r = q(this.#o(), undefined, t);
      this.#g = N(r);
    }
  };
  var G = ["protocol", "username", "password", "hostname", "port", "pathname", "search", "hash"];
  var E = "*";
  var Y = class {
    #i;
    #n = {};
    #t = {};
    #e = {};
    #s = {};
    constructor(t = {}, r, n) {
      try {
        let a;
        if (typeof r == "string" ? a = r : n = r, typeof t == "string") {
          let i = new U(t);
          if (i.parse(), t = i.result, a === undefined && typeof t.protocol != "string")
            throw new TypeError("A base URL must be provided for a relative constructor string.");
          t.baseURL = a;
        } else {
          if (!t || typeof t != "object")
            throw new TypeError("parameter 1 is not of type 'string' and cannot convert to dictionary.");
          if (a)
            throw new TypeError("parameter 1 is not of type 'string'.");
        }
        typeof n > "u" && (n = { ignoreCase: false });
        let c = { ignoreCase: n.ignoreCase === true }, l = { pathname: E, protocol: E, username: E, password: E, hostname: E, port: E, search: E, hash: E };
        this.#i = w(l, t, true), z(this.#i.protocol) === this.#i.port && (this.#i.port = "");
        let s;
        for (s of G) {
          if (!(s in this.#i))
            continue;
          let i = {}, o = this.#i[s];
          switch (this.#t[s] = [], s) {
            case "protocol":
              Object.assign(i, b), i.encodePart = A;
              break;
            case "username":
              Object.assign(i, b), i.encodePart = fe;
              break;
            case "password":
              Object.assign(i, b), i.encodePart = ue;
              break;
            case "hostname":
              Object.assign(i, J), _(o) ? i.encodePart = K : i.encodePart = j;
              break;
            case "port":
              Object.assign(i, b), i.encodePart = V;
              break;
            case "pathname":
              N(this.#n.protocol) ? (Object.assign(i, Q, c), i.encodePart = pe) : (Object.assign(i, b, c), i.encodePart = de);
              break;
            case "search":
              Object.assign(i, b, c), i.encodePart = ge;
              break;
            case "hash":
              Object.assign(i, b, c), i.encodePart = me;
              break;
          }
          try {
            this.#s[s] = F(o, i), this.#n[s] = W(this.#s[s], this.#t[s], i), this.#e[s] = Ie(this.#s[s], i);
          } catch {
            throw new TypeError(`invalid ${s} pattern '${this.#i[s]}'.`);
          }
        }
      } catch (a) {
        throw new TypeError(`Failed to construct 'URLPattern': ${a.message}`);
      }
    }
    test(t = {}, r) {
      let n = { pathname: "", protocol: "", username: "", password: "", hostname: "", port: "", search: "", hash: "" };
      if (typeof t != "string" && r)
        throw new TypeError("parameter 1 is not of type 'string'.");
      if (typeof t > "u")
        return false;
      try {
        typeof t == "object" ? n = w(n, t, false) : n = w(n, xe(t, r), false);
      } catch {
        return false;
      }
      let a;
      for (a of G)
        if (!this.#n[a].exec(n[a]))
          return false;
      return true;
    }
    exec(t = {}, r) {
      let n = { pathname: "", protocol: "", username: "", password: "", hostname: "", port: "", search: "", hash: "" };
      if (typeof t != "string" && r)
        throw new TypeError("parameter 1 is not of type 'string'.");
      if (typeof t > "u")
        return;
      try {
        typeof t == "object" ? n = w(n, t, false) : n = w(n, xe(t, r), false);
      } catch {
        return null;
      }
      let a = {};
      r ? a.inputs = [t, r] : a.inputs = [t];
      let c;
      for (c of G) {
        let l = this.#n[c].exec(n[c]);
        if (!l)
          return null;
        let s = {};
        for (let [i, o] of this.#t[c].entries())
          if (typeof o == "string" || typeof o == "number") {
            let h = l[i + 1];
            s[o] = h;
          }
        a[c] = { input: n[c] ?? "", groups: s };
      }
      return a;
    }
    static compareComponent(t, r, n) {
      let a = (i, o) => {
        for (let h of ["type", "modifier", "prefix", "value", "suffix"]) {
          if (i[h] < o[h])
            return -1;
          if (i[h] === o[h])
            continue;
          return 1;
        }
        return 0;
      }, c = new k(3, "", "", "", "", 3), l = new k(0, "", "", "", "", 3), s = (i, o) => {
        let h = 0;
        for (;h < Math.min(i.length, o.length); ++h) {
          let p = a(i[h], o[h]);
          if (p)
            return p;
        }
        return i.length === o.length ? 0 : a(i[h] ?? c, o[h] ?? c);
      };
      return !r.#e[t] && !n.#e[t] ? 0 : r.#e[t] && !n.#e[t] ? s(r.#s[t], [l]) : !r.#e[t] && n.#e[t] ? s([l], n.#s[t]) : s(r.#s[t], n.#s[t]);
    }
    get protocol() {
      return this.#e.protocol;
    }
    get username() {
      return this.#e.username;
    }
    get password() {
      return this.#e.password;
    }
    get hostname() {
      return this.#e.hostname;
    }
    get port() {
      return this.#e.port;
    }
    get pathname() {
      return this.#e.pathname;
    }
    get search() {
      return this.#e.search;
    }
    get hash() {
      return this.#e.hash;
    }
  };
});

// node_modules/urlpattern-polyfill/index.cjs
var require_urlpattern_polyfill = __commonJS((exports, module) => {
  var { URLPattern } = require_urlpattern();
  module.exports = { URLPattern };
  if (!globalThis.URLPattern) {
    globalThis.URLPattern = URLPattern;
  }
});

// node_modules/@whatwg-node/node-fetch/cjs/AbortError.js
var require_AbortError = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.PonyfillAbortError = undefined;

  class PonyfillAbortError extends Error {
    constructor(reason) {
      let message = "The operation was aborted";
      if (reason) {
        message += ` reason: ${reason}`;
      }
      super(message, {
        cause: reason
      });
      this.name = "AbortError";
    }
    get reason() {
      return this.cause;
    }
  }
  exports.PonyfillAbortError = PonyfillAbortError;
});

// node_modules/busboy/lib/utils.js
var require_utils = __commonJS((exports, module) => {
  var parseContentType = function(str) {
    if (str.length === 0)
      return;
    const params = Object.create(null);
    let i = 0;
    for (;i < str.length; ++i) {
      const code = str.charCodeAt(i);
      if (TOKEN[code] !== 1) {
        if (code !== 47 || i === 0)
          return;
        break;
      }
    }
    if (i === str.length)
      return;
    const type = str.slice(0, i).toLowerCase();
    const subtypeStart = ++i;
    for (;i < str.length; ++i) {
      const code = str.charCodeAt(i);
      if (TOKEN[code] !== 1) {
        if (i === subtypeStart)
          return;
        if (parseContentTypeParams(str, i, params) === undefined)
          return;
        break;
      }
    }
    if (i === subtypeStart)
      return;
    const subtype = str.slice(subtypeStart, i).toLowerCase();
    return { type, subtype, params };
  };
  var parseContentTypeParams = function(str, i, params) {
    while (i < str.length) {
      for (;i < str.length; ++i) {
        const code = str.charCodeAt(i);
        if (code !== 32 && code !== 9)
          break;
      }
      if (i === str.length)
        break;
      if (str.charCodeAt(i++) !== 59)
        return;
      for (;i < str.length; ++i) {
        const code = str.charCodeAt(i);
        if (code !== 32 && code !== 9)
          break;
      }
      if (i === str.length)
        return;
      let name4;
      const nameStart = i;
      for (;i < str.length; ++i) {
        const code = str.charCodeAt(i);
        if (TOKEN[code] !== 1) {
          if (code !== 61)
            return;
          break;
        }
      }
      if (i === str.length)
        return;
      name4 = str.slice(nameStart, i);
      ++i;
      if (i === str.length)
        return;
      let value = "";
      let valueStart;
      if (str.charCodeAt(i) === 34) {
        valueStart = ++i;
        let escaping = false;
        for (;i < str.length; ++i) {
          const code = str.charCodeAt(i);
          if (code === 92) {
            if (escaping) {
              valueStart = i;
              escaping = false;
            } else {
              value += str.slice(valueStart, i);
              escaping = true;
            }
            continue;
          }
          if (code === 34) {
            if (escaping) {
              valueStart = i;
              escaping = false;
              continue;
            }
            value += str.slice(valueStart, i);
            break;
          }
          if (escaping) {
            valueStart = i - 1;
            escaping = false;
          }
          if (QDTEXT[code] !== 1)
            return;
        }
        if (i === str.length)
          return;
        ++i;
      } else {
        valueStart = i;
        for (;i < str.length; ++i) {
          const code = str.charCodeAt(i);
          if (TOKEN[code] !== 1) {
            if (i === valueStart)
              return;
            break;
          }
        }
        value = str.slice(valueStart, i);
      }
      name4 = name4.toLowerCase();
      if (params[name4] === undefined)
        params[name4] = value;
    }
    return params;
  };
  var parseDisposition = function(str, defDecoder) {
    if (str.length === 0)
      return;
    const params = Object.create(null);
    let i = 0;
    for (;i < str.length; ++i) {
      const code = str.charCodeAt(i);
      if (TOKEN[code] !== 1) {
        if (parseDispositionParams(str, i, params, defDecoder) === undefined)
          return;
        break;
      }
    }
    const type = str.slice(0, i).toLowerCase();
    return { type, params };
  };
  var parseDispositionParams = function(str, i, params, defDecoder) {
    while (i < str.length) {
      for (;i < str.length; ++i) {
        const code = str.charCodeAt(i);
        if (code !== 32 && code !== 9)
          break;
      }
      if (i === str.length)
        break;
      if (str.charCodeAt(i++) !== 59)
        return;
      for (;i < str.length; ++i) {
        const code = str.charCodeAt(i);
        if (code !== 32 && code !== 9)
          break;
      }
      if (i === str.length)
        return;
      let name4;
      const nameStart = i;
      for (;i < str.length; ++i) {
        const code = str.charCodeAt(i);
        if (TOKEN[code] !== 1) {
          if (code === 61)
            break;
          return;
        }
      }
      if (i === str.length)
        return;
      let value = "";
      let valueStart;
      let charset;
      name4 = str.slice(nameStart, i);
      if (name4.charCodeAt(name4.length - 1) === 42) {
        const charsetStart = ++i;
        for (;i < str.length; ++i) {
          const code = str.charCodeAt(i);
          if (CHARSET[code] !== 1) {
            if (code !== 39)
              return;
            break;
          }
        }
        if (i === str.length)
          return;
        charset = str.slice(charsetStart, i);
        ++i;
        for (;i < str.length; ++i) {
          const code = str.charCodeAt(i);
          if (code === 39)
            break;
        }
        if (i === str.length)
          return;
        ++i;
        if (i === str.length)
          return;
        valueStart = i;
        let encode = 0;
        for (;i < str.length; ++i) {
          const code = str.charCodeAt(i);
          if (EXTENDED_VALUE[code] !== 1) {
            if (code === 37) {
              let hexUpper;
              let hexLower;
              if (i + 2 < str.length && (hexUpper = HEX_VALUES[str.charCodeAt(i + 1)]) !== -1 && (hexLower = HEX_VALUES[str.charCodeAt(i + 2)]) !== -1) {
                const byteVal = (hexUpper << 4) + hexLower;
                value += str.slice(valueStart, i);
                value += String.fromCharCode(byteVal);
                i += 2;
                valueStart = i + 1;
                if (byteVal >= 128)
                  encode = 2;
                else if (encode === 0)
                  encode = 1;
                continue;
              }
              return;
            }
            break;
          }
        }
        value += str.slice(valueStart, i);
        value = convertToUTF8(value, charset, encode);
        if (value === undefined)
          return;
      } else {
        ++i;
        if (i === str.length)
          return;
        if (str.charCodeAt(i) === 34) {
          valueStart = ++i;
          let escaping = false;
          for (;i < str.length; ++i) {
            const code = str.charCodeAt(i);
            if (code === 92) {
              if (escaping) {
                valueStart = i;
                escaping = false;
              } else {
                value += str.slice(valueStart, i);
                escaping = true;
              }
              continue;
            }
            if (code === 34) {
              if (escaping) {
                valueStart = i;
                escaping = false;
                continue;
              }
              value += str.slice(valueStart, i);
              break;
            }
            if (escaping) {
              valueStart = i - 1;
              escaping = false;
            }
            if (QDTEXT[code] !== 1)
              return;
          }
          if (i === str.length)
            return;
          ++i;
        } else {
          valueStart = i;
          for (;i < str.length; ++i) {
            const code = str.charCodeAt(i);
            if (TOKEN[code] !== 1) {
              if (i === valueStart)
                return;
              break;
            }
          }
          value = str.slice(valueStart, i);
        }
        value = defDecoder(value, 2);
        if (value === undefined)
          return;
      }
      name4 = name4.toLowerCase();
      if (params[name4] === undefined)
        params[name4] = value;
    }
    return params;
  };
  var getDecoder = function(charset) {
    let lc;
    while (true) {
      switch (charset) {
        case "utf-8":
        case "utf8":
          return decoders.utf8;
        case "latin1":
        case "ascii":
        case "us-ascii":
        case "iso-8859-1":
        case "iso8859-1":
        case "iso88591":
        case "iso_8859-1":
        case "windows-1252":
        case "iso_8859-1:1987":
        case "cp1252":
        case "x-cp1252":
          return decoders.latin1;
        case "utf16le":
        case "utf-16le":
        case "ucs2":
        case "ucs-2":
          return decoders.utf16le;
        case "base64":
          return decoders.base64;
        default:
          if (lc === undefined) {
            lc = true;
            charset = charset.toLowerCase();
            continue;
          }
          return decoders.other.bind(charset);
      }
    }
  };
  var convertToUTF8 = function(data, charset, hint) {
    const decode2 = getDecoder(charset);
    if (decode2)
      return decode2(data, hint);
  };
  var basename2 = function(path5) {
    if (typeof path5 !== "string")
      return "";
    for (let i = path5.length - 1;i >= 0; --i) {
      switch (path5.charCodeAt(i)) {
        case 47:
        case 92:
          path5 = path5.slice(i + 1);
          return path5 === ".." || path5 === "." ? "" : path5;
      }
    }
    return path5 === ".." || path5 === "." ? "" : path5;
  };
  var decoders = {
    utf8: (data, hint) => {
      if (data.length === 0)
        return "";
      if (typeof data === "string") {
        if (hint < 2)
          return data;
        data = Buffer.from(data, "latin1");
      }
      return data.utf8Slice(0, data.length);
    },
    latin1: (data, hint) => {
      if (data.length === 0)
        return "";
      if (typeof data === "string")
        return data;
      return data.latin1Slice(0, data.length);
    },
    utf16le: (data, hint) => {
      if (data.length === 0)
        return "";
      if (typeof data === "string")
        data = Buffer.from(data, "latin1");
      return data.ucs2Slice(0, data.length);
    },
    base64: (data, hint) => {
      if (data.length === 0)
        return "";
      if (typeof data === "string")
        data = Buffer.from(data, "latin1");
      return data.base64Slice(0, data.length);
    },
    other: (data, hint) => {
      if (data.length === 0)
        return "";
      if (typeof data === "string")
        data = Buffer.from(data, "latin1");
      try {
        const decoder = new TextDecoder(exports);
        return decoder.decode(data);
      } catch {
      }
    }
  };
  var TOKEN = [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    0,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    1,
    1,
    0,
    1,
    1,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    1,
    0,
    1,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0
  ];
  var QDTEXT = [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    1,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1
  ];
  var CHARSET = [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    0,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    0,
    1,
    0,
    1,
    0,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    1,
    1,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0
  ];
  var EXTENDED_VALUE = [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    0,
    1,
    1,
    0,
    1,
    0,
    0,
    0,
    0,
    1,
    0,
    1,
    1,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    1,
    0,
    1,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0
  ];
  var HEX_VALUES = [
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    0,
    1,
    2,
    3,
    4,
    5,
    6,
    7,
    8,
    9,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    10,
    11,
    12,
    13,
    14,
    15,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    10,
    11,
    12,
    13,
    14,
    15,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1
  ];
  module.exports = {
    basename: basename2,
    convertToUTF8,
    getDecoder,
    parseContentType,
    parseDisposition
  };
});

// node_modules/streamsearch/lib/sbmh.js
var require_sbmh = __commonJS((exports, module) => {
  var memcmp = function(buf1, pos1, buf2, pos2, num) {
    for (let i = 0;i < num; ++i) {
      if (buf1[pos1 + i] !== buf2[pos2 + i])
        return false;
    }
    return true;
  };
  var feed = function(self2, data) {
    const len = data.length;
    const needle = self2._needle;
    const needleLen = needle.length;
    let pos = -self2._lookbehindSize;
    const lastNeedleCharPos = needleLen - 1;
    const lastNeedleChar = needle[lastNeedleCharPos];
    const end = len - needleLen;
    const occ = self2._occ;
    const lookbehind = self2._lookbehind;
    if (pos < 0) {
      while (pos < 0 && pos <= end) {
        const nextPos = pos + lastNeedleCharPos;
        const ch = nextPos < 0 ? lookbehind[self2._lookbehindSize + nextPos] : data[nextPos];
        if (ch === lastNeedleChar && matchNeedle(self2, data, pos, lastNeedleCharPos)) {
          self2._lookbehindSize = 0;
          ++self2.matches;
          if (pos > -self2._lookbehindSize)
            self2._cb(true, lookbehind, 0, self2._lookbehindSize + pos, false);
          else
            self2._cb(true, undefined, 0, 0, true);
          return self2._bufPos = pos + needleLen;
        }
        pos += occ[ch];
      }
      while (pos < 0 && !matchNeedle(self2, data, pos, len - pos))
        ++pos;
      if (pos < 0) {
        const bytesToCutOff = self2._lookbehindSize + pos;
        if (bytesToCutOff > 0) {
          self2._cb(false, lookbehind, 0, bytesToCutOff, false);
        }
        self2._lookbehindSize -= bytesToCutOff;
        lookbehind.copy(lookbehind, 0, bytesToCutOff, self2._lookbehindSize);
        lookbehind.set(data, self2._lookbehindSize);
        self2._lookbehindSize += len;
        self2._bufPos = len;
        return len;
      }
      self2._cb(false, lookbehind, 0, self2._lookbehindSize, false);
      self2._lookbehindSize = 0;
    }
    pos += self2._bufPos;
    const firstNeedleChar = needle[0];
    while (pos <= end) {
      const ch = data[pos + lastNeedleCharPos];
      if (ch === lastNeedleChar && data[pos] === firstNeedleChar && memcmp(needle, 0, data, pos, lastNeedleCharPos)) {
        ++self2.matches;
        if (pos > 0)
          self2._cb(true, data, self2._bufPos, pos, true);
        else
          self2._cb(true, undefined, 0, 0, true);
        return self2._bufPos = pos + needleLen;
      }
      pos += occ[ch];
    }
    while (pos < len) {
      if (data[pos] !== firstNeedleChar || !memcmp(data, pos, needle, 0, len - pos)) {
        ++pos;
        continue;
      }
      data.copy(lookbehind, 0, pos, len);
      self2._lookbehindSize = len - pos;
      break;
    }
    if (pos > 0)
      self2._cb(false, data, self2._bufPos, pos < len ? pos : len, true);
    self2._bufPos = len;
    return len;
  };
  var matchNeedle = function(self2, data, pos, len) {
    const lb = self2._lookbehind;
    const lbSize = self2._lookbehindSize;
    const needle = self2._needle;
    for (let i = 0;i < len; ++i, ++pos) {
      const ch = pos < 0 ? lb[lbSize + pos] : data[pos];
      if (ch !== needle[i])
        return false;
    }
    return true;
  };

  class SBMH {
    constructor(needle, cb) {
      if (typeof cb !== "function")
        throw new Error("Missing match callback");
      if (typeof needle === "string")
        needle = Buffer.from(needle);
      else if (!Buffer.isBuffer(needle))
        throw new Error(`Expected Buffer for needle, got ${typeof needle}`);
      const needleLen = needle.length;
      this.maxMatches = Infinity;
      this.matches = 0;
      this._cb = cb;
      this._lookbehindSize = 0;
      this._needle = needle;
      this._bufPos = 0;
      this._lookbehind = Buffer.allocUnsafe(needleLen);
      this._occ = [
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen
      ];
      if (needleLen > 1) {
        for (let i = 0;i < needleLen - 1; ++i)
          this._occ[needle[i]] = needleLen - 1 - i;
      }
    }
    reset() {
      this.matches = 0;
      this._lookbehindSize = 0;
      this._bufPos = 0;
    }
    push(chunk, pos) {
      let result;
      if (!Buffer.isBuffer(chunk))
        chunk = Buffer.from(chunk, "latin1");
      const chunkLen = chunk.length;
      this._bufPos = pos || 0;
      while (result !== chunkLen && this.matches < this.maxMatches)
        result = feed(this, chunk);
      return result;
    }
    destroy() {
      const lbSize = this._lookbehindSize;
      if (lbSize)
        this._cb(false, this._lookbehind, 0, lbSize, false);
      this.reset();
    }
  }
  module.exports = SBMH;
});

// node_modules/busboy/lib/types/multipart.js
var require_multipart = __commonJS((exports, module) => {
  var noop2 = function() {
  };
  var callAndUnsetCb = function(self2, err) {
    const cb = self2._writecb;
    self2._writecb = null;
    if (err)
      self2.destroy(err);
    else if (cb)
      cb();
  };
  var nullDecoder = function(val, hint) {
    return val;
  };
  var finalcb = function(self2, cb, err) {
    if (err)
      return cb(err);
    err = checkEndState(self2);
    cb(err);
  };
  var checkEndState = function(self2) {
    if (self2._hparser)
      return new Error("Malformed part header");
    const fileStream = self2._fileStream;
    if (fileStream) {
      self2._fileStream = null;
      fileStream.destroy(new Error("Unexpected end of file"));
    }
    if (!self2._complete)
      return new Error("Unexpected end of form");
  };
  var { Readable, Writable } = import.meta.require("stream");
  var StreamSearch = require_sbmh();
  var {
    basename: basename2,
    convertToUTF8,
    getDecoder,
    parseContentType,
    parseDisposition
  } = require_utils();
  var BUF_CRLF = Buffer.from("\r\n");
  var BUF_CR = Buffer.from("\r");
  var BUF_DASH = Buffer.from("-");
  var MAX_HEADER_PAIRS = 2000;
  var MAX_HEADER_SIZE = 16 * 1024;
  var HPARSER_NAME = 0;
  var HPARSER_PRE_OWS = 1;
  var HPARSER_VALUE = 2;

  class HeaderParser {
    constructor(cb) {
      this.header = Object.create(null);
      this.pairCount = 0;
      this.byteCount = 0;
      this.state = HPARSER_NAME;
      this.name = "";
      this.value = "";
      this.crlf = 0;
      this.cb = cb;
    }
    reset() {
      this.header = Object.create(null);
      this.pairCount = 0;
      this.byteCount = 0;
      this.state = HPARSER_NAME;
      this.name = "";
      this.value = "";
      this.crlf = 0;
    }
    push(chunk, pos, end) {
      let start = pos;
      while (pos < end) {
        switch (this.state) {
          case HPARSER_NAME: {
            let done = false;
            for (;pos < end; ++pos) {
              if (this.byteCount === MAX_HEADER_SIZE)
                return -1;
              ++this.byteCount;
              const code = chunk[pos];
              if (TOKEN[code] !== 1) {
                if (code !== 58)
                  return -1;
                this.name += chunk.latin1Slice(start, pos);
                if (this.name.length === 0)
                  return -1;
                ++pos;
                done = true;
                this.state = HPARSER_PRE_OWS;
                break;
              }
            }
            if (!done) {
              this.name += chunk.latin1Slice(start, pos);
              break;
            }
          }
          case HPARSER_PRE_OWS: {
            let done = false;
            for (;pos < end; ++pos) {
              if (this.byteCount === MAX_HEADER_SIZE)
                return -1;
              ++this.byteCount;
              const code = chunk[pos];
              if (code !== 32 && code !== 9) {
                start = pos;
                done = true;
                this.state = HPARSER_VALUE;
                break;
              }
            }
            if (!done)
              break;
          }
          case HPARSER_VALUE:
            switch (this.crlf) {
              case 0:
                for (;pos < end; ++pos) {
                  if (this.byteCount === MAX_HEADER_SIZE)
                    return -1;
                  ++this.byteCount;
                  const code = chunk[pos];
                  if (FIELD_VCHAR[code] !== 1) {
                    if (code !== 13)
                      return -1;
                    ++this.crlf;
                    break;
                  }
                }
                this.value += chunk.latin1Slice(start, pos++);
                break;
              case 1:
                if (this.byteCount === MAX_HEADER_SIZE)
                  return -1;
                ++this.byteCount;
                if (chunk[pos++] !== 10)
                  return -1;
                ++this.crlf;
                break;
              case 2: {
                if (this.byteCount === MAX_HEADER_SIZE)
                  return -1;
                ++this.byteCount;
                const code = chunk[pos];
                if (code === 32 || code === 9) {
                  start = pos;
                  this.crlf = 0;
                } else {
                  if (++this.pairCount < MAX_HEADER_PAIRS) {
                    this.name = this.name.toLowerCase();
                    if (this.header[this.name] === undefined)
                      this.header[this.name] = [this.value];
                    else
                      this.header[this.name].push(this.value);
                  }
                  if (code === 13) {
                    ++this.crlf;
                    ++pos;
                  } else {
                    start = pos;
                    this.crlf = 0;
                    this.state = HPARSER_NAME;
                    this.name = "";
                    this.value = "";
                  }
                }
                break;
              }
              case 3: {
                if (this.byteCount === MAX_HEADER_SIZE)
                  return -1;
                ++this.byteCount;
                if (chunk[pos++] !== 10)
                  return -1;
                const header = this.header;
                this.reset();
                this.cb(header);
                return pos;
              }
            }
            break;
        }
      }
      return pos;
    }
  }

  class FileStream extends Readable {
    constructor(opts, owner) {
      super(opts);
      this.truncated = false;
      this._readcb = null;
      this.once("end", () => {
        this._read();
        if (--owner._fileEndsLeft === 0 && owner._finalcb) {
          const cb = owner._finalcb;
          owner._finalcb = null;
          process.nextTick(cb);
        }
      });
    }
    _read(n) {
      const cb = this._readcb;
      if (cb) {
        this._readcb = null;
        cb();
      }
    }
  }
  var ignoreData = {
    push: (chunk, pos) => {
    },
    destroy: () => {
    }
  };

  class Multipart extends Writable {
    constructor(cfg) {
      const streamOpts = {
        autoDestroy: true,
        emitClose: true,
        highWaterMark: typeof cfg.highWaterMark === "number" ? cfg.highWaterMark : undefined
      };
      super(streamOpts);
      if (!cfg.conType.params || typeof cfg.conType.params.boundary !== "string")
        throw new Error("Multipart: Boundary not found");
      const boundary = cfg.conType.params.boundary;
      const paramDecoder = typeof cfg.defParamCharset === "string" && cfg.defParamCharset ? getDecoder(cfg.defParamCharset) : nullDecoder;
      const defCharset = cfg.defCharset || "utf8";
      const preservePath = cfg.preservePath;
      const fileOpts = {
        autoDestroy: true,
        emitClose: true,
        highWaterMark: typeof cfg.fileHwm === "number" ? cfg.fileHwm : undefined
      };
      const limits = cfg.limits;
      const fieldSizeLimit = limits && typeof limits.fieldSize === "number" ? limits.fieldSize : 1 * 1024 * 1024;
      const fileSizeLimit = limits && typeof limits.fileSize === "number" ? limits.fileSize : Infinity;
      const filesLimit = limits && typeof limits.files === "number" ? limits.files : Infinity;
      const fieldsLimit = limits && typeof limits.fields === "number" ? limits.fields : Infinity;
      const partsLimit = limits && typeof limits.parts === "number" ? limits.parts : Infinity;
      let parts = -1;
      let fields = 0;
      let files = 0;
      let skipPart = false;
      this._fileEndsLeft = 0;
      this._fileStream = undefined;
      this._complete = false;
      let fileSize = 0;
      let field;
      let fieldSize = 0;
      let partCharset;
      let partEncoding;
      let partType;
      let partName;
      let partTruncated = false;
      let hitFilesLimit = false;
      let hitFieldsLimit = false;
      this._hparser = null;
      const hparser = new HeaderParser((header) => {
        this._hparser = null;
        skipPart = false;
        partType = "text/plain";
        partCharset = defCharset;
        partEncoding = "7bit";
        partName = undefined;
        partTruncated = false;
        let filename;
        if (!header["content-disposition"]) {
          skipPart = true;
          return;
        }
        const disp = parseDisposition(header["content-disposition"][0], paramDecoder);
        if (!disp || disp.type !== "form-data") {
          skipPart = true;
          return;
        }
        if (disp.params) {
          if (disp.params.name)
            partName = disp.params.name;
          if (disp.params["filename*"])
            filename = disp.params["filename*"];
          else if (disp.params.filename)
            filename = disp.params.filename;
          if (filename !== undefined && !preservePath)
            filename = basename2(filename);
        }
        if (header["content-type"]) {
          const conType = parseContentType(header["content-type"][0]);
          if (conType) {
            partType = `${conType.type}/${conType.subtype}`;
            if (conType.params && typeof conType.params.charset === "string")
              partCharset = conType.params.charset.toLowerCase();
          }
        }
        if (header["content-transfer-encoding"])
          partEncoding = header["content-transfer-encoding"][0].toLowerCase();
        if (partType === "application/octet-stream" || filename !== undefined) {
          if (files === filesLimit) {
            if (!hitFilesLimit) {
              hitFilesLimit = true;
              this.emit("filesLimit");
            }
            skipPart = true;
            return;
          }
          ++files;
          if (this.listenerCount("file") === 0) {
            skipPart = true;
            return;
          }
          fileSize = 0;
          this._fileStream = new FileStream(fileOpts, this);
          ++this._fileEndsLeft;
          this.emit("file", partName, this._fileStream, {
            filename,
            encoding: partEncoding,
            mimeType: partType
          });
        } else {
          if (fields === fieldsLimit) {
            if (!hitFieldsLimit) {
              hitFieldsLimit = true;
              this.emit("fieldsLimit");
            }
            skipPart = true;
            return;
          }
          ++fields;
          if (this.listenerCount("field") === 0) {
            skipPart = true;
            return;
          }
          field = [];
          fieldSize = 0;
        }
      });
      let matchPostBoundary = 0;
      const ssCb = (isMatch, data, start, end, isDataSafe) => {
        retrydata:
          while (data) {
            if (this._hparser !== null) {
              const ret = this._hparser.push(data, start, end);
              if (ret === -1) {
                this._hparser = null;
                hparser.reset();
                this.emit("error", new Error("Malformed part header"));
                break;
              }
              start = ret;
            }
            if (start === end)
              break;
            if (matchPostBoundary !== 0) {
              if (matchPostBoundary === 1) {
                switch (data[start]) {
                  case 45:
                    matchPostBoundary = 2;
                    ++start;
                    break;
                  case 13:
                    matchPostBoundary = 3;
                    ++start;
                    break;
                  default:
                    matchPostBoundary = 0;
                }
                if (start === end)
                  return;
              }
              if (matchPostBoundary === 2) {
                matchPostBoundary = 0;
                if (data[start] === 45) {
                  this._complete = true;
                  this._bparser = ignoreData;
                  return;
                }
                const writecb = this._writecb;
                this._writecb = noop2;
                ssCb(false, BUF_DASH, 0, 1, false);
                this._writecb = writecb;
              } else if (matchPostBoundary === 3) {
                matchPostBoundary = 0;
                if (data[start] === 10) {
                  ++start;
                  if (parts >= partsLimit)
                    break;
                  this._hparser = hparser;
                  if (start === end)
                    break;
                  continue retrydata;
                } else {
                  const writecb = this._writecb;
                  this._writecb = noop2;
                  ssCb(false, BUF_CR, 0, 1, false);
                  this._writecb = writecb;
                }
              }
            }
            if (!skipPart) {
              if (this._fileStream) {
                let chunk;
                const actualLen = Math.min(end - start, fileSizeLimit - fileSize);
                if (!isDataSafe) {
                  chunk = Buffer.allocUnsafe(actualLen);
                  data.copy(chunk, 0, start, start + actualLen);
                } else {
                  chunk = data.slice(start, start + actualLen);
                }
                fileSize += chunk.length;
                if (fileSize === fileSizeLimit) {
                  if (chunk.length > 0)
                    this._fileStream.push(chunk);
                  this._fileStream.emit("limit");
                  this._fileStream.truncated = true;
                  skipPart = true;
                } else if (!this._fileStream.push(chunk)) {
                  if (this._writecb)
                    this._fileStream._readcb = this._writecb;
                  this._writecb = null;
                }
              } else if (field !== undefined) {
                let chunk;
                const actualLen = Math.min(end - start, fieldSizeLimit - fieldSize);
                if (!isDataSafe) {
                  chunk = Buffer.allocUnsafe(actualLen);
                  data.copy(chunk, 0, start, start + actualLen);
                } else {
                  chunk = data.slice(start, start + actualLen);
                }
                fieldSize += actualLen;
                field.push(chunk);
                if (fieldSize === fieldSizeLimit) {
                  skipPart = true;
                  partTruncated = true;
                }
              }
            }
            break;
          }
        if (isMatch) {
          matchPostBoundary = 1;
          if (this._fileStream) {
            this._fileStream.push(null);
            this._fileStream = null;
          } else if (field !== undefined) {
            let data2;
            switch (field.length) {
              case 0:
                data2 = "";
                break;
              case 1:
                data2 = convertToUTF8(field[0], partCharset, 0);
                break;
              default:
                data2 = convertToUTF8(Buffer.concat(field, fieldSize), partCharset, 0);
            }
            field = undefined;
            fieldSize = 0;
            this.emit("field", partName, data2, {
              nameTruncated: false,
              valueTruncated: partTruncated,
              encoding: partEncoding,
              mimeType: partType
            });
          }
          if (++parts === partsLimit)
            this.emit("partsLimit");
        }
      };
      this._bparser = new StreamSearch(`\r\n--${boundary}`, ssCb);
      this._writecb = null;
      this._finalcb = null;
      this.write(BUF_CRLF);
    }
    static detect(conType) {
      return conType.type === "multipart" && conType.subtype === "form-data";
    }
    _write(chunk, enc, cb) {
      this._writecb = cb;
      this._bparser.push(chunk, 0);
      if (this._writecb)
        callAndUnsetCb(this);
    }
    _destroy(err, cb) {
      this._hparser = null;
      this._bparser = ignoreData;
      if (!err)
        err = checkEndState(this);
      const fileStream = this._fileStream;
      if (fileStream) {
        this._fileStream = null;
        fileStream.destroy(err);
      }
      cb(err);
    }
    _final(cb) {
      this._bparser.destroy();
      if (!this._complete)
        return cb(new Error("Unexpected end of form"));
      if (this._fileEndsLeft)
        this._finalcb = finalcb.bind(null, this, cb);
      else
        finalcb(this, cb);
    }
  }
  var TOKEN = [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    0,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    1,
    1,
    0,
    1,
    1,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    1,
    0,
    1,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0
  ];
  var FIELD_VCHAR = [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1
  ];
  module.exports = Multipart;
});

// node_modules/busboy/lib/types/urlencoded.js
var require_urlencoded = __commonJS((exports, module) => {
  var readPctEnc = function(self2, chunk, pos, len) {
    if (pos >= len)
      return len;
    if (self2._byte === -1) {
      const hexUpper = HEX_VALUES[chunk[pos++]];
      if (hexUpper === -1)
        return -1;
      if (hexUpper >= 8)
        self2._encode = 2;
      if (pos < len) {
        const hexLower = HEX_VALUES[chunk[pos++]];
        if (hexLower === -1)
          return -1;
        if (self2._inKey)
          self2._key += String.fromCharCode((hexUpper << 4) + hexLower);
        else
          self2._val += String.fromCharCode((hexUpper << 4) + hexLower);
        self2._byte = -2;
        self2._lastPos = pos;
      } else {
        self2._byte = hexUpper;
      }
    } else {
      const hexLower = HEX_VALUES[chunk[pos++]];
      if (hexLower === -1)
        return -1;
      if (self2._inKey)
        self2._key += String.fromCharCode((self2._byte << 4) + hexLower);
      else
        self2._val += String.fromCharCode((self2._byte << 4) + hexLower);
      self2._byte = -2;
      self2._lastPos = pos;
    }
    return pos;
  };
  var skipKeyBytes = function(self2, chunk, pos, len) {
    if (self2._bytesKey > self2.fieldNameSizeLimit) {
      if (!self2._keyTrunc) {
        if (self2._lastPos < pos)
          self2._key += chunk.latin1Slice(self2._lastPos, pos - 1);
      }
      self2._keyTrunc = true;
      for (;pos < len; ++pos) {
        const code = chunk[pos];
        if (code === 61 || code === 38)
          break;
        ++self2._bytesKey;
      }
      self2._lastPos = pos;
    }
    return pos;
  };
  var skipValBytes = function(self2, chunk, pos, len) {
    if (self2._bytesVal > self2.fieldSizeLimit) {
      if (!self2._valTrunc) {
        if (self2._lastPos < pos)
          self2._val += chunk.latin1Slice(self2._lastPos, pos - 1);
      }
      self2._valTrunc = true;
      for (;pos < len; ++pos) {
        if (chunk[pos] === 38)
          break;
        ++self2._bytesVal;
      }
      self2._lastPos = pos;
    }
    return pos;
  };
  var { Writable } = import.meta.require("stream");
  var { getDecoder } = require_utils();

  class URLEncoded extends Writable {
    constructor(cfg) {
      const streamOpts = {
        autoDestroy: true,
        emitClose: true,
        highWaterMark: typeof cfg.highWaterMark === "number" ? cfg.highWaterMark : undefined
      };
      super(streamOpts);
      let charset = cfg.defCharset || "utf8";
      if (cfg.conType.params && typeof cfg.conType.params.charset === "string")
        charset = cfg.conType.params.charset;
      this.charset = charset;
      const limits = cfg.limits;
      this.fieldSizeLimit = limits && typeof limits.fieldSize === "number" ? limits.fieldSize : 1 * 1024 * 1024;
      this.fieldsLimit = limits && typeof limits.fields === "number" ? limits.fields : Infinity;
      this.fieldNameSizeLimit = limits && typeof limits.fieldNameSize === "number" ? limits.fieldNameSize : 100;
      this._inKey = true;
      this._keyTrunc = false;
      this._valTrunc = false;
      this._bytesKey = 0;
      this._bytesVal = 0;
      this._fields = 0;
      this._key = "";
      this._val = "";
      this._byte = -2;
      this._lastPos = 0;
      this._encode = 0;
      this._decoder = getDecoder(charset);
    }
    static detect(conType) {
      return conType.type === "application" && conType.subtype === "x-www-form-urlencoded";
    }
    _write(chunk, enc, cb) {
      if (this._fields >= this.fieldsLimit)
        return cb();
      let i = 0;
      const len = chunk.length;
      this._lastPos = 0;
      if (this._byte !== -2) {
        i = readPctEnc(this, chunk, i, len);
        if (i === -1)
          return cb(new Error("Malformed urlencoded form"));
        if (i >= len)
          return cb();
        if (this._inKey)
          ++this._bytesKey;
        else
          ++this._bytesVal;
      }
      main:
        while (i < len) {
          if (this._inKey) {
            i = skipKeyBytes(this, chunk, i, len);
            while (i < len) {
              switch (chunk[i]) {
                case 61:
                  if (this._lastPos < i)
                    this._key += chunk.latin1Slice(this._lastPos, i);
                  this._lastPos = ++i;
                  this._key = this._decoder(this._key, this._encode);
                  this._encode = 0;
                  this._inKey = false;
                  continue main;
                case 38:
                  if (this._lastPos < i)
                    this._key += chunk.latin1Slice(this._lastPos, i);
                  this._lastPos = ++i;
                  this._key = this._decoder(this._key, this._encode);
                  this._encode = 0;
                  if (this._bytesKey > 0) {
                    this.emit("field", this._key, "", {
                      nameTruncated: this._keyTrunc,
                      valueTruncated: false,
                      encoding: this.charset,
                      mimeType: "text/plain"
                    });
                  }
                  this._key = "";
                  this._val = "";
                  this._keyTrunc = false;
                  this._valTrunc = false;
                  this._bytesKey = 0;
                  this._bytesVal = 0;
                  if (++this._fields >= this.fieldsLimit) {
                    this.emit("fieldsLimit");
                    return cb();
                  }
                  continue;
                case 43:
                  if (this._lastPos < i)
                    this._key += chunk.latin1Slice(this._lastPos, i);
                  this._key += " ";
                  this._lastPos = i + 1;
                  break;
                case 37:
                  if (this._encode === 0)
                    this._encode = 1;
                  if (this._lastPos < i)
                    this._key += chunk.latin1Slice(this._lastPos, i);
                  this._lastPos = i + 1;
                  this._byte = -1;
                  i = readPctEnc(this, chunk, i + 1, len);
                  if (i === -1)
                    return cb(new Error("Malformed urlencoded form"));
                  if (i >= len)
                    return cb();
                  ++this._bytesKey;
                  i = skipKeyBytes(this, chunk, i, len);
                  continue;
              }
              ++i;
              ++this._bytesKey;
              i = skipKeyBytes(this, chunk, i, len);
            }
            if (this._lastPos < i)
              this._key += chunk.latin1Slice(this._lastPos, i);
          } else {
            i = skipValBytes(this, chunk, i, len);
            while (i < len) {
              switch (chunk[i]) {
                case 38:
                  if (this._lastPos < i)
                    this._val += chunk.latin1Slice(this._lastPos, i);
                  this._lastPos = ++i;
                  this._inKey = true;
                  this._val = this._decoder(this._val, this._encode);
                  this._encode = 0;
                  if (this._bytesKey > 0 || this._bytesVal > 0) {
                    this.emit("field", this._key, this._val, {
                      nameTruncated: this._keyTrunc,
                      valueTruncated: this._valTrunc,
                      encoding: this.charset,
                      mimeType: "text/plain"
                    });
                  }
                  this._key = "";
                  this._val = "";
                  this._keyTrunc = false;
                  this._valTrunc = false;
                  this._bytesKey = 0;
                  this._bytesVal = 0;
                  if (++this._fields >= this.fieldsLimit) {
                    this.emit("fieldsLimit");
                    return cb();
                  }
                  continue main;
                case 43:
                  if (this._lastPos < i)
                    this._val += chunk.latin1Slice(this._lastPos, i);
                  this._val += " ";
                  this._lastPos = i + 1;
                  break;
                case 37:
                  if (this._encode === 0)
                    this._encode = 1;
                  if (this._lastPos < i)
                    this._val += chunk.latin1Slice(this._lastPos, i);
                  this._lastPos = i + 1;
                  this._byte = -1;
                  i = readPctEnc(this, chunk, i + 1, len);
                  if (i === -1)
                    return cb(new Error("Malformed urlencoded form"));
                  if (i >= len)
                    return cb();
                  ++this._bytesVal;
                  i = skipValBytes(this, chunk, i, len);
                  continue;
              }
              ++i;
              ++this._bytesVal;
              i = skipValBytes(this, chunk, i, len);
            }
            if (this._lastPos < i)
              this._val += chunk.latin1Slice(this._lastPos, i);
          }
        }
      cb();
    }
    _final(cb) {
      if (this._byte !== -2)
        return cb(new Error("Malformed urlencoded form"));
      if (!this._inKey || this._bytesKey > 0 || this._bytesVal > 0) {
        if (this._inKey)
          this._key = this._decoder(this._key, this._encode);
        else
          this._val = this._decoder(this._val, this._encode);
        this.emit("field", this._key, this._val, {
          nameTruncated: this._keyTrunc,
          valueTruncated: this._valTrunc,
          encoding: this.charset,
          mimeType: "text/plain"
        });
      }
      cb();
    }
  }
  var HEX_VALUES = [
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    0,
    1,
    2,
    3,
    4,
    5,
    6,
    7,
    8,
    9,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    10,
    11,
    12,
    13,
    14,
    15,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    10,
    11,
    12,
    13,
    14,
    15,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1
  ];
  module.exports = URLEncoded;
});

// node_modules/busboy/lib/index.js
var require_lib = __commonJS((exports, module) => {
  var getInstance = function(cfg) {
    const headers = cfg.headers;
    const conType = parseContentType(headers["content-type"]);
    if (!conType)
      throw new Error("Malformed content type");
    for (const type of TYPES) {
      const matched = type.detect(conType);
      if (!matched)
        continue;
      const instanceCfg = {
        limits: cfg.limits,
        headers,
        conType,
        highWaterMark: undefined,
        fileHwm: undefined,
        defCharset: undefined,
        defParamCharset: undefined,
        preservePath: false
      };
      if (cfg.highWaterMark)
        instanceCfg.highWaterMark = cfg.highWaterMark;
      if (cfg.fileHwm)
        instanceCfg.fileHwm = cfg.fileHwm;
      instanceCfg.defCharset = cfg.defCharset;
      instanceCfg.defParamCharset = cfg.defParamCharset;
      instanceCfg.preservePath = cfg.preservePath;
      return new type(instanceCfg);
    }
    throw new Error(`Unsupported content type: ${headers["content-type"]}`);
  };
  var { parseContentType } = require_utils();
  var TYPES = [
    require_multipart(),
    require_urlencoded()
  ].filter(function(typemod) {
    return typeof typemod.detect === "function";
  });
  module.exports = (cfg) => {
    if (typeof cfg !== "object" || cfg === null)
      cfg = {};
    if (typeof cfg.headers !== "object" || cfg.headers === null || typeof cfg.headers["content-type"] !== "string") {
      throw new Error("Missing Content-Type");
    }
    return getInstance(cfg);
  };
});

// node_modules/@whatwg-node/node-fetch/cjs/ReadableStream.js
var require_ReadableStream = __commonJS((exports) => {
  var createController = function(desiredSize, readable) {
    let chunks = [];
    let _closed = false;
    let flushed = false;
    return {
      desiredSize,
      enqueue(chunk) {
        const buf = typeof chunk === "string" ? Buffer.from(chunk) : chunk;
        if (!flushed) {
          chunks.push(buf);
        } else {
          readable.push(buf);
        }
      },
      close() {
        if (chunks.length > 0) {
          this._flush();
        }
        readable.push(null);
        _closed = true;
      },
      error(error2) {
        if (chunks.length > 0) {
          this._flush();
        }
        readable.destroy(error2);
      },
      get _closed() {
        return _closed;
      },
      _flush() {
        flushed = true;
        if (chunks.length > 0) {
          const concatenated = chunks.length > 1 ? Buffer.concat(chunks) : chunks[0];
          readable.push(concatenated);
          chunks = [];
        }
      }
    };
  };
  var isNodeReadable = function(obj) {
    return obj?.read != null;
  };
  var isReadableStream = function(obj) {
    return obj?.getReader != null;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.PonyfillReadableStream = undefined;
  var stream_1 = import.meta.require("stream");

  class PonyfillReadableStream {
    constructor(underlyingSource) {
      this.locked = false;
      if (underlyingSource instanceof PonyfillReadableStream) {
        this.readable = underlyingSource.readable;
      } else if (isNodeReadable(underlyingSource)) {
        this.readable = underlyingSource;
      } else if (isReadableStream(underlyingSource)) {
        let reader;
        let started = false;
        this.readable = new stream_1.Readable({
          read() {
            if (!started) {
              started = true;
              reader = underlyingSource.getReader();
            }
            reader.read().then(({ value, done }) => {
              if (done) {
                this.push(null);
              } else {
                this.push(value);
              }
            }).catch((err) => {
              this.destroy(err);
            });
          },
          destroy(err, callback) {
            reader.cancel(err).then(() => callback(err), callback);
          }
        });
      } else {
        let started = false;
        let ongoing = false;
        this.readable = new stream_1.Readable({
          read(desiredSize) {
            if (ongoing) {
              return;
            }
            ongoing = true;
            return Promise.resolve().then(async () => {
              if (!started) {
                const controller2 = createController(desiredSize, this);
                started = true;
                await underlyingSource?.start?.(controller2);
                controller2._flush();
                if (controller2._closed) {
                  return;
                }
              }
              const controller = createController(desiredSize, this);
              await underlyingSource?.pull?.(controller);
              controller._flush();
              ongoing = false;
            });
          },
          async destroy(err, callback) {
            try {
              await underlyingSource?.cancel?.(err);
              callback(null);
            } catch (err2) {
              callback(err2);
            }
          }
        });
      }
    }
    cancel(reason) {
      this.readable.destroy(reason);
      return Promise.resolve();
    }
    getReader(_options) {
      const iterator = this.readable[Symbol.asyncIterator]();
      this.locked = true;
      return {
        read() {
          return iterator.next();
        },
        releaseLock: () => {
          iterator.return?.();
          this.locked = false;
        },
        cancel: async (reason) => {
          await iterator.return?.(reason);
          this.locked = false;
        },
        closed: new Promise((resolve, reject) => {
          this.readable.once("end", resolve);
          this.readable.once("error", reject);
        })
      };
    }
    [Symbol.asyncIterator]() {
      return this.readable[Symbol.asyncIterator]();
    }
    tee() {
      throw new Error("Not implemented");
    }
    async pipeTo(destination) {
      const writer = destination.getWriter();
      await writer.ready;
      for await (const chunk of this.readable) {
        await writer.write(chunk);
      }
      await writer.ready;
      return writer.close();
    }
    pipeThrough({ writable, readable }) {
      this.pipeTo(writable);
      return readable;
    }
    static [Symbol.hasInstance](instance) {
      return isReadableStream(instance);
    }
  }
  exports.PonyfillReadableStream = PonyfillReadableStream;
});

// node_modules/@whatwg-node/node-fetch/cjs/utils.js
var require_utils2 = __commonJS((exports) => {
  var isHeadersInstance = function(obj) {
    return obj?.forEach != null;
  };
  var getHeadersObj = function(headers) {
    if (headers == null || !isHeadersInstance(headers)) {
      return headers;
    }
    const obj = {};
    headers.forEach((value, key) => {
      obj[key] = value;
    });
    return obj;
  };
  var defaultHeadersSerializer = function(headers, onContentLength) {
    const headerArray = [];
    headers.forEach((value, key) => {
      if (onContentLength && key === "content-length") {
        onContentLength(value);
      }
      headerArray.push(`${key}: ${value}`);
    });
    return headerArray;
  };
  var isPromise4 = function(val) {
    return val?.then != null;
  };
  var fakePromise = function(value) {
    if (isPromise4(value)) {
      return value;
    }
    return {
      then(resolve) {
        if (resolve) {
          const callbackResult = resolve(value);
          if (isPromise4(callbackResult)) {
            return callbackResult;
          }
          return fakePromise(callbackResult);
        }
        return this;
      },
      catch() {
        return this;
      },
      finally(cb) {
        if (cb) {
          const callbackResult = cb();
          if (isPromise4(callbackResult)) {
            return callbackResult.then(() => value);
          }
          return fakePromise(value);
        }
        return this;
      },
      [Symbol.toStringTag]: "Promise"
    };
  };
  var isArrayBufferView = function(obj) {
    return obj != null && obj.buffer != null && obj.byteLength != null && obj.byteOffset != null;
  };
  var isNodeReadable = function(obj) {
    return obj != null && obj.pipe != null;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.isNodeReadable = exports.isArrayBufferView = exports.fakePromise = exports.defaultHeadersSerializer = exports.getHeadersObj = undefined;
  exports.getHeadersObj = getHeadersObj;
  exports.defaultHeadersSerializer = defaultHeadersSerializer;
  exports.fakePromise = fakePromise;
  exports.isArrayBufferView = isArrayBufferView;
  exports.isNodeReadable = isNodeReadable;
});

// node_modules/@whatwg-node/node-fetch/cjs/Blob.js
var require_Blob = __commonJS((exports) => {
  var getBlobPartAsBuffer = function(blobPart) {
    if (typeof blobPart === "string") {
      return Buffer.from(blobPart);
    } else if (Buffer.isBuffer(blobPart)) {
      return blobPart;
    } else if ((0, utils_js_1.isArrayBufferView)(blobPart)) {
      return Buffer.from(blobPart.buffer, blobPart.byteOffset, blobPart.byteLength);
    } else {
      return Buffer.from(blobPart);
    }
  };
  var isBlob = function(obj) {
    return obj != null && obj.arrayBuffer != null;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.PonyfillBlob = undefined;
  var ReadableStream_js_1 = require_ReadableStream();
  var utils_js_1 = require_utils2();

  class PonyfillBlob {
    constructor(blobParts, options) {
      this.blobParts = blobParts;
      this._size = null;
      this.type = options?.type || "application/octet-stream";
      this.encoding = options?.encoding || "utf8";
      this._size = options?.size || null;
      if (blobParts.length === 1 && isBlob(blobParts[0])) {
        return blobParts[0];
      }
    }
    arrayBuffer() {
      if (this.blobParts.length === 1) {
        const blobPart = this.blobParts[0];
        if (isBlob(blobPart)) {
          return blobPart.arrayBuffer();
        }
        return (0, utils_js_1.fakePromise)(getBlobPartAsBuffer(blobPart));
      }
      const jobs = [];
      const bufferChunks = this.blobParts.map((blobPart, i) => {
        if (isBlob(blobPart)) {
          jobs.push(blobPart.arrayBuffer().then((arrayBuf) => {
            bufferChunks[i] = Buffer.from(arrayBuf, undefined, blobPart.size);
          }));
          return;
        } else {
          return getBlobPartAsBuffer(blobPart);
        }
      });
      if (jobs.length > 0) {
        return Promise.all(jobs).then(() => Buffer.concat(bufferChunks, this._size || undefined));
      }
      return (0, utils_js_1.fakePromise)(Buffer.concat(bufferChunks, this._size || undefined));
    }
    text() {
      if (this.blobParts.length === 1) {
        const blobPart = this.blobParts[0];
        if (typeof blobPart === "string") {
          return (0, utils_js_1.fakePromise)(blobPart);
        }
        if (isBlob(blobPart)) {
          return blobPart.text();
        }
        const buf = getBlobPartAsBuffer(blobPart);
        return (0, utils_js_1.fakePromise)(buf.toString(this.encoding));
      }
      return this.arrayBuffer().then((buf) => buf.toString(this.encoding));
    }
    get size() {
      if (this._size == null) {
        this._size = 0;
        for (const blobPart of this.blobParts) {
          if (typeof blobPart === "string") {
            this._size += Buffer.byteLength(blobPart);
          } else if (isBlob(blobPart)) {
            this._size += blobPart.size;
          } else if ((0, utils_js_1.isArrayBufferView)(blobPart)) {
            this._size += blobPart.byteLength;
          }
        }
      }
      return this._size;
    }
    stream() {
      if (this.blobParts.length === 1) {
        const blobPart = this.blobParts[0];
        if (isBlob(blobPart)) {
          return blobPart.stream();
        }
        const buf = getBlobPartAsBuffer(blobPart);
        return new ReadableStream_js_1.PonyfillReadableStream({
          start: (controller) => {
            controller.enqueue(buf);
            controller.close();
          }
        });
      }
      let blobPartIterator;
      return new ReadableStream_js_1.PonyfillReadableStream({
        start: (controller) => {
          if (this.blobParts.length === 0) {
            controller.close();
            return;
          }
          blobPartIterator = this.blobParts[Symbol.iterator]();
        },
        pull: (controller) => {
          const { value: blobPart, done } = blobPartIterator.next();
          if (done) {
            controller.close();
            return;
          }
          if (blobPart) {
            if (isBlob(blobPart)) {
              return blobPart.arrayBuffer().then((arrayBuffer) => {
                const buf2 = Buffer.from(arrayBuffer, undefined, blobPart.size);
                controller.enqueue(buf2);
              });
            }
            const buf = getBlobPartAsBuffer(blobPart);
            controller.enqueue(buf);
          }
        }
      });
    }
    slice() {
      throw new Error("Not implemented");
    }
  }
  exports.PonyfillBlob = PonyfillBlob;
});

// node_modules/@whatwg-node/node-fetch/cjs/File.js
var require_File = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.PonyfillFile = undefined;
  var Blob_js_1 = require_Blob();

  class PonyfillFile extends Blob_js_1.PonyfillBlob {
    constructor(fileBits, name4, options) {
      super(fileBits, options);
      this.name = name4;
      this.webkitRelativePath = "";
      this.lastModified = options?.lastModified || Date.now();
    }
  }
  exports.PonyfillFile = PonyfillFile;
});

// node_modules/@whatwg-node/node-fetch/cjs/FormData.js
var require_FormData = __commonJS((exports) => {
  var getStreamFromFormData = function(formData, boundary = "---") {
    const entries = [];
    let sentInitialHeader = false;
    return new ReadableStream_js_1.PonyfillReadableStream({
      start: (controller) => {
        formData.forEach((value, key) => {
          if (!sentInitialHeader) {
            controller.enqueue(Buffer.from(`--${boundary}\r\n`));
            sentInitialHeader = true;
          }
          entries.push([key, value]);
        });
        if (!sentInitialHeader) {
          controller.enqueue(Buffer.from(`--${boundary}--\r\n`));
          controller.close();
        }
      },
      pull: async (controller) => {
        const entry = entries.shift();
        if (entry) {
          const [key, value] = entry;
          if (typeof value === "string") {
            controller.enqueue(Buffer.from(`Content-Disposition: form-data; name="${key}"\r\n\r\n`));
            controller.enqueue(Buffer.from(value));
          } else {
            let filenamePart = "";
            if (value.name) {
              filenamePart = `; filename="${value.name}"`;
            }
            controller.enqueue(Buffer.from(`Content-Disposition: form-data; name="${key}"${filenamePart}\r\n`));
            controller.enqueue(Buffer.from(`Content-Type: ${value.type || "application/octet-stream"}\r\n\r\n`));
            const entryStream = value.stream();
            for await (const chunk of entryStream) {
              controller.enqueue(chunk);
            }
          }
          if (entries.length === 0) {
            controller.enqueue(Buffer.from(`\r\n--${boundary}--\r\n`));
            controller.close();
          } else {
            controller.enqueue(Buffer.from(`\r\n--${boundary}\r\n`));
          }
        } else {
          controller.enqueue(Buffer.from(`\r\n--${boundary}--\r\n`));
          controller.close();
        }
      }
    });
  };
  var getNormalizedFile = function(name4, blob, fileName) {
    blob.name = fileName || blob.name || name4;
    return blob;
  };
  var isBlob = function(value) {
    return value?.arrayBuffer != null;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getStreamFromFormData = exports.PonyfillFormData = undefined;
  var ReadableStream_js_1 = require_ReadableStream();

  class PonyfillFormData {
    constructor() {
      this.map = new Map;
    }
    append(name4, value, fileName) {
      let values3 = this.map.get(name4);
      if (!values3) {
        values3 = [];
        this.map.set(name4, values3);
      }
      const entry = isBlob(value) ? getNormalizedFile(name4, value, fileName) : value;
      values3.push(entry);
    }
    delete(name4) {
      this.map.delete(name4);
    }
    get(name4) {
      const values3 = this.map.get(name4);
      return values3 ? values3[0] : null;
    }
    getAll(name4) {
      return this.map.get(name4) || [];
    }
    has(name4) {
      return this.map.has(name4);
    }
    set(name4, value, fileName) {
      const entry = isBlob(value) ? getNormalizedFile(name4, value, fileName) : value;
      this.map.set(name4, [entry]);
    }
    *[Symbol.iterator]() {
      for (const [key, values3] of this.map) {
        for (const value of values3) {
          yield [key, value];
        }
      }
    }
    entries() {
      return this[Symbol.iterator]();
    }
    keys() {
      return this.map.keys();
    }
    *values() {
      for (const values3 of this.map.values()) {
        for (const value of values3) {
          yield value;
        }
      }
    }
    forEach(callback) {
      for (const [key, value] of this) {
        callback(value, key, this);
      }
    }
  }
  exports.PonyfillFormData = PonyfillFormData;
  exports.getStreamFromFormData = getStreamFromFormData;
});

// node_modules/@whatwg-node/node-fetch/cjs/Body.js
var require_Body = __commonJS((exports) => {
  var processBodyInit = function(bodyInit) {
    if (bodyInit == null) {
      return {
        bodyFactory: () => null,
        contentType: null,
        contentLength: null
      };
    }
    if (typeof bodyInit === "string") {
      const buffer = Buffer.from(bodyInit);
      const contentLength = buffer.byteLength;
      return {
        bodyType: BodyInitType.String,
        contentType: "text/plain;charset=UTF-8",
        contentLength,
        buffer,
        bodyFactory() {
          const readable = stream_1.Readable.from(buffer);
          return new ReadableStream_js_1.PonyfillReadableStream(readable);
        }
      };
    }
    if (Buffer.isBuffer(bodyInit)) {
      return {
        bodyType: BodyInitType.Buffer,
        contentType: null,
        contentLength: bodyInit.length,
        buffer: bodyInit,
        bodyFactory() {
          const readable = stream_1.Readable.from(bodyInit);
          const body = new ReadableStream_js_1.PonyfillReadableStream(readable);
          return body;
        }
      };
    }
    if ((0, utils_js_1.isArrayBufferView)(bodyInit)) {
      const buffer = Buffer.from(bodyInit.buffer, bodyInit.byteOffset, bodyInit.byteLength);
      return {
        bodyType: BodyInitType.Buffer,
        contentLength: bodyInit.byteLength,
        contentType: null,
        buffer,
        bodyFactory() {
          const readable = stream_1.Readable.from(buffer);
          const body = new ReadableStream_js_1.PonyfillReadableStream(readable);
          return body;
        }
      };
    }
    if (bodyInit instanceof ReadableStream_js_1.PonyfillReadableStream) {
      return {
        bodyType: BodyInitType.ReadableStream,
        bodyFactory: () => bodyInit,
        contentType: null,
        contentLength: null
      };
    }
    if (isBlob(bodyInit)) {
      return {
        bodyType: BodyInitType.Blob,
        contentType: bodyInit.type,
        contentLength: bodyInit.size,
        bodyFactory() {
          return bodyInit.stream();
        }
      };
    }
    if (bodyInit instanceof ArrayBuffer) {
      const contentLength = bodyInit.byteLength;
      const buffer = Buffer.from(bodyInit, undefined, bodyInit.byteLength);
      return {
        bodyType: BodyInitType.Buffer,
        contentType: null,
        contentLength,
        buffer,
        bodyFactory() {
          const readable = stream_1.Readable.from(buffer);
          const body = new ReadableStream_js_1.PonyfillReadableStream(readable);
          return body;
        }
      };
    }
    if (bodyInit instanceof stream_1.Readable) {
      return {
        bodyType: BodyInitType.Readable,
        contentType: null,
        contentLength: null,
        bodyFactory() {
          const body = new ReadableStream_js_1.PonyfillReadableStream(bodyInit);
          return body;
        }
      };
    }
    if (isURLSearchParams(bodyInit)) {
      const contentType = "application/x-www-form-urlencoded;charset=UTF-8";
      return {
        bodyType: BodyInitType.String,
        contentType,
        contentLength: null,
        bodyFactory() {
          const body = new ReadableStream_js_1.PonyfillReadableStream(stream_1.Readable.from(bodyInit.toString()));
          return body;
        }
      };
    }
    if (isFormData(bodyInit)) {
      const boundary = Math.random().toString(36).substr(2);
      const contentType = `multipart/form-data; boundary=${boundary}`;
      return {
        bodyType: BodyInitType.FormData,
        contentType,
        contentLength: null,
        bodyFactory() {
          return (0, FormData_js_1.getStreamFromFormData)(bodyInit, boundary);
        }
      };
    }
    if (bodyInit[Symbol.iterator] || bodyInit[Symbol.asyncIterator]) {
      return {
        contentType: null,
        contentLength: null,
        bodyFactory() {
          const readable = stream_1.Readable.from(bodyInit);
          return new ReadableStream_js_1.PonyfillReadableStream(readable);
        }
      };
    }
    throw new Error("Unknown body type");
  };
  var isFormData = function(value) {
    return value?.forEach != null;
  };
  var isBlob = function(value) {
    return value?.stream != null;
  };
  var isURLSearchParams = function(value) {
    return value?.sort != null;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.PonyfillBody = undefined;
  var tslib_1 = require_tslib();
  var stream_1 = import.meta.require("stream");
  var busboy_1 = tslib_1.__importDefault(require_lib());
  var Blob_js_1 = require_Blob();
  var File_js_1 = require_File();
  var FormData_js_1 = require_FormData();
  var ReadableStream_js_1 = require_ReadableStream();
  var utils_js_1 = require_utils2();
  var BodyInitType;
  (function(BodyInitType2) {
    BodyInitType2["ReadableStream"] = "ReadableStream";
    BodyInitType2["Blob"] = "Blob";
    BodyInitType2["FormData"] = "FormData";
    BodyInitType2["String"] = "String";
    BodyInitType2["Readable"] = "Readable";
    BodyInitType2["Buffer"] = "Buffer";
  })(BodyInitType || (BodyInitType = {}));

  class PonyfillBody {
    constructor(bodyInit, options = {}) {
      this.bodyInit = bodyInit;
      this.options = options;
      this.bodyUsed = false;
      this.contentType = null;
      this.contentLength = null;
      this._bodyFactory = () => null;
      this._generatedBody = null;
      const { bodyFactory, contentType, contentLength, bodyType, buffer } = processBodyInit(bodyInit);
      this._bodyFactory = bodyFactory;
      this.contentType = contentType;
      this.contentLength = contentLength;
      this.bodyType = bodyType;
      this._buffer = buffer;
    }
    generateBody() {
      if (this._generatedBody) {
        return this._generatedBody;
      }
      const body = this._bodyFactory();
      this._generatedBody = body;
      return body;
    }
    get body() {
      const _body = this.generateBody();
      if (_body != null) {
        const ponyfillReadableStream = _body;
        const readable = _body.readable;
        return new Proxy(_body.readable, {
          get(_, prop) {
            if (prop in ponyfillReadableStream) {
              const ponyfillReadableStreamProp = ponyfillReadableStream[prop];
              if (typeof ponyfillReadableStreamProp === "function") {
                return ponyfillReadableStreamProp.bind(ponyfillReadableStream);
              }
              return ponyfillReadableStreamProp;
            }
            if (prop in readable) {
              const readableProp = readable[prop];
              if (typeof readableProp === "function") {
                return readableProp.bind(readable);
              }
              return readableProp;
            }
          }
        });
      }
      return null;
    }
    _collectChunksFromReadable() {
      const _body = this.generateBody();
      if (!_body) {
        return (0, utils_js_1.fakePromise)([]);
      }
      const chunks = [];
      _body.readable.on("data", (chunk) => {
        chunks.push(chunk);
      });
      return new Promise((resolve, reject) => {
        _body.readable.once("end", () => {
          resolve(chunks);
        });
        _body.readable.once("error", (e) => {
          reject(e);
        });
      });
    }
    blob() {
      if (this.bodyType === BodyInitType.Blob) {
        return (0, utils_js_1.fakePromise)(this.bodyInit);
      }
      if (this._buffer) {
        const blob = new Blob_js_1.PonyfillBlob([this._buffer], {
          type: this.contentType || "",
          size: this.contentLength
        });
        return (0, utils_js_1.fakePromise)(blob);
      }
      return this._collectChunksFromReadable().then((chunks) => {
        return new Blob_js_1.PonyfillBlob(chunks, {
          type: this.contentType || "",
          size: this.contentLength
        });
      });
    }
    formData(opts) {
      if (this.bodyType === BodyInitType.FormData) {
        return (0, utils_js_1.fakePromise)(this.bodyInit);
      }
      const formData = new FormData_js_1.PonyfillFormData;
      const _body = this.generateBody();
      if (_body == null) {
        return (0, utils_js_1.fakePromise)(formData);
      }
      const formDataLimits = {
        ...this.options.formDataLimits,
        ...opts?.formDataLimits
      };
      return new Promise((resolve, reject) => {
        const bb = (0, busboy_1.default)({
          headers: {
            "content-type": this.contentType || ""
          },
          limits: formDataLimits,
          defParamCharset: "utf-8"
        });
        bb.on("field", (name4, value, { nameTruncated, valueTruncated }) => {
          if (nameTruncated) {
            reject(new Error(`Field name size exceeded: ${formDataLimits?.fieldNameSize} bytes`));
          }
          if (valueTruncated) {
            reject(new Error(`Field value size exceeded: ${formDataLimits?.fieldSize} bytes`));
          }
          formData.set(name4, value);
        });
        bb.on("fieldsLimit", () => {
          reject(new Error(`Fields limit exceeded: ${formDataLimits?.fields}`));
        });
        bb.on("file", (name4, fileStream, { filename, mimeType }) => {
          const chunks = [];
          fileStream.on("limit", () => {
            reject(new Error(`File size limit exceeded: ${formDataLimits?.fileSize} bytes`));
          });
          fileStream.on("data", (chunk) => {
            chunks.push(chunk);
          });
          fileStream.on("close", () => {
            if (fileStream.truncated) {
              reject(new Error(`File size limit exceeded: ${formDataLimits?.fileSize} bytes`));
            }
            const file = new File_js_1.PonyfillFile(chunks, filename, { type: mimeType });
            formData.set(name4, file);
          });
        });
        bb.on("filesLimit", () => {
          reject(new Error(`Files limit exceeded: ${formDataLimits?.files}`));
        });
        bb.on("partsLimit", () => {
          reject(new Error(`Parts limit exceeded: ${formDataLimits?.parts}`));
        });
        bb.on("close", () => {
          resolve(formData);
        });
        bb.on("error", (err) => {
          reject(err);
        });
        _body?.readable.pipe(bb);
      });
    }
    arrayBuffer() {
      if (this._buffer) {
        return (0, utils_js_1.fakePromise)(this._buffer);
      }
      if (this.bodyType === BodyInitType.Blob) {
        if (this.bodyInit instanceof Blob_js_1.PonyfillBlob) {
          return this.bodyInit.arrayBuffer();
        }
        const bodyInitTyped = this.bodyInit;
        return bodyInitTyped.arrayBuffer().then((arrayBuffer) => Buffer.from(arrayBuffer, undefined, bodyInitTyped.size));
      }
      return this._collectChunksFromReadable().then((chunks) => {
        if (chunks.length === 1) {
          return chunks[0];
        }
        return Buffer.concat(chunks);
      });
    }
    json() {
      return this.text().then((text) => JSON.parse(text));
    }
    text() {
      if (this.bodyType === BodyInitType.String) {
        return (0, utils_js_1.fakePromise)(this.bodyInit);
      }
      return this.arrayBuffer().then((buffer) => buffer.toString("utf-8"));
    }
  }
  exports.PonyfillBody = PonyfillBody;
});

// node_modules/@whatwg-node/node-fetch/cjs/Headers.js
var require_Headers = __commonJS((exports) => {
  var isHeadersLike = function(headers) {
    return headers?.get && headers?.forEach;
  };
  var splitSetCookieHeader = function(setCookieHeader) {
    const setCookieHeaders = [];
    let currentStr = "";
    let ignoreComma = false;
    for (const ch of setCookieHeader) {
      if (currentStr.endsWith("Expires=")) {
        ignoreComma = true;
      }
      if (ignoreComma) {
        if (ch === ";") {
          ignoreComma = false;
        }
        if (ch === "," && currentStr.split("Expires=")[1].length > 3) {
          ignoreComma = false;
        }
      }
      if (ch === "," && !ignoreComma) {
        setCookieHeaders.push(currentStr.trim());
        currentStr = "";
      } else {
        currentStr += ch;
      }
    }
    if (currentStr) {
      setCookieHeaders.push(currentStr.trim());
    }
    return setCookieHeaders;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.splitSetCookieHeader = exports.PonyfillHeaders = exports.isHeadersLike = undefined;
  var node_util_1 = import.meta.require("util");
  exports.isHeadersLike = isHeadersLike;

  class PonyfillHeaders {
    constructor(headersInit) {
      this.headersInit = headersInit;
      this.objectNormalizedKeysOfHeadersInit = [];
      this.objectOriginalKeysOfHeadersInit = [];
    }
    _get(key) {
      if (this._map) {
        return this._map.get(key.toLowerCase()) || null;
      }
      if (this.headersInit == null) {
        return null;
      }
      const normalized = key.toLowerCase();
      if (Array.isArray(this.headersInit)) {
        return this.headersInit.find((header) => header[0].toLowerCase() === normalized)?.[1] || null;
      } else if (isHeadersLike(this.headersInit)) {
        return this.headersInit.get(normalized);
      } else {
        const initValue = this.headersInit[key] || this.headersInit[normalized];
        if (initValue != null) {
          return initValue;
        }
        if (!this.objectNormalizedKeysOfHeadersInit.length) {
          Object.keys(this.headersInit).forEach((k) => {
            this.objectOriginalKeysOfHeadersInit.push(k);
            this.objectNormalizedKeysOfHeadersInit.push(k.toLowerCase());
          });
        }
        const index = this.objectNormalizedKeysOfHeadersInit.indexOf(normalized);
        if (index === -1) {
          return null;
        }
        const originalKey = this.objectOriginalKeysOfHeadersInit[index];
        return this.headersInit[originalKey];
      }
    }
    getMap() {
      if (!this._map) {
        if (this.headersInit != null) {
          if (Array.isArray(this.headersInit)) {
            this._map = new Map(this.headersInit);
          } else if (isHeadersLike(this.headersInit)) {
            this._map = new Map;
            this.headersInit.forEach((value, key) => {
              this._map.set(key, value);
            });
          } else {
            this._map = new Map;
            for (const initKey in this.headersInit) {
              const initValue = this.headersInit[initKey];
              if (initValue != null) {
                const normalizedKey = initKey.toLowerCase();
                this._map.set(normalizedKey, initValue);
              }
            }
          }
        } else {
          this._map = new Map;
        }
      }
      return this._map;
    }
    append(name4, value) {
      const key = name4.toLowerCase();
      const existingValue = this.getMap().get(key);
      const finalValue = existingValue ? `${existingValue}, ${value}` : value;
      this.getMap().set(key, finalValue);
    }
    get(name4) {
      const value = this._get(name4);
      if (value == null) {
        return null;
      }
      return value;
    }
    has(name4) {
      return !!this._get(name4);
    }
    set(name4, value) {
      const key = name4.toLowerCase();
      this.getMap().set(key, value);
    }
    delete(name4) {
      const key = name4.toLowerCase();
      this.getMap().delete(key);
    }
    forEach(callback) {
      if (!this._map) {
        if (this.headersInit) {
          if (Array.isArray(this.headersInit)) {
            this.headersInit.forEach(([key, value]) => {
              callback(value, key, this);
            });
            return;
          }
          if (isHeadersLike(this.headersInit)) {
            this.headersInit.forEach(callback);
            return;
          }
          Object.entries(this.headersInit).forEach(([key, value]) => {
            if (value != null) {
              callback(value, key, this);
            }
          });
        }
        return;
      }
      this.getMap().forEach((value, key) => {
        callback(value, key, this);
      });
    }
    keys() {
      if (!this._map) {
        if (this.headersInit) {
          if (Array.isArray(this.headersInit)) {
            return this.headersInit.map(([key]) => key)[Symbol.iterator]();
          }
          if (isHeadersLike(this.headersInit)) {
            return this.headersInit.keys();
          }
          return Object.keys(this.headersInit)[Symbol.iterator]();
        }
      }
      return this.getMap().keys();
    }
    values() {
      if (!this._map) {
        if (this.headersInit) {
          if (Array.isArray(this.headersInit)) {
            return this.headersInit.map(([, value]) => value)[Symbol.iterator]();
          }
          if (isHeadersLike(this.headersInit)) {
            return this.headersInit.values();
          }
          return Object.values(this.headersInit)[Symbol.iterator]();
        }
      }
      return this.getMap().values();
    }
    entries() {
      if (!this._map) {
        if (this.headersInit) {
          if (Array.isArray(this.headersInit)) {
            return this.headersInit[Symbol.iterator]();
          }
          if (isHeadersLike(this.headersInit)) {
            return this.headersInit.entries();
          }
          return Object.entries(this.headersInit)[Symbol.iterator]();
        }
      }
      return this.getMap().entries();
    }
    getSetCookie() {
      const setCookieHeader = this.get("set-cookie");
      if (!setCookieHeader) {
        return [];
      }
      return splitSetCookieHeader(setCookieHeader);
    }
    [Symbol.iterator]() {
      return this.entries();
    }
    [Symbol.for("nodejs.util.inspect.custom")]() {
      const record = {};
      this.forEach((value, key) => {
        if (key === "set-cookie") {
          record["set-cookie"] = this.getSetCookie();
        } else {
          record[key] = value.includes(",") ? value.split(",").map((el) => el.trim()) : value;
        }
      });
      return `Headers ${(0, node_util_1.inspect)(record)}`;
    }
  }
  exports.PonyfillHeaders = PonyfillHeaders;
  exports.splitSetCookieHeader = splitSetCookieHeader;
});

// node_modules/@whatwg-node/node-fetch/cjs/Response.js
var require_Response = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.PonyfillResponse = undefined;
  var http_1 = import.meta.require("http");
  var Body_js_1 = require_Body();
  var Headers_js_1 = require_Headers();
  var JSON_CONTENT_TYPE = "application/json; charset=utf-8";

  class PonyfillResponse extends Body_js_1.PonyfillBody {
    constructor(body, init) {
      super(body || null, init);
      this.headers = init?.headers && (0, Headers_js_1.isHeadersLike)(init.headers) ? init.headers : new Headers_js_1.PonyfillHeaders(init?.headers);
      this.status = init?.status || 200;
      this.statusText = init?.statusText || http_1.STATUS_CODES[this.status] || "OK";
      this.url = init?.url || "";
      this.redirected = init?.redirected || false;
      this.type = init?.type || "default";
      const contentTypeInHeaders = this.headers.get("content-type");
      if (!contentTypeInHeaders) {
        if (this.contentType) {
          this.headers.set("content-type", this.contentType);
        }
      } else {
        this.contentType = contentTypeInHeaders;
      }
      const contentLengthInHeaders = this.headers.get("content-length");
      if (!contentLengthInHeaders) {
        if (this.contentLength) {
          this.headers.set("content-length", this.contentLength.toString());
        }
      } else {
        this.contentLength = parseInt(contentLengthInHeaders, 10);
      }
    }
    get ok() {
      return this.status >= 200 && this.status < 300;
    }
    clone() {
      return new PonyfillResponse(this.body, this);
    }
    static error() {
      return new PonyfillResponse(null, {
        status: 500,
        statusText: "Internal Server Error"
      });
    }
    static redirect(url, status = 301) {
      if (status < 300 || status > 399) {
        throw new RangeError("Invalid status code");
      }
      return new PonyfillResponse(null, {
        headers: {
          location: url
        },
        status
      });
    }
    static json(data, init = {}) {
      init.headers = init?.headers && (0, Headers_js_1.isHeadersLike)(init.headers) ? init.headers : new Headers_js_1.PonyfillHeaders(init?.headers);
      if (!init.headers.has("content-type")) {
        init.headers.set("content-type", JSON_CONTENT_TYPE);
      }
      return new PonyfillResponse(JSON.stringify(data), init);
    }
  }
  exports.PonyfillResponse = PonyfillResponse;
});

// node_modules/@whatwg-node/node-fetch/cjs/fetchCurl.js
var require_fetchCurl = __commonJS((exports) => {
  var fetchCurl = function(fetchRequest) {
    const { Curl, CurlCode, CurlFeature, CurlPause, CurlProgressFunc } = globalThis["libcurl"];
    const curlHandle = new Curl;
    curlHandle.enable(CurlFeature.NoDataParsing);
    curlHandle.setOpt("URL", fetchRequest.url);
    curlHandle.setOpt("SSL_VERIFYPEER", false);
    curlHandle.enable(CurlFeature.StreamResponse);
    curlHandle.setStreamProgressCallback(function() {
      return fetchRequest["_signal"]?.aborted ? process.env.DEBUG ? CurlProgressFunc.Continue : 1 : 0;
    });
    if (fetchRequest["bodyType"] === "String") {
      curlHandle.setOpt("POSTFIELDS", fetchRequest["bodyInit"]);
    } else {
      const nodeReadable = fetchRequest.body != null ? (0, utils_js_1.isNodeReadable)(fetchRequest.body) ? fetchRequest.body : node_stream_1.Readable.from(fetchRequest.body) : null;
      if (nodeReadable) {
        curlHandle.setOpt("UPLOAD", true);
        curlHandle.setUploadStream(nodeReadable);
      }
    }
    if (process.env.DEBUG) {
      curlHandle.setOpt("VERBOSE", true);
    }
    curlHandle.setOpt("TRANSFER_ENCODING", false);
    curlHandle.setOpt("HTTP_TRANSFER_DECODING", true);
    curlHandle.setOpt("FOLLOWLOCATION", fetchRequest.redirect === "follow");
    curlHandle.setOpt("MAXREDIRS", 20);
    curlHandle.setOpt("ACCEPT_ENCODING", "");
    curlHandle.setOpt("CUSTOMREQUEST", fetchRequest.method);
    const headersSerializer = fetchRequest.headersSerializer || utils_js_1.defaultHeadersSerializer;
    let size;
    const curlHeaders = headersSerializer(fetchRequest.headers, (value) => {
      size = Number(value);
    });
    if (size != null) {
      curlHandle.setOpt("INFILESIZE", size);
    }
    curlHandle.setOpt("HTTPHEADER", curlHeaders);
    curlHandle.enable(CurlFeature.NoHeaderParsing);
    return new Promise(function promiseResolver(resolve, reject) {
      let streamResolved = false;
      if (fetchRequest["_signal"]) {
        fetchRequest["_signal"].onabort = () => {
          if (streamResolved) {
            curlHandle.pause(CurlPause.Recv);
          } else {
            reject(new AbortError_js_1.PonyfillAbortError);
            curlHandle.close();
          }
        };
      }
      curlHandle.once("end", function endListener() {
        curlHandle.close();
      });
      curlHandle.once("error", function errorListener(error2) {
        if (error2.isCurlError && error2.code === CurlCode.CURLE_ABORTED_BY_CALLBACK) {
        } else {
          reject(error2);
        }
        curlHandle.close();
      });
      curlHandle.once("stream", function streamListener(stream, status, headersBuf) {
        const headersFlat = headersBuf.toString("utf8").split(/\r?\n|\r/g).filter((headerFilter) => {
          if (headerFilter && !headerFilter.startsWith("HTTP/")) {
            if (fetchRequest.redirect === "error" && (headerFilter.includes("location") || headerFilter.includes("Location"))) {
              reject(new Error("redirect is not allowed"));
            }
            return true;
          }
          return false;
        });
        const headersInit = headersFlat.map((headerFlat) => headerFlat.split(/:\s(.+)/).slice(0, 2));
        resolve(new Response_js_1.PonyfillResponse(stream, {
          status,
          headers: headersInit,
          url: fetchRequest.url
        }));
        streamResolved = true;
      });
      curlHandle.perform();
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.fetchCurl = undefined;
  var node_stream_1 = import.meta.require("stream");
  var AbortError_js_1 = require_AbortError();
  var Response_js_1 = require_Response();
  var utils_js_1 = require_utils2();
  exports.fetchCurl = fetchCurl;
});

// node_modules/@whatwg-node/node-fetch/cjs/Request.js
var require_Request = __commonJS((exports) => {
  var isRequest = function(input) {
    return input[Symbol.toStringTag] === "Request";
  };
  var isURL = function(obj) {
    return obj?.href != null;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.PonyfillRequest = undefined;
  var Body_js_1 = require_Body();
  var Headers_js_1 = require_Headers();

  class PonyfillRequest extends Body_js_1.PonyfillBody {
    constructor(input, options) {
      let url;
      let bodyInit = null;
      let requestInit;
      if (typeof input === "string") {
        url = input;
      } else if (isURL(input)) {
        url = input.toString();
      } else if (isRequest(input)) {
        url = input.url;
        bodyInit = input.body;
        requestInit = input;
      }
      if (options != null) {
        bodyInit = options.body || null;
        requestInit = options;
      }
      super(bodyInit, options);
      this.cache = requestInit?.cache || "default";
      this.credentials = requestInit?.credentials || "same-origin";
      this.headers = requestInit?.headers && (0, Headers_js_1.isHeadersLike)(requestInit.headers) ? requestInit.headers : new Headers_js_1.PonyfillHeaders(requestInit?.headers);
      this.integrity = requestInit?.integrity || "";
      this.keepalive = requestInit?.keepalive != null ? requestInit?.keepalive : false;
      this.method = requestInit?.method?.toUpperCase() || "GET";
      this.mode = requestInit?.mode || "cors";
      this.redirect = requestInit?.redirect || "follow";
      this.referrer = requestInit?.referrer || "about:client";
      this.referrerPolicy = requestInit?.referrerPolicy || "no-referrer";
      this._signal = requestInit?.signal;
      this.headersSerializer = requestInit?.headersSerializer;
      this.url = url || "";
      this.destination = "document";
      this.priority = "auto";
      if (this.method !== "GET" && this.method !== "HEAD") {
        const contentTypeInHeaders = this.headers.get("content-type");
        if (!contentTypeInHeaders) {
          if (this.contentType) {
            this.headers.set("content-type", this.contentType);
          }
        } else {
          this.contentType = contentTypeInHeaders;
        }
        const contentLengthInHeaders = this.headers.get("content-length");
        if (!contentLengthInHeaders) {
          if (this.contentLength) {
            this.headers.set("content-length", this.contentLength.toString());
          }
        } else {
          this.contentLength = parseInt(contentLengthInHeaders, 10);
        }
      }
    }
    get signal() {
      if (!this._signal) {
        this._signal = new AbortController().signal;
      }
      return this._signal;
    }
    clone() {
      return new PonyfillRequest(this);
    }
  }
  exports.PonyfillRequest = PonyfillRequest;
});

// node_modules/fast-decode-uri-component/index.js
var require_fast_decode_uri_component = __commonJS((exports, module) => {
  var decodeURIComponent2 = function(uri) {
    var percentPosition = uri.indexOf("%");
    if (percentPosition === -1)
      return uri;
    var length = uri.length;
    var decoded = "";
    var last = 0;
    var codepoint = 0;
    var startOfOctets = percentPosition;
    var state = UTF8_ACCEPT;
    while (percentPosition > -1 && percentPosition < length) {
      var high = hexCodeToInt(uri[percentPosition + 1], 4);
      var low = hexCodeToInt(uri[percentPosition + 2], 0);
      var byte = high | low;
      var type = UTF8_DATA[byte];
      state = UTF8_DATA[256 + state + type];
      codepoint = codepoint << 6 | byte & UTF8_DATA[364 + type];
      if (state === UTF8_ACCEPT) {
        decoded += uri.slice(last, startOfOctets);
        decoded += codepoint <= 65535 ? String.fromCharCode(codepoint) : String.fromCharCode(55232 + (codepoint >> 10), 56320 + (codepoint & 1023));
        codepoint = 0;
        last = percentPosition + 3;
        percentPosition = startOfOctets = uri.indexOf("%", last);
      } else if (state === UTF8_REJECT) {
        return null;
      } else {
        percentPosition += 3;
        if (percentPosition < length && uri.charCodeAt(percentPosition) === 37)
          continue;
        return null;
      }
    }
    return decoded + uri.slice(last);
  };
  var hexCodeToInt = function(c, shift) {
    var i = HEX[c];
    return i === undefined ? 255 : i << shift;
  };
  var UTF8_ACCEPT = 12;
  var UTF8_REJECT = 0;
  var UTF8_DATA = [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    4,
    4,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    6,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    8,
    7,
    7,
    10,
    9,
    9,
    9,
    11,
    4,
    4,
    4,
    4,
    4,
    4,
    4,
    4,
    4,
    4,
    4,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    12,
    0,
    0,
    0,
    0,
    24,
    36,
    48,
    60,
    72,
    84,
    96,
    0,
    12,
    12,
    12,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    24,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    24,
    24,
    24,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    24,
    24,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    48,
    48,
    48,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    48,
    48,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    48,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    127,
    63,
    63,
    63,
    0,
    31,
    15,
    15,
    15,
    7,
    7,
    7
  ];
  var HEX = {
    "0": 0,
    "1": 1,
    "2": 2,
    "3": 3,
    "4": 4,
    "5": 5,
    "6": 6,
    "7": 7,
    "8": 8,
    "9": 9,
    a: 10,
    A: 10,
    b: 11,
    B: 11,
    c: 12,
    C: 12,
    d: 13,
    D: 13,
    e: 14,
    E: 14,
    f: 15,
    F: 15
  };
  module.exports = decodeURIComponent2;
});

// node_modules/fast-querystring/lib/parse.js
var require_parse = __commonJS((exports, module) => {
  var parse2 = function(input) {
    const result = new Empty;
    if (typeof input !== "string") {
      return result;
    }
    let inputLength = input.length;
    let key = "";
    let value = "";
    let startingIndex = -1;
    let equalityIndex = -1;
    let shouldDecodeKey = false;
    let shouldDecodeValue = false;
    let keyHasPlus = false;
    let valueHasPlus = false;
    let hasBothKeyValuePair = false;
    let c = 0;
    for (let i = 0;i < inputLength + 1; i++) {
      c = i !== inputLength ? input.charCodeAt(i) : 38;
      if (c === 38) {
        hasBothKeyValuePair = equalityIndex > startingIndex;
        if (!hasBothKeyValuePair) {
          equalityIndex = i;
        }
        key = input.slice(startingIndex + 1, equalityIndex);
        if (hasBothKeyValuePair || key.length > 0) {
          if (keyHasPlus) {
            key = key.replace(plusRegex, " ");
          }
          if (shouldDecodeKey) {
            key = fastDecode(key) || key;
          }
          if (hasBothKeyValuePair) {
            value = input.slice(equalityIndex + 1, i);
            if (valueHasPlus) {
              value = value.replace(plusRegex, " ");
            }
            if (shouldDecodeValue) {
              value = fastDecode(value) || value;
            }
          }
          const currentValue = result[key];
          if (currentValue === undefined) {
            result[key] = value;
          } else {
            if (currentValue.pop) {
              currentValue.push(value);
            } else {
              result[key] = [currentValue, value];
            }
          }
        }
        value = "";
        startingIndex = i;
        equalityIndex = i;
        shouldDecodeKey = false;
        shouldDecodeValue = false;
        keyHasPlus = false;
        valueHasPlus = false;
      } else if (c === 61) {
        if (equalityIndex <= startingIndex) {
          equalityIndex = i;
        } else {
          shouldDecodeValue = true;
        }
      } else if (c === 43) {
        if (equalityIndex > startingIndex) {
          valueHasPlus = true;
        } else {
          keyHasPlus = true;
        }
      } else if (c === 37) {
        if (equalityIndex > startingIndex) {
          shouldDecodeValue = true;
        } else {
          shouldDecodeKey = true;
        }
      }
    }
    return result;
  };
  var fastDecode = require_fast_decode_uri_component();
  var plusRegex = /\+/g;
  var Empty = function() {
  };
  Empty.prototype = Object.create(null);
  module.exports = parse2;
});

// node_modules/fast-querystring/lib/internals/querystring.js
var require_querystring = __commonJS((exports, module) => {
  var encodeString = function(str) {
    const len = str.length;
    if (len === 0)
      return "";
    let out = "";
    let lastPos = 0;
    let i = 0;
    outer:
      for (;i < len; i++) {
        let c = str.charCodeAt(i);
        while (c < 128) {
          if (noEscape[c] !== 1) {
            if (lastPos < i)
              out += str.slice(lastPos, i);
            lastPos = i + 1;
            out += hexTable[c];
          }
          if (++i === len)
            break outer;
          c = str.charCodeAt(i);
        }
        if (lastPos < i)
          out += str.slice(lastPos, i);
        if (c < 2048) {
          lastPos = i + 1;
          out += hexTable[192 | c >> 6] + hexTable[128 | c & 63];
          continue;
        }
        if (c < 55296 || c >= 57344) {
          lastPos = i + 1;
          out += hexTable[224 | c >> 12] + hexTable[128 | c >> 6 & 63] + hexTable[128 | c & 63];
          continue;
        }
        ++i;
        if (i >= len) {
          throw new Error("URI malformed");
        }
        const c2 = str.charCodeAt(i) & 1023;
        lastPos = i + 1;
        c = 65536 + ((c & 1023) << 10 | c2);
        out += hexTable[240 | c >> 18] + hexTable[128 | c >> 12 & 63] + hexTable[128 | c >> 6 & 63] + hexTable[128 | c & 63];
      }
    if (lastPos === 0)
      return str;
    if (lastPos < len)
      return out + str.slice(lastPos);
    return out;
  };
  var hexTable = Array.from({ length: 256 }, (_, i) => "%" + ((i < 16 ? "0" : "") + i.toString(16)).toUpperCase());
  var noEscape = new Int8Array([
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    0,
    0,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    0,
    0,
    1,
    1,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    0,
    1,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    1,
    0
  ]);
  module.exports = { encodeString };
});

// node_modules/fast-querystring/lib/stringify.js
var require_stringify = __commonJS((exports, module) => {
  var getAsPrimitive = function(value) {
    const type = typeof value;
    if (type === "string") {
      return encodeString(value);
    } else if (type === "bigint") {
      return value.toString();
    } else if (type === "boolean") {
      return value ? "true" : "false";
    } else if (type === "number" && Number.isFinite(value)) {
      return value < 1000000000000000000000 ? "" + value : encodeString("" + value);
    }
    return "";
  };
  var stringify2 = function(input) {
    let result = "";
    if (input === null || typeof input !== "object") {
      return result;
    }
    const separator = "&";
    const keys = Object.keys(input);
    const keyLength = keys.length;
    let valueLength = 0;
    for (let i = 0;i < keyLength; i++) {
      const key = keys[i];
      const value = input[key];
      const encodedKey = encodeString(key) + "=";
      if (i) {
        result += separator;
      }
      if (Array.isArray(value)) {
        valueLength = value.length;
        for (let j = 0;j < valueLength; j++) {
          if (j) {
            result += separator;
          }
          result += encodedKey;
          result += getAsPrimitive(value[j]);
        }
      } else {
        result += encodedKey;
        result += getAsPrimitive(value);
      }
    }
    return result;
  };
  var { encodeString } = require_querystring();
  module.exports = stringify2;
});

// node_modules/fast-querystring/lib/index.js
var require_lib2 = __commonJS((exports, module) => {
  var parse2 = require_parse();
  var stringify2 = require_stringify();
  var fastQuerystring = {
    parse: parse2,
    stringify: stringify2
  };
  module.exports = fastQuerystring;
  module.exports.default = fastQuerystring;
  module.exports.parse = parse2;
  module.exports.stringify = stringify2;
});

// node_modules/fast-url-parser/src/urlparser.js
var require_urlparser = __commonJS((exports, module) => {
  var Url = function() {
    this._protocol = null;
    this._href = "";
    this._port = -1;
    this._query = null;
    this.auth = null;
    this.slashes = null;
    this.host = null;
    this.hostname = null;
    this.hash = null;
    this.search = null;
    this.pathname = null;
    this._prependSlash = false;
  };
  var _escapePath = function(pathname) {
    return pathname.replace(/[?#]/g, function(match) {
      return encodeURIComponent(match);
    });
  };
  var _escapeSearch = function(search) {
    return search.replace(/#/g, function(match) {
      return encodeURIComponent(match);
    });
  };
  var containsCharacter = function(string, char1, fromIndex, stopCharacterTable) {
    var len2 = string.length;
    for (var i2 = fromIndex;i2 < len2; ++i2) {
      var ch = string.charCodeAt(i2);
      if (ch === char1) {
        return true;
      } else if (stopCharacterTable[ch] === 1) {
        return false;
      }
    }
    return false;
  };
  var containsCharacter2 = function(string, char1, char2) {
    for (var i2 = 0, len2 = string.length;i2 < len2; ++i2) {
      var ch = string.charCodeAt(i2);
      if (ch === char1 || ch === char2)
        return true;
    }
    return false;
  };
  var makeAsciiTable = function(spec) {
    var ret = new Uint8Array(128);
    spec.forEach(function(item2) {
      if (typeof item2 === "number") {
        ret[item2] = 1;
      } else {
        var start = item2[0];
        var end = item2[1];
        for (var j = start;j <= end; ++j) {
          ret[j] = 1;
        }
      }
    });
    return ret;
  };
  var f = function() {
  };
  var querystring2 = import.meta.require("querystring");
  Url.queryString = querystring2;
  Url.prototype.parse = function Url$parse(str, parseQueryString, hostDenotesSlash, disableAutoEscapeChars) {
    if (typeof str !== "string") {
      throw new TypeError("Parameter 'url' must be a string, not " + typeof str);
    }
    var start = 0;
    var end = str.length - 1;
    while (str.charCodeAt(start) <= 32)
      start++;
    while (str.charCodeAt(end) <= 32)
      end--;
    start = this._parseProtocol(str, start, end);
    if (this._protocol !== "javascript") {
      start = this._parseHost(str, start, end, hostDenotesSlash);
      var proto = this._protocol;
      if (!this.hostname && (this.slashes || proto && !slashProtocols[proto])) {
        this.hostname = this.host = "";
      }
    }
    if (start <= end) {
      var ch = str.charCodeAt(start);
      if (ch === 47 || ch === 92) {
        this._parsePath(str, start, end, disableAutoEscapeChars);
      } else if (ch === 63) {
        this._parseQuery(str, start, end, disableAutoEscapeChars);
      } else if (ch === 35) {
        this._parseHash(str, start, end, disableAutoEscapeChars);
      } else if (this._protocol !== "javascript") {
        this._parsePath(str, start, end, disableAutoEscapeChars);
      } else {
        this.pathname = str.slice(start, end + 1);
      }
    }
    if (!this.pathname && this.hostname && this._slashProtocols[this._protocol]) {
      this.pathname = "/";
    }
    if (parseQueryString) {
      var search = this.search;
      if (search == null) {
        search = this.search = "";
      }
      if (search.charCodeAt(0) === 63) {
        search = search.slice(1);
      }
      this.query = Url.queryString.parse(search);
    }
  };
  Url.prototype.resolve = function Url$resolve(relative2) {
    return this.resolveObject(Url.parse(relative2, false, true)).format();
  };
  Url.prototype.format = function Url$format() {
    var auth = this.auth || "";
    if (auth) {
      auth = encodeURIComponent(auth);
      auth = auth.replace(/%3A/i, ":");
      auth += "@";
    }
    var protocol = this.protocol || "";
    var pathname = this.pathname || "";
    var hash = this.hash || "";
    var search = this.search || "";
    var query = "";
    var hostname = this.hostname || "";
    var port = this.port || "";
    var host = false;
    var scheme = "";
    var q = this.query;
    if (q && typeof q === "object") {
      query = Url.queryString.stringify(q);
    }
    if (!search) {
      search = query ? "?" + query : "";
    }
    if (protocol && protocol.charCodeAt(protocol.length - 1) !== 58)
      protocol += ":";
    if (this.host) {
      host = auth + this.host;
    } else if (hostname) {
      var ip6 = hostname.indexOf(":") > -1;
      if (ip6)
        hostname = "[" + hostname + "]";
      host = auth + hostname + (port ? ":" + port : "");
    }
    var slashes = this.slashes || (!protocol || slashProtocols[protocol]) && host !== false;
    if (protocol)
      scheme = protocol + (slashes ? "//" : "");
    else if (slashes)
      scheme = "//";
    if (slashes && pathname && pathname.charCodeAt(0) !== 47) {
      pathname = "/" + pathname;
    }
    if (search && search.charCodeAt(0) !== 63)
      search = "?" + search;
    if (hash && hash.charCodeAt(0) !== 35)
      hash = "#" + hash;
    pathname = escapePathName(pathname);
    search = escapeSearch(search);
    return scheme + (host === false ? "" : host) + pathname + search + hash;
  };
  Url.prototype.resolveObject = function Url$resolveObject(relative2) {
    if (typeof relative2 === "string")
      relative2 = Url.parse(relative2, false, true);
    var result = this._clone();
    result.hash = relative2.hash;
    if (!relative2.href) {
      result._href = "";
      return result;
    }
    if (relative2.slashes && !relative2._protocol) {
      relative2._copyPropsTo(result, true);
      if (slashProtocols[result._protocol] && result.hostname && !result.pathname) {
        result.pathname = "/";
      }
      result._href = "";
      return result;
    }
    if (relative2._protocol && relative2._protocol !== result._protocol) {
      if (!slashProtocols[relative2._protocol]) {
        relative2._copyPropsTo(result, false);
        result._href = "";
        return result;
      }
      result._protocol = relative2._protocol;
      if (!relative2.host && relative2._protocol !== "javascript") {
        var relPath = (relative2.pathname || "").split("/");
        while (relPath.length && !(relative2.host = relPath.shift()))
          ;
        if (!relative2.host)
          relative2.host = "";
        if (!relative2.hostname)
          relative2.hostname = "";
        if (relPath[0] !== "")
          relPath.unshift("");
        if (relPath.length < 2)
          relPath.unshift("");
        result.pathname = relPath.join("/");
      } else {
        result.pathname = relative2.pathname;
      }
      result.search = relative2.search;
      result.host = relative2.host || "";
      result.auth = relative2.auth;
      result.hostname = relative2.hostname || relative2.host;
      result._port = relative2._port;
      result.slashes = result.slashes || relative2.slashes;
      result._href = "";
      return result;
    }
    var isSourceAbs = result.pathname && result.pathname.charCodeAt(0) === 47;
    var isRelAbs = relative2.host || relative2.pathname && relative2.pathname.charCodeAt(0) === 47;
    var mustEndAbs = isRelAbs || isSourceAbs || result.host && relative2.pathname;
    var removeAllDots = mustEndAbs;
    var srcPath = result.pathname && result.pathname.split("/") || [];
    var relPath = relative2.pathname && relative2.pathname.split("/") || [];
    var psychotic = result._protocol && !slashProtocols[result._protocol];
    if (psychotic) {
      result.hostname = "";
      result._port = -1;
      if (result.host) {
        if (srcPath[0] === "")
          srcPath[0] = result.host;
        else
          srcPath.unshift(result.host);
      }
      result.host = "";
      if (relative2._protocol) {
        relative2.hostname = "";
        relative2._port = -1;
        if (relative2.host) {
          if (relPath[0] === "")
            relPath[0] = relative2.host;
          else
            relPath.unshift(relative2.host);
        }
        relative2.host = "";
      }
      mustEndAbs = mustEndAbs && (relPath[0] === "" || srcPath[0] === "");
    }
    if (isRelAbs) {
      result.host = relative2.host ? relative2.host : result.host;
      result.hostname = relative2.hostname ? relative2.hostname : result.hostname;
      result.search = relative2.search;
      srcPath = relPath;
    } else if (relPath.length) {
      if (!srcPath)
        srcPath = [];
      srcPath.pop();
      srcPath = srcPath.concat(relPath);
      result.search = relative2.search;
    } else if (relative2.search) {
      if (psychotic) {
        result.hostname = result.host = srcPath.shift();
        var authInHost = result.host && result.host.indexOf("@") > 0 ? result.host.split("@") : false;
        if (authInHost) {
          result.auth = authInHost.shift();
          result.host = result.hostname = authInHost.shift();
        }
      }
      result.search = relative2.search;
      result._href = "";
      return result;
    }
    if (!srcPath.length) {
      result.pathname = null;
      result._href = "";
      return result;
    }
    var last = srcPath.slice(-1)[0];
    var hasTrailingSlash = (result.host || relative2.host) && (last === "." || last === "..") || last === "";
    var up = 0;
    for (var i2 = srcPath.length;i2 >= 0; i2--) {
      last = srcPath[i2];
      if (last === ".") {
        srcPath.splice(i2, 1);
      } else if (last === "..") {
        srcPath.splice(i2, 1);
        up++;
      } else if (up) {
        srcPath.splice(i2, 1);
        up--;
      }
    }
    if (!mustEndAbs && !removeAllDots) {
      for (;up--; up) {
        srcPath.unshift("..");
      }
    }
    if (mustEndAbs && srcPath[0] !== "" && (!srcPath[0] || srcPath[0].charCodeAt(0) !== 47)) {
      srcPath.unshift("");
    }
    if (hasTrailingSlash && srcPath.join("/").substr(-1) !== "/") {
      srcPath.push("");
    }
    var isAbsolute5 = srcPath[0] === "" || srcPath[0] && srcPath[0].charCodeAt(0) === 47;
    if (psychotic) {
      result.hostname = result.host = isAbsolute5 ? "" : srcPath.length ? srcPath.shift() : "";
      var authInHost = result.host && result.host.indexOf("@") > 0 ? result.host.split("@") : false;
      if (authInHost) {
        result.auth = authInHost.shift();
        result.host = result.hostname = authInHost.shift();
      }
    }
    mustEndAbs = mustEndAbs || result.host && srcPath.length;
    if (mustEndAbs && !isAbsolute5) {
      srcPath.unshift("");
    }
    result.pathname = srcPath.length === 0 ? null : srcPath.join("/");
    result.auth = relative2.auth || result.auth;
    result.slashes = result.slashes || relative2.slashes;
    result._href = "";
    return result;
  };
  var punycode = import.meta.require("punycode");
  Url.prototype._hostIdna = function Url$_hostIdna(hostname) {
    return punycode.toASCII(hostname);
  };
  var escapePathName = Url.prototype._escapePathName = function Url$_escapePathName(pathname) {
    if (!containsCharacter2(pathname, 35, 63)) {
      return pathname;
    }
    return _escapePath(pathname);
  };
  var escapeSearch = Url.prototype._escapeSearch = function Url$_escapeSearch(search) {
    if (!containsCharacter2(search, 35, -1))
      return search;
    return _escapeSearch(search);
  };
  Url.prototype._parseProtocol = function Url$_parseProtocol(str, start, end) {
    var doLowerCase = false;
    var protocolCharacters = this._protocolCharacters;
    for (var i2 = start;i2 <= end; ++i2) {
      var ch = str.charCodeAt(i2);
      if (ch === 58) {
        var protocol = str.slice(start, i2);
        if (doLowerCase)
          protocol = protocol.toLowerCase();
        this._protocol = protocol;
        return i2 + 1;
      } else if (protocolCharacters[ch] === 1) {
        if (ch < 97)
          doLowerCase = true;
      } else {
        return start;
      }
    }
    return start;
  };
  Url.prototype._parseAuth = function Url$_parseAuth(str, start, end, decode2) {
    var auth = str.slice(start, end + 1);
    if (decode2) {
      auth = decodeURIComponent(auth);
    }
    this.auth = auth;
  };
  Url.prototype._parsePort = function Url$_parsePort(str, start, end) {
    var port = 0;
    var hadChars = false;
    var validPort = true;
    for (var i2 = start;i2 <= end; ++i2) {
      var ch = str.charCodeAt(i2);
      if (48 <= ch && ch <= 57) {
        port = 10 * port + (ch - 48);
        hadChars = true;
      } else {
        validPort = false;
        if (ch === 92 || ch === 47) {
          validPort = true;
        }
        break;
      }
    }
    if (port === 0 && !hadChars || !validPort) {
      if (!validPort) {
        this._port = -2;
      }
      return 0;
    }
    this._port = port;
    return i2 - start;
  };
  Url.prototype._parseHost = function Url$_parseHost(str, start, end, slashesDenoteHost) {
    var hostEndingCharacters = this._hostEndingCharacters;
    var first = str.charCodeAt(start);
    var second = str.charCodeAt(start + 1);
    if ((first === 47 || first === 92) && (second === 47 || second === 92)) {
      this.slashes = true;
      if (start === 0) {
        if (end < 2)
          return start;
        var hasAuth = containsCharacter(str, 64, 2, hostEndingCharacters);
        if (!hasAuth && !slashesDenoteHost) {
          this.slashes = null;
          return start;
        }
      }
      start += 2;
    } else if (!this._protocol || slashProtocols[this._protocol]) {
      return start;
    }
    var doLowerCase = false;
    var idna = false;
    var hostNameStart = start;
    var hostNameEnd = end;
    var lastCh = -1;
    var portLength = 0;
    var charsAfterDot = 0;
    var authNeedsDecoding = false;
    var j = -1;
    for (var i2 = start;i2 <= end; ++i2) {
      var ch = str.charCodeAt(i2);
      if (ch === 64) {
        j = i2;
      } else if (ch === 37) {
        authNeedsDecoding = true;
      } else if (hostEndingCharacters[ch] === 1) {
        break;
      }
    }
    if (j > -1) {
      this._parseAuth(str, start, j - 1, authNeedsDecoding);
      start = hostNameStart = j + 1;
    }
    if (str.charCodeAt(start) === 91) {
      for (var i2 = start + 1;i2 <= end; ++i2) {
        var ch = str.charCodeAt(i2);
        if (ch === 93) {
          if (str.charCodeAt(i2 + 1) === 58) {
            portLength = this._parsePort(str, i2 + 2, end) + 1;
          }
          var hostname = str.slice(start + 1, i2).toLowerCase();
          this.hostname = hostname;
          this.host = this._port > 0 ? "[" + hostname + "]:" + this._port : "[" + hostname + "]";
          this.pathname = "/";
          return i2 + portLength + 1;
        }
      }
      return start;
    }
    for (var i2 = start;i2 <= end; ++i2) {
      if (charsAfterDot > 62) {
        this.hostname = this.host = str.slice(start, i2);
        return i2;
      }
      var ch = str.charCodeAt(i2);
      if (ch === 58) {
        portLength = this._parsePort(str, i2 + 1, end) + 1;
        hostNameEnd = i2 - 1;
        break;
      } else if (ch < 97) {
        if (ch === 46) {
          charsAfterDot = -1;
        } else if (65 <= ch && ch <= 90) {
          doLowerCase = true;
        } else if (!(ch === 45 || ch === 95 || ch === 43 || 48 <= ch && ch <= 57)) {
          if (hostEndingCharacters[ch] === 0 && this._noPrependSlashHostEnders[ch] === 0) {
            this._prependSlash = true;
          }
          hostNameEnd = i2 - 1;
          break;
        }
      } else if (ch >= 123) {
        if (ch <= 126) {
          if (this._noPrependSlashHostEnders[ch] === 0) {
            this._prependSlash = true;
          }
          hostNameEnd = i2 - 1;
          break;
        }
        idna = true;
      }
      lastCh = ch;
      charsAfterDot++;
    }
    if (hostNameEnd + 1 !== start && hostNameEnd - hostNameStart <= 256) {
      var hostname = str.slice(hostNameStart, hostNameEnd + 1);
      if (doLowerCase)
        hostname = hostname.toLowerCase();
      if (idna)
        hostname = this._hostIdna(hostname);
      this.hostname = hostname;
      this.host = this._port > 0 ? hostname + ":" + this._port : hostname;
    }
    return hostNameEnd + 1 + portLength;
  };
  Url.prototype._copyPropsTo = function Url$_copyPropsTo(input, noProtocol) {
    if (!noProtocol) {
      input._protocol = this._protocol;
    }
    input._href = this._href;
    input._port = this._port;
    input._prependSlash = this._prependSlash;
    input.auth = this.auth;
    input.slashes = this.slashes;
    input.host = this.host;
    input.hostname = this.hostname;
    input.hash = this.hash;
    input.search = this.search;
    input.pathname = this.pathname;
  };
  Url.prototype._clone = function Url$_clone() {
    var ret = new Url;
    ret._protocol = this._protocol;
    ret._href = this._href;
    ret._port = this._port;
    ret._prependSlash = this._prependSlash;
    ret.auth = this.auth;
    ret.slashes = this.slashes;
    ret.host = this.host;
    ret.hostname = this.hostname;
    ret.hash = this.hash;
    ret.search = this.search;
    ret.pathname = this.pathname;
    return ret;
  };
  Url.prototype._getComponentEscaped = function Url$_getComponentEscaped(str, start, end, isAfterQuery) {
    var cur = start;
    var i2 = start;
    var ret = "";
    var autoEscapeMap2 = isAfterQuery ? this._afterQueryAutoEscapeMap : this._autoEscapeMap;
    for (;i2 <= end; ++i2) {
      var ch = str.charCodeAt(i2);
      var escaped = autoEscapeMap2[ch];
      if (escaped !== "" && escaped !== undefined) {
        if (cur < i2)
          ret += str.slice(cur, i2);
        ret += escaped;
        cur = i2 + 1;
      }
    }
    if (cur < i2 + 1)
      ret += str.slice(cur, i2);
    return ret;
  };
  Url.prototype._parsePath = function Url$_parsePath(str, start, end, disableAutoEscapeChars) {
    var pathStart = start;
    var pathEnd = end;
    var escape2 = false;
    var autoEscapeCharacters = this._autoEscapeCharacters;
    var prePath = this._port === -2 ? "/:" : "";
    for (var i2 = start;i2 <= end; ++i2) {
      var ch = str.charCodeAt(i2);
      if (ch === 35) {
        this._parseHash(str, i2, end, disableAutoEscapeChars);
        pathEnd = i2 - 1;
        break;
      } else if (ch === 63) {
        this._parseQuery(str, i2, end, disableAutoEscapeChars);
        pathEnd = i2 - 1;
        break;
      } else if (!disableAutoEscapeChars && !escape2 && autoEscapeCharacters[ch] === 1) {
        escape2 = true;
      }
    }
    if (pathStart > pathEnd) {
      this.pathname = prePath === "" ? "/" : prePath;
      return;
    }
    var path5;
    if (escape2) {
      path5 = this._getComponentEscaped(str, pathStart, pathEnd, false);
    } else {
      path5 = str.slice(pathStart, pathEnd + 1);
    }
    this.pathname = prePath === "" ? this._prependSlash ? "/" + path5 : path5 : prePath + path5;
  };
  Url.prototype._parseQuery = function Url$_parseQuery(str, start, end, disableAutoEscapeChars) {
    var queryStart = start;
    var queryEnd = end;
    var escape2 = false;
    var autoEscapeCharacters = this._autoEscapeCharacters;
    for (var i2 = start;i2 <= end; ++i2) {
      var ch = str.charCodeAt(i2);
      if (ch === 35) {
        this._parseHash(str, i2, end, disableAutoEscapeChars);
        queryEnd = i2 - 1;
        break;
      } else if (!disableAutoEscapeChars && !escape2 && autoEscapeCharacters[ch] === 1) {
        escape2 = true;
      }
    }
    if (queryStart > queryEnd) {
      this.search = "";
      return;
    }
    var query;
    if (escape2) {
      query = this._getComponentEscaped(str, queryStart, queryEnd, true);
    } else {
      query = str.slice(queryStart, queryEnd + 1);
    }
    this.search = query;
  };
  Url.prototype._parseHash = function Url$_parseHash(str, start, end, disableAutoEscapeChars) {
    if (start > end) {
      this.hash = "";
      return;
    }
    this.hash = disableAutoEscapeChars ? str.slice(start, end + 1) : this._getComponentEscaped(str, start, end, true);
  };
  Object.defineProperty(Url.prototype, "port", {
    get: function() {
      if (this._port >= 0) {
        return "" + this._port;
      }
      return null;
    },
    set: function(v) {
      if (v == null) {
        this._port = -1;
      } else {
        this._port = parseInt(v, 10);
      }
    }
  });
  Object.defineProperty(Url.prototype, "query", {
    get: function() {
      var query = this._query;
      if (query != null) {
        return query;
      }
      var search = this.search;
      if (search) {
        if (search.charCodeAt(0) === 63) {
          search = search.slice(1);
        }
        if (search !== "") {
          this._query = search;
          return search;
        }
      }
      return search;
    },
    set: function(v) {
      this._query = v;
    }
  });
  Object.defineProperty(Url.prototype, "path", {
    get: function() {
      var p = this.pathname || "";
      var s = this.search || "";
      if (p || s) {
        return p + s;
      }
      return p == null && s ? "/" + s : null;
    },
    set: function() {
    }
  });
  Object.defineProperty(Url.prototype, "protocol", {
    get: function() {
      var proto = this._protocol;
      return proto ? proto + ":" : proto;
    },
    set: function(v) {
      if (typeof v === "string") {
        var end = v.length - 1;
        if (v.charCodeAt(end) === 58) {
          this._protocol = v.slice(0, end);
        } else {
          this._protocol = v;
        }
      } else if (v == null) {
        this._protocol = null;
      }
    }
  });
  Object.defineProperty(Url.prototype, "href", {
    get: function() {
      var href = this._href;
      if (!href) {
        href = this._href = this.format();
      }
      return href;
    },
    set: function(v) {
      this._href = v;
    }
  });
  Url.parse = function Url$Parse(str, parseQueryString, hostDenotesSlash, disableAutoEscapeChars) {
    if (str instanceof Url)
      return str;
    var ret = new Url;
    ret.parse(str, !!parseQueryString, !!hostDenotesSlash, !!disableAutoEscapeChars);
    return ret;
  };
  Url.format = function Url$Format(obj) {
    if (typeof obj === "string") {
      obj = Url.parse(obj);
    }
    if (!(obj instanceof Url)) {
      return Url.prototype.format.call(obj);
    }
    return obj.format();
  };
  Url.resolve = function Url$Resolve(source2, relative2) {
    return Url.parse(source2, false, true).resolve(relative2);
  };
  Url.resolveObject = function Url$ResolveObject(source2, relative2) {
    if (!source2)
      return relative2;
    return Url.parse(source2, false, true).resolveObject(relative2);
  };
  var autoEscape = [
    "<",
    ">",
    "\"",
    "`",
    " ",
    "\r",
    "\n",
    "\t",
    "{",
    "}",
    "|",
    "\\",
    "^",
    "`",
    "'"
  ];
  var autoEscapeMap = new Array(128);
  for (i = 0, len = autoEscapeMap.length;i < len; ++i) {
    autoEscapeMap[i] = "";
  }
  var i;
  var len;
  for (i = 0, len = autoEscape.length;i < len; ++i) {
    c = autoEscape[i];
    esc = encodeURIComponent(c);
    if (esc === c) {
      esc = escape(c);
    }
    autoEscapeMap[c.charCodeAt(0)] = esc;
  }
  var c;
  var esc;
  var i;
  var len;
  var afterQueryAutoEscapeMap = autoEscapeMap.slice();
  autoEscapeMap[92] = "/";
  var slashProtocols = Url.prototype._slashProtocols = {
    http: true,
    https: true,
    gopher: true,
    file: true,
    ftp: true,
    "http:": true,
    "https:": true,
    "gopher:": true,
    "file:": true,
    "ftp:": true
  };
  f.prototype = slashProtocols;
  Url.prototype._protocolCharacters = makeAsciiTable([
    [97, 122],
    [65, 90],
    46,
    43,
    45
  ]);
  Url.prototype._hostEndingCharacters = makeAsciiTable([
    35,
    63,
    47,
    92
  ]);
  Url.prototype._autoEscapeCharacters = makeAsciiTable(autoEscape.map(function(v) {
    return v.charCodeAt(0);
  }));
  Url.prototype._noPrependSlashHostEnders = makeAsciiTable([
    "<",
    ">",
    "'",
    "`",
    " ",
    "\r",
    "\n",
    "\t",
    "{",
    "}",
    "|",
    "^",
    "`",
    "\"",
    "%",
    ";"
  ].map(function(v) {
    return v.charCodeAt(0);
  }));
  Url.prototype._autoEscapeMap = autoEscapeMap;
  Url.prototype._afterQueryAutoEscapeMap = afterQueryAutoEscapeMap;
  module.exports = Url;
  Url.replace = function Url$Replace() {
    require.cache.url = {
      exports: Url
    };
  };
});

// node_modules/@whatwg-node/node-fetch/cjs/URLSearchParams.js
var require_URLSearchParams = __commonJS((exports) => {
  var isURLSearchParams = function(value) {
    return value?.entries != null;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.PonyfillURLSearchParams = undefined;
  var tslib_1 = require_tslib();
  var fast_querystring_1 = tslib_1.__importDefault(require_lib2());

  class PonyfillURLSearchParams {
    constructor(init) {
      if (init) {
        if (typeof init === "string") {
          this.params = fast_querystring_1.default.parse(init);
        } else if (Array.isArray(init)) {
          this.params = {};
          for (const [key, value] of init) {
            this.params[key] = value;
          }
        } else if (isURLSearchParams(init)) {
          this.params = {};
          for (const [key, value] of init.entries()) {
            this.params[key] = value;
          }
        } else {
          this.params = init;
        }
      } else {
        this.params = {};
      }
    }
    append(name4, value) {
      const existingValue = this.params[name4];
      const finalValue = existingValue ? `${existingValue},${value}` : value;
      this.params[name4] = finalValue;
    }
    delete(name4) {
      delete this.params[name4];
    }
    get(name4) {
      const value = this.params[name4];
      if (Array.isArray(value)) {
        return value[0] || null;
      }
      return value || null;
    }
    getAll(name4) {
      const value = this.params[name4];
      if (!Array.isArray(value)) {
        return value ? [value] : [];
      }
      return value;
    }
    has(name4) {
      return name4 in this.params;
    }
    set(name4, value) {
      this.params[name4] = value;
    }
    sort() {
      const sortedKeys = Object.keys(this.params).sort();
      const sortedParams = {};
      for (const key of sortedKeys) {
        sortedParams[key] = this.params[key];
      }
      this.params = sortedParams;
    }
    toString() {
      return fast_querystring_1.default.stringify(this.params);
    }
    *keys() {
      for (const key in this.params) {
        yield key;
      }
    }
    *entries() {
      for (const key of this.keys()) {
        const value = this.params[key];
        if (Array.isArray(value)) {
          for (const item2 of value) {
            yield [key, item2];
          }
        } else {
          yield [key, value];
        }
      }
    }
    *values() {
      for (const [, value] of this) {
        yield value;
      }
    }
    [Symbol.iterator]() {
      return this.entries();
    }
    forEach(callback) {
      for (const [key, value] of this) {
        callback(value, key, this);
      }
    }
    get size() {
      return Object.keys(this.params).length;
    }
  }
  exports.PonyfillURLSearchParams = PonyfillURLSearchParams;
});

// node_modules/@whatwg-node/node-fetch/cjs/URL.js
var require_URL = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.PonyfillURL = undefined;
  var tslib_1 = require_tslib();
  var fast_querystring_1 = tslib_1.__importDefault(require_lib2());
  var fast_url_parser_1 = tslib_1.__importDefault(require_urlparser());
  var URLSearchParams_js_1 = require_URLSearchParams();
  fast_url_parser_1.default.queryString = fast_querystring_1.default;

  class PonyfillURL extends fast_url_parser_1.default {
    constructor(url, base) {
      super();
      if (url.startsWith("data:")) {
        this.protocol = "data:";
        this.pathname = url.slice("data:".length);
        return;
      }
      this.parse(url, false);
      if (base) {
        const baseParsed = typeof base === "string" ? new PonyfillURL(base) : base;
        this.protocol = this.protocol || baseParsed.protocol;
        this.host = this.host || baseParsed.host;
        this.pathname = this.pathname || baseParsed.pathname;
      }
    }
    get origin() {
      return `${this.protocol}//${this.host}`;
    }
    get searchParams() {
      if (!this._searchParams) {
        this._searchParams = new URLSearchParams_js_1.PonyfillURLSearchParams(this.query);
      }
      return this._searchParams;
    }
    get username() {
      return this.auth?.split(":")[0] || "";
    }
    set username(value) {
      this.auth = `${value}:${this.password}`;
    }
    get password() {
      return this.auth?.split(":")[1] || "";
    }
    set password(value) {
      this.auth = `${this.username}:${value}`;
    }
    toString() {
      return this.format();
    }
    toJSON() {
      return this.toString();
    }
  }
  exports.PonyfillURL = PonyfillURL;
});

// node_modules/@whatwg-node/node-fetch/cjs/fetchNodeHttp.js
var require_fetchNodeHttp = __commonJS((exports) => {
  var getRequestFnForProtocol = function(url) {
    if (url.startsWith("http:")) {
      return http_1.request;
    } else if (url.startsWith("https:")) {
      return https_1.request;
    }
    throw new Error(`Unsupported protocol: ${url.split(":")[0] || url}`);
  };
  var fetchNodeHttp = function(fetchRequest) {
    return new Promise((resolve, reject) => {
      try {
        const requestFn = getRequestFnForProtocol(fetchRequest.url);
        const nodeReadable = fetchRequest.body != null ? (0, utils_js_1.isNodeReadable)(fetchRequest.body) ? fetchRequest.body : stream_1.Readable.from(fetchRequest.body) : null;
        const headersSerializer = fetchRequest.headersSerializer || utils_js_1.getHeadersObj;
        const nodeHeaders = headersSerializer(fetchRequest.headers);
        const nodeRequest = requestFn(fetchRequest.url, {
          method: fetchRequest.method,
          headers: nodeHeaders,
          signal: fetchRequest["_signal"] ?? undefined,
          agent: fetchRequest.agent
        });
        fetchRequest["_signal"]?.addEventListener("abort", () => {
          if (!nodeRequest.aborted) {
            nodeRequest.abort();
          }
        });
        nodeRequest.once("abort", (reason) => {
          reject(new AbortError_js_1.PonyfillAbortError(reason));
        });
        nodeRequest.once("response", (nodeResponse) => {
          let responseBody = nodeResponse;
          const contentEncoding = nodeResponse.headers["content-encoding"];
          switch (contentEncoding) {
            case "x-gzip":
            case "gzip":
              responseBody = nodeResponse.pipe((0, zlib_1.createGunzip)());
              break;
            case "x-deflate":
            case "deflate":
              responseBody = nodeResponse.pipe((0, zlib_1.createInflate)());
              break;
            case "br":
              responseBody = nodeResponse.pipe((0, zlib_1.createBrotliDecompress)());
              break;
          }
          if (nodeResponse.headers.location) {
            if (fetchRequest.redirect === "error") {
              const redirectError = new Error("Redirects are not allowed");
              reject(redirectError);
              nodeResponse.resume();
              return;
            }
            if (fetchRequest.redirect === "follow") {
              const redirectedUrl = new URL_js_1.PonyfillURL(nodeResponse.headers.location, fetchRequest.url);
              const redirectResponse$ = fetchNodeHttp(new Request_js_1.PonyfillRequest(redirectedUrl, fetchRequest));
              resolve(redirectResponse$.then((redirectResponse) => {
                redirectResponse.redirected = true;
                return redirectResponse;
              }));
              nodeResponse.resume();
              return;
            }
          }
          const ponyfillResponse = new Response_js_1.PonyfillResponse(responseBody, {
            status: nodeResponse.statusCode,
            statusText: nodeResponse.statusMessage,
            headers: nodeResponse.headers,
            url: fetchRequest.url
          });
          resolve(ponyfillResponse);
        });
        nodeRequest.once("error", reject);
        if (nodeReadable) {
          nodeReadable.pipe(nodeRequest);
        } else {
          nodeRequest.end();
        }
      } catch (e) {
        reject(e);
      }
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.fetchNodeHttp = undefined;
  var http_1 = import.meta.require("http");
  var https_1 = import.meta.require("https");
  var stream_1 = import.meta.require("stream");
  var zlib_1 = import.meta.require("zlib");
  var AbortError_js_1 = require_AbortError();
  var Request_js_1 = require_Request();
  var Response_js_1 = require_Response();
  var URL_js_1 = require_URL();
  var utils_js_1 = require_utils2();
  exports.fetchNodeHttp = fetchNodeHttp;
});

// node_modules/@whatwg-node/node-fetch/cjs/fetch.js
var require_fetch = __commonJS((exports) => {
  var getResponseForFile = function(url) {
    const path5 = (0, url_1.fileURLToPath)(url);
    const readable = (0, fs_1.createReadStream)(path5);
    return new Response_js_1.PonyfillResponse(readable);
  };
  var getResponseForDataUri = function(url) {
    const [mimeType = "text/plain", ...datas] = url.substring(5).split(",");
    const data = decodeURIComponent(datas.join(","));
    if (mimeType.endsWith(BASE64_SUFFIX)) {
      const buffer = Buffer.from(data, "base64url");
      const realMimeType = mimeType.slice(0, -BASE64_SUFFIX.length);
      return new Response_js_1.PonyfillResponse(buffer, {
        status: 200,
        statusText: "OK",
        headers: {
          "content-type": realMimeType
        }
      });
    }
    return new Response_js_1.PonyfillResponse(data, {
      status: 200,
      statusText: "OK",
      headers: {
        "content-type": mimeType
      }
    });
  };
  var isURL = function(obj) {
    return obj != null && obj.href != null;
  };
  var fetchPonyfill = function(info, init) {
    if (typeof info === "string" || isURL(info)) {
      const ponyfillRequest = new Request_js_1.PonyfillRequest(info, init);
      return fetchPonyfill(ponyfillRequest);
    }
    const fetchRequest = info;
    if (fetchRequest.url.startsWith("data:")) {
      const response = getResponseForDataUri(fetchRequest.url);
      return (0, utils_js_1.fakePromise)(response);
    }
    if (fetchRequest.url.startsWith("file:")) {
      const response = getResponseForFile(fetchRequest.url);
      return (0, utils_js_1.fakePromise)(response);
    }
    if (globalThis.libcurl) {
      return (0, fetchCurl_js_1.fetchCurl)(fetchRequest);
    }
    return (0, fetchNodeHttp_js_1.fetchNodeHttp)(fetchRequest);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.fetchPonyfill = undefined;
  var fs_1 = import.meta.require("fs");
  var url_1 = import.meta.require("url");
  var fetchCurl_js_1 = require_fetchCurl();
  var fetchNodeHttp_js_1 = require_fetchNodeHttp();
  var Request_js_1 = require_Request();
  var Response_js_1 = require_Response();
  var utils_js_1 = require_utils2();
  var BASE64_SUFFIX = ";base64";
  exports.fetchPonyfill = fetchPonyfill;
});

// node_modules/@whatwg-node/node-fetch/cjs/TextEncoderDecoder.js
var require_TextEncoderDecoder = __commonJS((exports) => {
  var PonyfillBtoa = function(input) {
    return Buffer.from(input, "binary").toString("base64");
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.PonyfillBtoa = exports.PonyfillTextDecoder = exports.PonyfillTextEncoder = undefined;
  var utils_js_1 = require_utils2();

  class PonyfillTextEncoder {
    constructor(encoding = "utf-8") {
      this.encoding = encoding;
    }
    encode(input) {
      return Buffer.from(input, this.encoding);
    }
    encodeInto(source2, destination) {
      const buffer = this.encode(source2);
      const copied = buffer.copy(destination);
      return {
        read: copied,
        written: copied
      };
    }
  }
  exports.PonyfillTextEncoder = PonyfillTextEncoder;

  class PonyfillTextDecoder {
    constructor(encoding = "utf-8", options) {
      this.encoding = encoding;
      this.fatal = false;
      this.ignoreBOM = false;
      if (options) {
        this.fatal = options.fatal || false;
        this.ignoreBOM = options.ignoreBOM || false;
      }
    }
    decode(input) {
      if (Buffer.isBuffer(input)) {
        return input.toString(this.encoding);
      }
      if ((0, utils_js_1.isArrayBufferView)(input)) {
        return Buffer.from(input.buffer, input.byteOffset, input.byteLength).toString(this.encoding);
      }
      return Buffer.from(input).toString(this.encoding);
    }
  }
  exports.PonyfillTextDecoder = PonyfillTextDecoder;
  exports.PonyfillBtoa = PonyfillBtoa;
});

// node_modules/@whatwg-node/node-fetch/cjs/index.js
var require_cjs = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.URLSearchParams = exports.URL = exports.btoa = exports.TextDecoder = exports.TextEncoder = exports.Blob = exports.FormData = exports.File = exports.ReadableStream = exports.Response = exports.Request = exports.Body = exports.Headers = exports.fetch = undefined;
  var fetch_js_1 = require_fetch();
  Object.defineProperty(exports, "fetch", { enumerable: true, get: function() {
    return fetch_js_1.fetchPonyfill;
  } });
  var Headers_js_1 = require_Headers();
  Object.defineProperty(exports, "Headers", { enumerable: true, get: function() {
    return Headers_js_1.PonyfillHeaders;
  } });
  var Body_js_1 = require_Body();
  Object.defineProperty(exports, "Body", { enumerable: true, get: function() {
    return Body_js_1.PonyfillBody;
  } });
  var Request_js_1 = require_Request();
  Object.defineProperty(exports, "Request", { enumerable: true, get: function() {
    return Request_js_1.PonyfillRequest;
  } });
  var Response_js_1 = require_Response();
  Object.defineProperty(exports, "Response", { enumerable: true, get: function() {
    return Response_js_1.PonyfillResponse;
  } });
  var ReadableStream_js_1 = require_ReadableStream();
  Object.defineProperty(exports, "ReadableStream", { enumerable: true, get: function() {
    return ReadableStream_js_1.PonyfillReadableStream;
  } });
  var File_js_1 = require_File();
  Object.defineProperty(exports, "File", { enumerable: true, get: function() {
    return File_js_1.PonyfillFile;
  } });
  var FormData_js_1 = require_FormData();
  Object.defineProperty(exports, "FormData", { enumerable: true, get: function() {
    return FormData_js_1.PonyfillFormData;
  } });
  var Blob_js_1 = require_Blob();
  Object.defineProperty(exports, "Blob", { enumerable: true, get: function() {
    return Blob_js_1.PonyfillBlob;
  } });
  var TextEncoderDecoder_js_1 = require_TextEncoderDecoder();
  Object.defineProperty(exports, "TextEncoder", { enumerable: true, get: function() {
    return TextEncoderDecoder_js_1.PonyfillTextEncoder;
  } });
  Object.defineProperty(exports, "TextDecoder", { enumerable: true, get: function() {
    return TextEncoderDecoder_js_1.PonyfillTextDecoder;
  } });
  Object.defineProperty(exports, "btoa", { enumerable: true, get: function() {
    return TextEncoderDecoder_js_1.PonyfillBtoa;
  } });
  var URL_js_1 = require_URL();
  Object.defineProperty(exports, "URL", { enumerable: true, get: function() {
    return URL_js_1.PonyfillURL;
  } });
  var URLSearchParams_js_1 = require_URLSearchParams();
  Object.defineProperty(exports, "URLSearchParams", { enumerable: true, get: function() {
    return URLSearchParams_js_1.PonyfillURLSearchParams;
  } });
});

// node_modules/@whatwg-node/fetch/dist/create-node-ponyfill.js
var require_create_node_ponyfill = __commonJS((exports, module) => {
  module.exports = function createNodePonyfill(opts = {}) {
    const ponyfills = {};
    if (!ponyfills.URLPattern) {
      const urlPatternModule = require_urlpattern_polyfill();
      ponyfills.URLPattern = urlPatternModule.URLPattern;
    }
    if (globalThis.Deno || process.versions.bun) {
      return globalThis;
    }
    const newNodeFetch = require_cjs();
    ponyfills.fetch = newNodeFetch.fetch;
    ponyfills.Request = newNodeFetch.Request;
    ponyfills.Response = newNodeFetch.Response;
    ponyfills.Headers = newNodeFetch.Headers;
    ponyfills.FormData = newNodeFetch.FormData;
    ponyfills.ReadableStream = newNodeFetch.ReadableStream;
    ponyfills.URL = newNodeFetch.URL;
    ponyfills.URLSearchParams = newNodeFetch.URLSearchParams;
    ponyfills.WritableStream = globalThis.WritableStream;
    ponyfills.TransformStream = globalThis.TransformStream;
    if (!ponyfills.WritableStream) {
      const streamsWeb = import.meta.require("stream/web");
      ponyfills.WritableStream = streamsWeb.WritableStream;
      ponyfills.TransformStream = streamsWeb.TransformStream;
    }
    ponyfills.Blob = newNodeFetch.Blob;
    ponyfills.File = newNodeFetch.File;
    ponyfills.crypto = globalThis.crypto;
    ponyfills.btoa = newNodeFetch.btoa;
    ponyfills.TextEncoder = newNodeFetch.TextEncoder;
    ponyfills.TextDecoder = newNodeFetch.TextDecoder;
    if (opts.formDataLimits) {
      ponyfills.Body = class Body extends newNodeFetch.Body {
        constructor(body, userOpts) {
          super(body, {
            formDataLimits: opts.formDataLimits,
            ...userOpts
          });
        }
      };
      ponyfills.Request = class Request extends newNodeFetch.Request {
        constructor(input, userOpts) {
          super(input, {
            formDataLimits: opts.formDataLimits,
            ...userOpts
          });
        }
      };
      ponyfills.Response = class Response extends newNodeFetch.Response {
        constructor(body, userOpts) {
          super(body, {
            formDataLimits: opts.formDataLimits,
            ...userOpts
          });
        }
      };
    }
    if (!ponyfills.crypto) {
      const cryptoModule = import.meta.require("crypto");
      ponyfills.crypto = cryptoModule.webcrypto;
    }
    return ponyfills;
  };
});

// node_modules/nexus/dist-esm/messages.js
var messages = {
  removedDeclarativeWrapping: (location2, used) => `[declarativeWrappingPlugin]: The ${used.join(" / ")} object prop${used.length > 1 ? "s" : ""} used in the ${location2} has been
moved to a plugin, as improved chaining APIs and the list() / nonNull() helpers functions are preferred.

On Fields: 

t.string('someField', { nullable: false })   ->    t.nonNull.string('someField')

On args: 

stringArg({ required: true })    ->    nonNull(stringArg())

If you would like to incrementally migrate, or prefer the existing API, it is now supported via the declarativeWrappingPlugin. 
Add this to your plugins array in your makeSchema config:

makeSchema({
  plugins: [declarativeWrappingPlugin(), ...]
})
`,
  removedDeclarativeWrappingShort: (location2, used) => `[declarativeWrappingPlugin]: Additional warning for ${used.join(" / ")} at ${location2}. Add the declarativeWrappingPlugin() to the plugins array to disable this message.
`,
  removedFunctionShorthand: (typeName, fieldName) => `Since v0.18.0, Nexus no longer supports resolver shorthands like:\n\n    t.string("${fieldName}", () => ...).\n\nInstead please write:\n\n    t.string("${fieldName}", { resolve: () => ... })\n\n.`
};

// node_modules/nexus/dist-esm/definitions/definitionBlocks.js
class OutputDefinitionBlock {
  constructor(typeBuilder, wrapping) {
    this.typeBuilder = typeBuilder;
    this.wrapping = wrapping;
    this.typeName = typeBuilder.typeName;
    this.typeBuilder.addDynamicOutputMembers(this, this.wrapping);
  }
  get list() {
    return this._wrapClass("List");
  }
  get nonNull() {
    return this._wrapClass("NonNull");
  }
  get nullable() {
    return this._wrapClass("Null");
  }
  boolean(name, ...config) {
    this.addScalarField(name, "Boolean", config);
  }
  string(name, ...config) {
    this.addScalarField(name, "String", config);
  }
  id(name, ...config) {
    this.addScalarField(name, "ID", config);
  }
  int(name, ...config) {
    this.addScalarField(name, "Int", config);
  }
  float(name, ...config) {
    this.addScalarField(name, "Float", config);
  }
  field(...args) {
    const config = args.length === 2 ? Object.assign({ name: args[0] }, args[1]) : args[0];
    this.typeBuilder.addField(Object.assign(Object.assign({}, config), { configFor: "outputField", wrapping: this.wrapping, parentType: this.typeName }));
  }
  _wrapClass(kind) {
    var _a;
    const previousWrapping = (_a = this.wrapping) === null || _a === undefined ? undefined : _a[0];
    if ((kind === "NonNull" || kind === "Null") && (previousWrapping === "NonNull" || previousWrapping === "Null")) {
      return new OutputDefinitionBlock(this.typeBuilder, this.wrapping || []);
    }
    return new OutputDefinitionBlock(this.typeBuilder, [kind].concat(this.wrapping || []));
  }
  addScalarField(fieldName, typeName, opts) {
    let fieldConfig = {
      type: typeName
    };
    if (typeof opts[0] === "function") {
      throw new Error(messages.removedFunctionShorthand(typeName, fieldName));
    } else {
      fieldConfig = Object.assign(Object.assign({}, fieldConfig), opts[0]);
    }
    this.field(fieldName, fieldConfig);
  }
}

class InputDefinitionBlock {
  constructor(typeBuilder, wrapping) {
    this.typeBuilder = typeBuilder;
    this.wrapping = wrapping;
    this.typeName = typeBuilder.typeName;
    this.typeBuilder.addDynamicInputFields(this, this.wrapping);
  }
  get list() {
    return this._wrapClass("List");
  }
  get nonNull() {
    return this._wrapClass("NonNull");
  }
  get nullable() {
    return this._wrapClass("Null");
  }
  string(fieldName, config) {
    this.field(fieldName, Object.assign(Object.assign({}, config), { type: "String" }));
  }
  int(fieldName, config) {
    this.field(fieldName, Object.assign(Object.assign({}, config), { type: "Int" }));
  }
  boolean(fieldName, opts) {
    this.field(fieldName, Object.assign(Object.assign({}, opts), { type: "Boolean" }));
  }
  id(fieldName, config) {
    this.field(fieldName, Object.assign(Object.assign({}, config), { type: "ID" }));
  }
  float(fieldName, config) {
    this.field(fieldName, Object.assign(Object.assign({}, config), { type: "Float" }));
  }
  field(...args) {
    const config = args.length === 2 ? Object.assign({ name: args[0] }, args[1]) : args[0];
    this.typeBuilder.addField(Object.assign(Object.assign({}, config), { wrapping: this.wrapping, parentType: this.typeName, configFor: "inputField" }));
  }
  _wrapClass(kind) {
    var _a;
    const previousWrapping = (_a = this.wrapping) === null || _a === undefined ? undefined : _a[0];
    if ((kind === "NonNull" || kind === "Null") && (previousWrapping === "NonNull" || previousWrapping === "Null")) {
      return new InputDefinitionBlock(this.typeBuilder, this.wrapping || []);
    }
    return new InputDefinitionBlock(this.typeBuilder, [kind].concat(this.wrapping || []));
  }
}
// node_modules/graphql/version.mjs
var versionInfo = Object.freeze({
  major: 16,
  minor: 8,
  patch: 1,
  preReleaseTag: null
});
// node_modules/graphql/jsutils/devAssert.mjs
function devAssert(condition, message) {
  const booleanCondition = Boolean(condition);
  if (!booleanCondition) {
    throw new Error(message);
  }
}

// node_modules/graphql/jsutils/isPromise.mjs
function isPromise(value) {
  return typeof (value === null || value === undefined ? undefined : value.then) === "function";
}

// node_modules/graphql/jsutils/isObjectLike.mjs
function isObjectLike(value) {
  return typeof value == "object" && value !== null;
}

// node_modules/graphql/jsutils/invariant.mjs
function invariant(condition, message) {
  const booleanCondition = Boolean(condition);
  if (!booleanCondition) {
    throw new Error(message != null ? message : "Unexpected invariant triggered.");
  }
}

// node_modules/graphql/language/location.mjs
function getLocation(source, position) {
  let lastLineStart = 0;
  let line = 1;
  for (const match of source.body.matchAll(LineRegExp)) {
    typeof match.index === "number" || invariant(false);
    if (match.index >= position) {
      break;
    }
    lastLineStart = match.index + match[0].length;
    line += 1;
  }
  return {
    line,
    column: position + 1 - lastLineStart
  };
}
var LineRegExp = /\r\n|[\n\r]/g;

// node_modules/graphql/language/printLocation.mjs
function printLocation(location3) {
  return printSourceLocation(location3.source, getLocation(location3.source, location3.start));
}
function printSourceLocation(source, sourceLocation) {
  const firstLineColumnOffset = source.locationOffset.column - 1;
  const body = "".padStart(firstLineColumnOffset) + source.body;
  const lineIndex = sourceLocation.line - 1;
  const lineOffset = source.locationOffset.line - 1;
  const lineNum = sourceLocation.line + lineOffset;
  const columnOffset = sourceLocation.line === 1 ? firstLineColumnOffset : 0;
  const columnNum = sourceLocation.column + columnOffset;
  const locationStr = `${source.name}:${lineNum}:${columnNum}\n`;
  const lines = body.split(/\r\n|[\n\r]/g);
  const locationLine = lines[lineIndex];
  if (locationLine.length > 120) {
    const subLineIndex = Math.floor(columnNum / 80);
    const subLineColumnNum = columnNum % 80;
    const subLines = [];
    for (let i = 0;i < locationLine.length; i += 80) {
      subLines.push(locationLine.slice(i, i + 80));
    }
    return locationStr + printPrefixedLines([
      [`${lineNum} |`, subLines[0]],
      ...subLines.slice(1, subLineIndex + 1).map((subLine) => ["|", subLine]),
      ["|", "^".padStart(subLineColumnNum)],
      ["|", subLines[subLineIndex + 1]]
    ]);
  }
  return locationStr + printPrefixedLines([
    [`${lineNum - 1} |`, lines[lineIndex - 1]],
    [`${lineNum} |`, locationLine],
    ["|", "^".padStart(columnNum)],
    [`${lineNum + 1} |`, lines[lineIndex + 1]]
  ]);
}
var printPrefixedLines = function(lines) {
  const existingLines = lines.filter(([_, line]) => line !== undefined);
  const padLen = Math.max(...existingLines.map(([prefix]) => prefix.length));
  return existingLines.map(([prefix, line]) => prefix.padStart(padLen) + (line ? " " + line : "")).join("\n");
};

// node_modules/graphql/error/GraphQLError.mjs
var toNormalizedOptions = function(args) {
  const firstArg = args[0];
  if (firstArg == null || ("kind" in firstArg) || ("length" in firstArg)) {
    return {
      nodes: firstArg,
      source: args[1],
      positions: args[2],
      path: args[3],
      originalError: args[4],
      extensions: args[5]
    };
  }
  return firstArg;
};
var undefinedIfEmpty = function(array) {
  return array === undefined || array.length === 0 ? undefined : array;
};
class GraphQLError extends Error {
  constructor(message, ...rawArgs) {
    var _this$nodes, _nodeLocations$, _ref;
    const { nodes, source, positions, path, originalError, extensions } = toNormalizedOptions(rawArgs);
    super(message);
    this.name = "GraphQLError";
    this.path = path !== null && path !== undefined ? path : undefined;
    this.originalError = originalError !== null && originalError !== undefined ? originalError : undefined;
    this.nodes = undefinedIfEmpty(Array.isArray(nodes) ? nodes : nodes ? [nodes] : undefined);
    const nodeLocations = undefinedIfEmpty((_this$nodes = this.nodes) === null || _this$nodes === undefined ? undefined : _this$nodes.map((node) => node.loc).filter((loc) => loc != null));
    this.source = source !== null && source !== undefined ? source : nodeLocations === null || nodeLocations === undefined ? undefined : (_nodeLocations$ = nodeLocations[0]) === null || _nodeLocations$ === undefined ? undefined : _nodeLocations$.source;
    this.positions = positions !== null && positions !== undefined ? positions : nodeLocations === null || nodeLocations === undefined ? undefined : nodeLocations.map((loc) => loc.start);
    this.locations = positions && source ? positions.map((pos) => getLocation(source, pos)) : nodeLocations === null || nodeLocations === undefined ? undefined : nodeLocations.map((loc) => getLocation(loc.source, loc.start));
    const originalExtensions = isObjectLike(originalError === null || originalError === undefined ? undefined : originalError.extensions) ? originalError === null || originalError === undefined ? undefined : originalError.extensions : undefined;
    this.extensions = (_ref = extensions !== null && extensions !== undefined ? extensions : originalExtensions) !== null && _ref !== undefined ? _ref : Object.create(null);
    Object.defineProperties(this, {
      message: {
        writable: true,
        enumerable: true
      },
      name: {
        enumerable: false
      },
      nodes: {
        enumerable: false
      },
      source: {
        enumerable: false
      },
      positions: {
        enumerable: false
      },
      originalError: {
        enumerable: false
      }
    });
    if (originalError !== null && originalError !== undefined && originalError.stack) {
      Object.defineProperty(this, "stack", {
        value: originalError.stack,
        writable: true,
        configurable: true
      });
    } else if (Error.captureStackTrace) {
      Error.captureStackTrace(this, GraphQLError);
    } else {
      Object.defineProperty(this, "stack", {
        value: Error().stack,
        writable: true,
        configurable: true
      });
    }
  }
  get [Symbol.toStringTag]() {
    return "GraphQLError";
  }
  toString() {
    let output = this.message;
    if (this.nodes) {
      for (const node of this.nodes) {
        if (node.loc) {
          output += "\n\n" + printLocation(node.loc);
        }
      }
    } else if (this.source && this.locations) {
      for (const location4 of this.locations) {
        output += "\n\n" + printSourceLocation(this.source, location4);
      }
    }
    return output;
  }
  toJSON() {
    const formattedError = {
      message: this.message
    };
    if (this.locations != null) {
      formattedError.locations = this.locations;
    }
    if (this.path != null) {
      formattedError.path = this.path;
    }
    if (this.extensions != null && Object.keys(this.extensions).length > 0) {
      formattedError.extensions = this.extensions;
    }
    return formattedError;
  }
}

// node_modules/graphql/error/syntaxError.mjs
function syntaxError(source, position, description) {
  return new GraphQLError(`Syntax Error: ${description}`, {
    source,
    positions: [position]
  });
}

// node_modules/graphql/language/ast.mjs
function isNode(maybeNode) {
  const maybeKind = maybeNode === null || maybeNode === undefined ? undefined : maybeNode.kind;
  return typeof maybeKind === "string" && kindValues.has(maybeKind);
}

class Location {
  constructor(startToken, endToken, source) {
    this.start = startToken.start;
    this.end = endToken.end;
    this.startToken = startToken;
    this.endToken = endToken;
    this.source = source;
  }
  get [Symbol.toStringTag]() {
    return "Location";
  }
  toJSON() {
    return {
      start: this.start,
      end: this.end
    };
  }
}

class Token {
  constructor(kind, start, end, line, column, value) {
    this.kind = kind;
    this.start = start;
    this.end = end;
    this.line = line;
    this.column = column;
    this.value = value;
    this.prev = null;
    this.next = null;
  }
  get [Symbol.toStringTag]() {
    return "Token";
  }
  toJSON() {
    return {
      kind: this.kind,
      value: this.value,
      line: this.line,
      column: this.column
    };
  }
}
var QueryDocumentKeys = {
  Name: [],
  Document: ["definitions"],
  OperationDefinition: [
    "name",
    "variableDefinitions",
    "directives",
    "selectionSet"
  ],
  VariableDefinition: ["variable", "type", "defaultValue", "directives"],
  Variable: ["name"],
  SelectionSet: ["selections"],
  Field: ["alias", "name", "arguments", "directives", "selectionSet"],
  Argument: ["name", "value"],
  FragmentSpread: ["name", "directives"],
  InlineFragment: ["typeCondition", "directives", "selectionSet"],
  FragmentDefinition: [
    "name",
    "variableDefinitions",
    "typeCondition",
    "directives",
    "selectionSet"
  ],
  IntValue: [],
  FloatValue: [],
  StringValue: [],
  BooleanValue: [],
  NullValue: [],
  EnumValue: [],
  ListValue: ["values"],
  ObjectValue: ["fields"],
  ObjectField: ["name", "value"],
  Directive: ["name", "arguments"],
  NamedType: ["name"],
  ListType: ["type"],
  NonNullType: ["type"],
  SchemaDefinition: ["description", "directives", "operationTypes"],
  OperationTypeDefinition: ["type"],
  ScalarTypeDefinition: ["description", "name", "directives"],
  ObjectTypeDefinition: [
    "description",
    "name",
    "interfaces",
    "directives",
    "fields"
  ],
  FieldDefinition: ["description", "name", "arguments", "type", "directives"],
  InputValueDefinition: [
    "description",
    "name",
    "type",
    "defaultValue",
    "directives"
  ],
  InterfaceTypeDefinition: [
    "description",
    "name",
    "interfaces",
    "directives",
    "fields"
  ],
  UnionTypeDefinition: ["description", "name", "directives", "types"],
  EnumTypeDefinition: ["description", "name", "directives", "values"],
  EnumValueDefinition: ["description", "name", "directives"],
  InputObjectTypeDefinition: ["description", "name", "directives", "fields"],
  DirectiveDefinition: ["description", "name", "arguments", "locations"],
  SchemaExtension: ["directives", "operationTypes"],
  ScalarTypeExtension: ["name", "directives"],
  ObjectTypeExtension: ["name", "interfaces", "directives", "fields"],
  InterfaceTypeExtension: ["name", "interfaces", "directives", "fields"],
  UnionTypeExtension: ["name", "directives", "types"],
  EnumTypeExtension: ["name", "directives", "values"],
  InputObjectTypeExtension: ["name", "directives", "fields"]
};
var kindValues = new Set(Object.keys(QueryDocumentKeys));
var OperationTypeNode;
(function(OperationTypeNode2) {
  OperationTypeNode2["QUERY"] = "query";
  OperationTypeNode2["MUTATION"] = "mutation";
  OperationTypeNode2["SUBSCRIPTION"] = "subscription";
})(OperationTypeNode || (OperationTypeNode = {}));

// node_modules/graphql/language/directiveLocation.mjs
var DirectiveLocation;
(function(DirectiveLocation2) {
  DirectiveLocation2["QUERY"] = "QUERY";
  DirectiveLocation2["MUTATION"] = "MUTATION";
  DirectiveLocation2["SUBSCRIPTION"] = "SUBSCRIPTION";
  DirectiveLocation2["FIELD"] = "FIELD";
  DirectiveLocation2["FRAGMENT_DEFINITION"] = "FRAGMENT_DEFINITION";
  DirectiveLocation2["FRAGMENT_SPREAD"] = "FRAGMENT_SPREAD";
  DirectiveLocation2["INLINE_FRAGMENT"] = "INLINE_FRAGMENT";
  DirectiveLocation2["VARIABLE_DEFINITION"] = "VARIABLE_DEFINITION";
  DirectiveLocation2["SCHEMA"] = "SCHEMA";
  DirectiveLocation2["SCALAR"] = "SCALAR";
  DirectiveLocation2["OBJECT"] = "OBJECT";
  DirectiveLocation2["FIELD_DEFINITION"] = "FIELD_DEFINITION";
  DirectiveLocation2["ARGUMENT_DEFINITION"] = "ARGUMENT_DEFINITION";
  DirectiveLocation2["INTERFACE"] = "INTERFACE";
  DirectiveLocation2["UNION"] = "UNION";
  DirectiveLocation2["ENUM"] = "ENUM";
  DirectiveLocation2["ENUM_VALUE"] = "ENUM_VALUE";
  DirectiveLocation2["INPUT_OBJECT"] = "INPUT_OBJECT";
  DirectiveLocation2["INPUT_FIELD_DEFINITION"] = "INPUT_FIELD_DEFINITION";
})(DirectiveLocation || (DirectiveLocation = {}));

// node_modules/graphql/language/kinds.mjs
var Kind;
(function(Kind2) {
  Kind2["NAME"] = "Name";
  Kind2["DOCUMENT"] = "Document";
  Kind2["OPERATION_DEFINITION"] = "OperationDefinition";
  Kind2["VARIABLE_DEFINITION"] = "VariableDefinition";
  Kind2["SELECTION_SET"] = "SelectionSet";
  Kind2["FIELD"] = "Field";
  Kind2["ARGUMENT"] = "Argument";
  Kind2["FRAGMENT_SPREAD"] = "FragmentSpread";
  Kind2["INLINE_FRAGMENT"] = "InlineFragment";
  Kind2["FRAGMENT_DEFINITION"] = "FragmentDefinition";
  Kind2["VARIABLE"] = "Variable";
  Kind2["INT"] = "IntValue";
  Kind2["FLOAT"] = "FloatValue";
  Kind2["STRING"] = "StringValue";
  Kind2["BOOLEAN"] = "BooleanValue";
  Kind2["NULL"] = "NullValue";
  Kind2["ENUM"] = "EnumValue";
  Kind2["LIST"] = "ListValue";
  Kind2["OBJECT"] = "ObjectValue";
  Kind2["OBJECT_FIELD"] = "ObjectField";
  Kind2["DIRECTIVE"] = "Directive";
  Kind2["NAMED_TYPE"] = "NamedType";
  Kind2["LIST_TYPE"] = "ListType";
  Kind2["NON_NULL_TYPE"] = "NonNullType";
  Kind2["SCHEMA_DEFINITION"] = "SchemaDefinition";
  Kind2["OPERATION_TYPE_DEFINITION"] = "OperationTypeDefinition";
  Kind2["SCALAR_TYPE_DEFINITION"] = "ScalarTypeDefinition";
  Kind2["OBJECT_TYPE_DEFINITION"] = "ObjectTypeDefinition";
  Kind2["FIELD_DEFINITION"] = "FieldDefinition";
  Kind2["INPUT_VALUE_DEFINITION"] = "InputValueDefinition";
  Kind2["INTERFACE_TYPE_DEFINITION"] = "InterfaceTypeDefinition";
  Kind2["UNION_TYPE_DEFINITION"] = "UnionTypeDefinition";
  Kind2["ENUM_TYPE_DEFINITION"] = "EnumTypeDefinition";
  Kind2["ENUM_VALUE_DEFINITION"] = "EnumValueDefinition";
  Kind2["INPUT_OBJECT_TYPE_DEFINITION"] = "InputObjectTypeDefinition";
  Kind2["DIRECTIVE_DEFINITION"] = "DirectiveDefinition";
  Kind2["SCHEMA_EXTENSION"] = "SchemaExtension";
  Kind2["SCALAR_TYPE_EXTENSION"] = "ScalarTypeExtension";
  Kind2["OBJECT_TYPE_EXTENSION"] = "ObjectTypeExtension";
  Kind2["INTERFACE_TYPE_EXTENSION"] = "InterfaceTypeExtension";
  Kind2["UNION_TYPE_EXTENSION"] = "UnionTypeExtension";
  Kind2["ENUM_TYPE_EXTENSION"] = "EnumTypeExtension";
  Kind2["INPUT_OBJECT_TYPE_EXTENSION"] = "InputObjectTypeExtension";
})(Kind || (Kind = {}));

// node_modules/graphql/language/characterClasses.mjs
function isWhiteSpace(code) {
  return code === 9 || code === 32;
}
function isDigit(code) {
  return code >= 48 && code <= 57;
}
function isLetter(code) {
  return code >= 97 && code <= 122 || code >= 65 && code <= 90;
}
function isNameStart(code) {
  return isLetter(code) || code === 95;
}
function isNameContinue(code) {
  return isLetter(code) || isDigit(code) || code === 95;
}

// node_modules/graphql/language/blockString.mjs
function dedentBlockStringLines(lines) {
  var _firstNonEmptyLine2;
  let commonIndent = Number.MAX_SAFE_INTEGER;
  let firstNonEmptyLine = null;
  let lastNonEmptyLine = -1;
  for (let i = 0;i < lines.length; ++i) {
    var _firstNonEmptyLine;
    const line = lines[i];
    const indent = leadingWhitespace(line);
    if (indent === line.length) {
      continue;
    }
    firstNonEmptyLine = (_firstNonEmptyLine = firstNonEmptyLine) !== null && _firstNonEmptyLine !== undefined ? _firstNonEmptyLine : i;
    lastNonEmptyLine = i;
    if (i !== 0 && indent < commonIndent) {
      commonIndent = indent;
    }
  }
  return lines.map((line, i) => i === 0 ? line : line.slice(commonIndent)).slice((_firstNonEmptyLine2 = firstNonEmptyLine) !== null && _firstNonEmptyLine2 !== undefined ? _firstNonEmptyLine2 : 0, lastNonEmptyLine + 1);
}
var leadingWhitespace = function(str) {
  let i = 0;
  while (i < str.length && isWhiteSpace(str.charCodeAt(i))) {
    ++i;
  }
  return i;
};
function isPrintableAsBlockString(value) {
  if (value === "") {
    return true;
  }
  let isEmptyLine = true;
  let hasIndent = false;
  let hasCommonIndent = true;
  let seenNonEmptyLine = false;
  for (let i = 0;i < value.length; ++i) {
    switch (value.codePointAt(i)) {
      case 0:
      case 1:
      case 2:
      case 3:
      case 4:
      case 5:
      case 6:
      case 7:
      case 8:
      case 11:
      case 12:
      case 14:
      case 15:
        return false;
      case 13:
        return false;
      case 10:
        if (isEmptyLine && !seenNonEmptyLine) {
          return false;
        }
        seenNonEmptyLine = true;
        isEmptyLine = true;
        hasIndent = false;
        break;
      case 9:
      case 32:
        hasIndent || (hasIndent = isEmptyLine);
        break;
      default:
        hasCommonIndent && (hasCommonIndent = hasIndent);
        isEmptyLine = false;
    }
  }
  if (isEmptyLine) {
    return false;
  }
  if (hasCommonIndent && seenNonEmptyLine) {
    return false;
  }
  return true;
}
function printBlockString(value, options) {
  const escapedValue = value.replace(/"""/g, '\\"""');
  const lines = escapedValue.split(/\r\n|[\n\r]/g);
  const isSingleLine = lines.length === 1;
  const forceLeadingNewLine = lines.length > 1 && lines.slice(1).every((line) => line.length === 0 || isWhiteSpace(line.charCodeAt(0)));
  const hasTrailingTripleQuotes = escapedValue.endsWith('\\"""');
  const hasTrailingQuote = value.endsWith('"') && !hasTrailingTripleQuotes;
  const hasTrailingSlash = value.endsWith("\\");
  const forceTrailingNewline = hasTrailingQuote || hasTrailingSlash;
  const printAsMultipleLines = !(options !== null && options !== undefined && options.minimize) && (!isSingleLine || value.length > 70 || forceTrailingNewline || forceLeadingNewLine || hasTrailingTripleQuotes);
  let result = "";
  const skipLeadingNewLine = isSingleLine && isWhiteSpace(value.charCodeAt(0));
  if (printAsMultipleLines && !skipLeadingNewLine || forceLeadingNewLine) {
    result += "\n";
  }
  result += escapedValue;
  if (printAsMultipleLines || forceTrailingNewline) {
    result += "\n";
  }
  return '"""' + result + '"""';
}

// node_modules/graphql/language/tokenKind.mjs
var TokenKind;
(function(TokenKind2) {
  TokenKind2["SOF"] = "<SOF>";
  TokenKind2["EOF"] = "<EOF>";
  TokenKind2["BANG"] = "!";
  TokenKind2["DOLLAR"] = "$";
  TokenKind2["AMP"] = "&";
  TokenKind2["PAREN_L"] = "(";
  TokenKind2["PAREN_R"] = ")";
  TokenKind2["SPREAD"] = "...";
  TokenKind2["COLON"] = ":";
  TokenKind2["EQUALS"] = "=";
  TokenKind2["AT"] = "@";
  TokenKind2["BRACKET_L"] = "[";
  TokenKind2["BRACKET_R"] = "]";
  TokenKind2["BRACE_L"] = "{";
  TokenKind2["PIPE"] = "|";
  TokenKind2["BRACE_R"] = "}";
  TokenKind2["NAME"] = "Name";
  TokenKind2["INT"] = "Int";
  TokenKind2["FLOAT"] = "Float";
  TokenKind2["STRING"] = "String";
  TokenKind2["BLOCK_STRING"] = "BlockString";
  TokenKind2["COMMENT"] = "Comment";
})(TokenKind || (TokenKind = {}));

// node_modules/graphql/language/lexer.mjs
function isPunctuatorTokenKind(kind) {
  return kind === TokenKind.BANG || kind === TokenKind.DOLLAR || kind === TokenKind.AMP || kind === TokenKind.PAREN_L || kind === TokenKind.PAREN_R || kind === TokenKind.SPREAD || kind === TokenKind.COLON || kind === TokenKind.EQUALS || kind === TokenKind.AT || kind === TokenKind.BRACKET_L || kind === TokenKind.BRACKET_R || kind === TokenKind.BRACE_L || kind === TokenKind.PIPE || kind === TokenKind.BRACE_R;
}
var isUnicodeScalarValue = function(code) {
  return code >= 0 && code <= 55295 || code >= 57344 && code <= 1114111;
};
var isSupplementaryCodePoint = function(body, location4) {
  return isLeadingSurrogate(body.charCodeAt(location4)) && isTrailingSurrogate(body.charCodeAt(location4 + 1));
};
var isLeadingSurrogate = function(code) {
  return code >= 55296 && code <= 56319;
};
var isTrailingSurrogate = function(code) {
  return code >= 56320 && code <= 57343;
};
var printCodePointAt = function(lexer, location4) {
  const code = lexer.source.body.codePointAt(location4);
  if (code === undefined) {
    return TokenKind.EOF;
  } else if (code >= 32 && code <= 126) {
    const char = String.fromCodePoint(code);
    return char === '"' ? "'\"'" : `"${char}"`;
  }
  return "U+" + code.toString(16).toUpperCase().padStart(4, "0");
};
var createToken = function(lexer, kind, start, end, value) {
  const line = lexer.line;
  const col = 1 + start - lexer.lineStart;
  return new Token(kind, start, end, line, col, value);
};
var readNextToken = function(lexer, start) {
  const body = lexer.source.body;
  const bodyLength = body.length;
  let position = start;
  while (position < bodyLength) {
    const code = body.charCodeAt(position);
    switch (code) {
      case 65279:
      case 9:
      case 32:
      case 44:
        ++position;
        continue;
      case 10:
        ++position;
        ++lexer.line;
        lexer.lineStart = position;
        continue;
      case 13:
        if (body.charCodeAt(position + 1) === 10) {
          position += 2;
        } else {
          ++position;
        }
        ++lexer.line;
        lexer.lineStart = position;
        continue;
      case 35:
        return readComment(lexer, position);
      case 33:
        return createToken(lexer, TokenKind.BANG, position, position + 1);
      case 36:
        return createToken(lexer, TokenKind.DOLLAR, position, position + 1);
      case 38:
        return createToken(lexer, TokenKind.AMP, position, position + 1);
      case 40:
        return createToken(lexer, TokenKind.PAREN_L, position, position + 1);
      case 41:
        return createToken(lexer, TokenKind.PAREN_R, position, position + 1);
      case 46:
        if (body.charCodeAt(position + 1) === 46 && body.charCodeAt(position + 2) === 46) {
          return createToken(lexer, TokenKind.SPREAD, position, position + 3);
        }
        break;
      case 58:
        return createToken(lexer, TokenKind.COLON, position, position + 1);
      case 61:
        return createToken(lexer, TokenKind.EQUALS, position, position + 1);
      case 64:
        return createToken(lexer, TokenKind.AT, position, position + 1);
      case 91:
        return createToken(lexer, TokenKind.BRACKET_L, position, position + 1);
      case 93:
        return createToken(lexer, TokenKind.BRACKET_R, position, position + 1);
      case 123:
        return createToken(lexer, TokenKind.BRACE_L, position, position + 1);
      case 124:
        return createToken(lexer, TokenKind.PIPE, position, position + 1);
      case 125:
        return createToken(lexer, TokenKind.BRACE_R, position, position + 1);
      case 34:
        if (body.charCodeAt(position + 1) === 34 && body.charCodeAt(position + 2) === 34) {
          return readBlockString(lexer, position);
        }
        return readString(lexer, position);
    }
    if (isDigit(code) || code === 45) {
      return readNumber(lexer, position, code);
    }
    if (isNameStart(code)) {
      return readName(lexer, position);
    }
    throw syntaxError(lexer.source, position, code === 39 ? 'Unexpected single quote character (\'), did you mean to use a double quote (")?' : isUnicodeScalarValue(code) || isSupplementaryCodePoint(body, position) ? `Unexpected character: ${printCodePointAt(lexer, position)}.` : `Invalid character: ${printCodePointAt(lexer, position)}.`);
  }
  return createToken(lexer, TokenKind.EOF, bodyLength, bodyLength);
};
var readComment = function(lexer, start) {
  const body = lexer.source.body;
  const bodyLength = body.length;
  let position = start + 1;
  while (position < bodyLength) {
    const code = body.charCodeAt(position);
    if (code === 10 || code === 13) {
      break;
    }
    if (isUnicodeScalarValue(code)) {
      ++position;
    } else if (isSupplementaryCodePoint(body, position)) {
      position += 2;
    } else {
      break;
    }
  }
  return createToken(lexer, TokenKind.COMMENT, start, position, body.slice(start + 1, position));
};
var readNumber = function(lexer, start, firstCode) {
  const body = lexer.source.body;
  let position = start;
  let code = firstCode;
  let isFloat = false;
  if (code === 45) {
    code = body.charCodeAt(++position);
  }
  if (code === 48) {
    code = body.charCodeAt(++position);
    if (isDigit(code)) {
      throw syntaxError(lexer.source, position, `Invalid number, unexpected digit after 0: ${printCodePointAt(lexer, position)}.`);
    }
  } else {
    position = readDigits(lexer, position, code);
    code = body.charCodeAt(position);
  }
  if (code === 46) {
    isFloat = true;
    code = body.charCodeAt(++position);
    position = readDigits(lexer, position, code);
    code = body.charCodeAt(position);
  }
  if (code === 69 || code === 101) {
    isFloat = true;
    code = body.charCodeAt(++position);
    if (code === 43 || code === 45) {
      code = body.charCodeAt(++position);
    }
    position = readDigits(lexer, position, code);
    code = body.charCodeAt(position);
  }
  if (code === 46 || isNameStart(code)) {
    throw syntaxError(lexer.source, position, `Invalid number, expected digit but got: ${printCodePointAt(lexer, position)}.`);
  }
  return createToken(lexer, isFloat ? TokenKind.FLOAT : TokenKind.INT, start, position, body.slice(start, position));
};
var readDigits = function(lexer, start, firstCode) {
  if (!isDigit(firstCode)) {
    throw syntaxError(lexer.source, start, `Invalid number, expected digit but got: ${printCodePointAt(lexer, start)}.`);
  }
  const body = lexer.source.body;
  let position = start + 1;
  while (isDigit(body.charCodeAt(position))) {
    ++position;
  }
  return position;
};
var readString = function(lexer, start) {
  const body = lexer.source.body;
  const bodyLength = body.length;
  let position = start + 1;
  let chunkStart = position;
  let value = "";
  while (position < bodyLength) {
    const code = body.charCodeAt(position);
    if (code === 34) {
      value += body.slice(chunkStart, position);
      return createToken(lexer, TokenKind.STRING, start, position + 1, value);
    }
    if (code === 92) {
      value += body.slice(chunkStart, position);
      const escape2 = body.charCodeAt(position + 1) === 117 ? body.charCodeAt(position + 2) === 123 ? readEscapedUnicodeVariableWidth(lexer, position) : readEscapedUnicodeFixedWidth(lexer, position) : readEscapedCharacter(lexer, position);
      value += escape2.value;
      position += escape2.size;
      chunkStart = position;
      continue;
    }
    if (code === 10 || code === 13) {
      break;
    }
    if (isUnicodeScalarValue(code)) {
      ++position;
    } else if (isSupplementaryCodePoint(body, position)) {
      position += 2;
    } else {
      throw syntaxError(lexer.source, position, `Invalid character within String: ${printCodePointAt(lexer, position)}.`);
    }
  }
  throw syntaxError(lexer.source, position, "Unterminated string.");
};
var readEscapedUnicodeVariableWidth = function(lexer, position) {
  const body = lexer.source.body;
  let point = 0;
  let size = 3;
  while (size < 12) {
    const code = body.charCodeAt(position + size++);
    if (code === 125) {
      if (size < 5 || !isUnicodeScalarValue(point)) {
        break;
      }
      return {
        value: String.fromCodePoint(point),
        size
      };
    }
    point = point << 4 | readHexDigit(code);
    if (point < 0) {
      break;
    }
  }
  throw syntaxError(lexer.source, position, `Invalid Unicode escape sequence: "${body.slice(position, position + size)}".`);
};
var readEscapedUnicodeFixedWidth = function(lexer, position) {
  const body = lexer.source.body;
  const code = read16BitHexCode(body, position + 2);
  if (isUnicodeScalarValue(code)) {
    return {
      value: String.fromCodePoint(code),
      size: 6
    };
  }
  if (isLeadingSurrogate(code)) {
    if (body.charCodeAt(position + 6) === 92 && body.charCodeAt(position + 7) === 117) {
      const trailingCode = read16BitHexCode(body, position + 8);
      if (isTrailingSurrogate(trailingCode)) {
        return {
          value: String.fromCodePoint(code, trailingCode),
          size: 12
        };
      }
    }
  }
  throw syntaxError(lexer.source, position, `Invalid Unicode escape sequence: "${body.slice(position, position + 6)}".`);
};
var read16BitHexCode = function(body, position) {
  return readHexDigit(body.charCodeAt(position)) << 12 | readHexDigit(body.charCodeAt(position + 1)) << 8 | readHexDigit(body.charCodeAt(position + 2)) << 4 | readHexDigit(body.charCodeAt(position + 3));
};
var readHexDigit = function(code) {
  return code >= 48 && code <= 57 ? code - 48 : code >= 65 && code <= 70 ? code - 55 : code >= 97 && code <= 102 ? code - 87 : -1;
};
var readEscapedCharacter = function(lexer, position) {
  const body = lexer.source.body;
  const code = body.charCodeAt(position + 1);
  switch (code) {
    case 34:
      return {
        value: '"',
        size: 2
      };
    case 92:
      return {
        value: "\\",
        size: 2
      };
    case 47:
      return {
        value: "/",
        size: 2
      };
    case 98:
      return {
        value: "\b",
        size: 2
      };
    case 102:
      return {
        value: "\f",
        size: 2
      };
    case 110:
      return {
        value: `
`,
        size: 2
      };
    case 114:
      return {
        value: `\r`,
        size: 2
      };
    case 116:
      return {
        value: "\t",
        size: 2
      };
  }
  throw syntaxError(lexer.source, position, `Invalid character escape sequence: "${body.slice(position, position + 2)}".`);
};
var readBlockString = function(lexer, start) {
  const body = lexer.source.body;
  const bodyLength = body.length;
  let lineStart = lexer.lineStart;
  let position = start + 3;
  let chunkStart = position;
  let currentLine = "";
  const blockLines = [];
  while (position < bodyLength) {
    const code = body.charCodeAt(position);
    if (code === 34 && body.charCodeAt(position + 1) === 34 && body.charCodeAt(position + 2) === 34) {
      currentLine += body.slice(chunkStart, position);
      blockLines.push(currentLine);
      const token = createToken(lexer, TokenKind.BLOCK_STRING, start, position + 3, dedentBlockStringLines(blockLines).join("\n"));
      lexer.line += blockLines.length - 1;
      lexer.lineStart = lineStart;
      return token;
    }
    if (code === 92 && body.charCodeAt(position + 1) === 34 && body.charCodeAt(position + 2) === 34 && body.charCodeAt(position + 3) === 34) {
      currentLine += body.slice(chunkStart, position);
      chunkStart = position + 1;
      position += 4;
      continue;
    }
    if (code === 10 || code === 13) {
      currentLine += body.slice(chunkStart, position);
      blockLines.push(currentLine);
      if (code === 13 && body.charCodeAt(position + 1) === 10) {
        position += 2;
      } else {
        ++position;
      }
      currentLine = "";
      chunkStart = position;
      lineStart = position;
      continue;
    }
    if (isUnicodeScalarValue(code)) {
      ++position;
    } else if (isSupplementaryCodePoint(body, position)) {
      position += 2;
    } else {
      throw syntaxError(lexer.source, position, `Invalid character within String: ${printCodePointAt(lexer, position)}.`);
    }
  }
  throw syntaxError(lexer.source, position, "Unterminated string.");
};
var readName = function(lexer, start) {
  const body = lexer.source.body;
  const bodyLength = body.length;
  let position = start + 1;
  while (position < bodyLength) {
    const code = body.charCodeAt(position);
    if (isNameContinue(code)) {
      ++position;
    } else {
      break;
    }
  }
  return createToken(lexer, TokenKind.NAME, start, position, body.slice(start, position));
};

class Lexer {
  constructor(source) {
    const startOfFileToken = new Token(TokenKind.SOF, 0, 0, 0, 0);
    this.source = source;
    this.lastToken = startOfFileToken;
    this.token = startOfFileToken;
    this.line = 1;
    this.lineStart = 0;
  }
  get [Symbol.toStringTag]() {
    return "Lexer";
  }
  advance() {
    this.lastToken = this.token;
    const token = this.token = this.lookahead();
    return token;
  }
  lookahead() {
    let token = this.token;
    if (token.kind !== TokenKind.EOF) {
      do {
        if (token.next) {
          token = token.next;
        } else {
          const nextToken = readNextToken(this, token.end);
          token.next = nextToken;
          nextToken.prev = token;
          token = nextToken;
        }
      } while (token.kind === TokenKind.COMMENT);
    }
    return token;
  }
}

// node_modules/graphql/jsutils/inspect.mjs
function inspect(value) {
  return formatValue(value, []);
}
var formatValue = function(value, seenValues) {
  switch (typeof value) {
    case "string":
      return JSON.stringify(value);
    case "function":
      return value.name ? `[function ${value.name}]` : "[function]";
    case "object":
      return formatObjectValue(value, seenValues);
    default:
      return String(value);
  }
};
var formatObjectValue = function(value, previouslySeenValues) {
  if (value === null) {
    return "null";
  }
  if (previouslySeenValues.includes(value)) {
    return "[Circular]";
  }
  const seenValues = [...previouslySeenValues, value];
  if (isJSONable(value)) {
    const jsonValue = value.toJSON();
    if (jsonValue !== value) {
      return typeof jsonValue === "string" ? jsonValue : formatValue(jsonValue, seenValues);
    }
  } else if (Array.isArray(value)) {
    return formatArray(value, seenValues);
  }
  return formatObject(value, seenValues);
};
var isJSONable = function(value) {
  return typeof value.toJSON === "function";
};
var formatObject = function(object, seenValues) {
  const entries = Object.entries(object);
  if (entries.length === 0) {
    return "{}";
  }
  if (seenValues.length > MAX_RECURSIVE_DEPTH) {
    return "[" + getObjectTag(object) + "]";
  }
  const properties = entries.map(([key, value]) => key + ": " + formatValue(value, seenValues));
  return "{ " + properties.join(", ") + " }";
};
var formatArray = function(array, seenValues) {
  if (array.length === 0) {
    return "[]";
  }
  if (seenValues.length > MAX_RECURSIVE_DEPTH) {
    return "[Array]";
  }
  const len = Math.min(MAX_ARRAY_LENGTH, array.length);
  const remaining = array.length - len;
  const items = [];
  for (let i = 0;i < len; ++i) {
    items.push(formatValue(array[i], seenValues));
  }
  if (remaining === 1) {
    items.push("... 1 more item");
  } else if (remaining > 1) {
    items.push(`... ${remaining} more items`);
  }
  return "[" + items.join(", ") + "]";
};
var getObjectTag = function(object) {
  const tag = Object.prototype.toString.call(object).replace(/^\[object /, "").replace(/]$/, "");
  if (tag === "Object" && typeof object.constructor === "function") {
    const name = object.constructor.name;
    if (typeof name === "string" && name !== "") {
      return name;
    }
  }
  return tag;
};
var MAX_ARRAY_LENGTH = 10;
var MAX_RECURSIVE_DEPTH = 2;

// node_modules/graphql/jsutils/instanceOf.mjs
var instanceOf = globalThis.process && globalThis.process.env.NODE_ENV === "production" ? function instanceOf2(value, constructor) {
  return value instanceof constructor;
} : function instanceOf3(value, constructor) {
  if (value instanceof constructor) {
    return true;
  }
  if (typeof value === "object" && value !== null) {
    var _value$constructor;
    const className = constructor.prototype[Symbol.toStringTag];
    const valueClassName = Symbol.toStringTag in value ? value[Symbol.toStringTag] : (_value$constructor = value.constructor) === null || _value$constructor === undefined ? undefined : _value$constructor.name;
    if (className === valueClassName) {
      const stringifiedValue = inspect(value);
      throw new Error(`Cannot use ${className} "${stringifiedValue}" from another module or realm.

Ensure that there is only one instance of "graphql" in the node_modules
directory. If different versions of "graphql" are the dependencies of other
relied on modules, use "resolutions" to ensure only one version is installed.

https://yarnpkg.com/en/docs/selective-version-resolutions

Duplicate "graphql" modules cannot be used at the same time since different
versions may have different capabilities and behavior. The data from one
version used in the function from another could produce confusing and
spurious results.`);
    }
  }
  return false;
};

// node_modules/graphql/language/source.mjs
function isSource(source) {
  return instanceOf(source, Source);
}

class Source {
  constructor(body, name = "GraphQL request", locationOffset = {
    line: 1,
    column: 1
  }) {
    typeof body === "string" || devAssert(false, `Body must be a string. Received: ${inspect(body)}.`);
    this.body = body;
    this.name = name;
    this.locationOffset = locationOffset;
    this.locationOffset.line > 0 || devAssert(false, "line in locationOffset is 1-indexed and must be positive.");
    this.locationOffset.column > 0 || devAssert(false, "column in locationOffset is 1-indexed and must be positive.");
  }
  get [Symbol.toStringTag]() {
    return "Source";
  }
}

// node_modules/graphql/language/parser.mjs
function parse(source2, options) {
  const parser = new Parser(source2, options);
  return parser.parseDocument();
}
var getTokenDesc = function(token) {
  const value = token.value;
  return getTokenKindDesc(token.kind) + (value != null ? ` "${value}"` : "");
};
var getTokenKindDesc = function(kind) {
  return isPunctuatorTokenKind(kind) ? `"${kind}"` : kind;
};

class Parser {
  constructor(source2, options = {}) {
    const sourceObj = isSource(source2) ? source2 : new Source(source2);
    this._lexer = new Lexer(sourceObj);
    this._options = options;
    this._tokenCounter = 0;
  }
  parseName() {
    const token = this.expectToken(TokenKind.NAME);
    return this.node(token, {
      kind: Kind.NAME,
      value: token.value
    });
  }
  parseDocument() {
    return this.node(this._lexer.token, {
      kind: Kind.DOCUMENT,
      definitions: this.many(TokenKind.SOF, this.parseDefinition, TokenKind.EOF)
    });
  }
  parseDefinition() {
    if (this.peek(TokenKind.BRACE_L)) {
      return this.parseOperationDefinition();
    }
    const hasDescription = this.peekDescription();
    const keywordToken = hasDescription ? this._lexer.lookahead() : this._lexer.token;
    if (keywordToken.kind === TokenKind.NAME) {
      switch (keywordToken.value) {
        case "schema":
          return this.parseSchemaDefinition();
        case "scalar":
          return this.parseScalarTypeDefinition();
        case "type":
          return this.parseObjectTypeDefinition();
        case "interface":
          return this.parseInterfaceTypeDefinition();
        case "union":
          return this.parseUnionTypeDefinition();
        case "enum":
          return this.parseEnumTypeDefinition();
        case "input":
          return this.parseInputObjectTypeDefinition();
        case "directive":
          return this.parseDirectiveDefinition();
      }
      if (hasDescription) {
        throw syntaxError(this._lexer.source, this._lexer.token.start, "Unexpected description, descriptions are supported only on type definitions.");
      }
      switch (keywordToken.value) {
        case "query":
        case "mutation":
        case "subscription":
          return this.parseOperationDefinition();
        case "fragment":
          return this.parseFragmentDefinition();
        case "extend":
          return this.parseTypeSystemExtension();
      }
    }
    throw this.unexpected(keywordToken);
  }
  parseOperationDefinition() {
    const start = this._lexer.token;
    if (this.peek(TokenKind.BRACE_L)) {
      return this.node(start, {
        kind: Kind.OPERATION_DEFINITION,
        operation: OperationTypeNode.QUERY,
        name: undefined,
        variableDefinitions: [],
        directives: [],
        selectionSet: this.parseSelectionSet()
      });
    }
    const operation = this.parseOperationType();
    let name;
    if (this.peek(TokenKind.NAME)) {
      name = this.parseName();
    }
    return this.node(start, {
      kind: Kind.OPERATION_DEFINITION,
      operation,
      name,
      variableDefinitions: this.parseVariableDefinitions(),
      directives: this.parseDirectives(false),
      selectionSet: this.parseSelectionSet()
    });
  }
  parseOperationType() {
    const operationToken = this.expectToken(TokenKind.NAME);
    switch (operationToken.value) {
      case "query":
        return OperationTypeNode.QUERY;
      case "mutation":
        return OperationTypeNode.MUTATION;
      case "subscription":
        return OperationTypeNode.SUBSCRIPTION;
    }
    throw this.unexpected(operationToken);
  }
  parseVariableDefinitions() {
    return this.optionalMany(TokenKind.PAREN_L, this.parseVariableDefinition, TokenKind.PAREN_R);
  }
  parseVariableDefinition() {
    return this.node(this._lexer.token, {
      kind: Kind.VARIABLE_DEFINITION,
      variable: this.parseVariable(),
      type: (this.expectToken(TokenKind.COLON), this.parseTypeReference()),
      defaultValue: this.expectOptionalToken(TokenKind.EQUALS) ? this.parseConstValueLiteral() : undefined,
      directives: this.parseConstDirectives()
    });
  }
  parseVariable() {
    const start = this._lexer.token;
    this.expectToken(TokenKind.DOLLAR);
    return this.node(start, {
      kind: Kind.VARIABLE,
      name: this.parseName()
    });
  }
  parseSelectionSet() {
    return this.node(this._lexer.token, {
      kind: Kind.SELECTION_SET,
      selections: this.many(TokenKind.BRACE_L, this.parseSelection, TokenKind.BRACE_R)
    });
  }
  parseSelection() {
    return this.peek(TokenKind.SPREAD) ? this.parseFragment() : this.parseField();
  }
  parseField() {
    const start = this._lexer.token;
    const nameOrAlias = this.parseName();
    let alias;
    let name;
    if (this.expectOptionalToken(TokenKind.COLON)) {
      alias = nameOrAlias;
      name = this.parseName();
    } else {
      name = nameOrAlias;
    }
    return this.node(start, {
      kind: Kind.FIELD,
      alias,
      name,
      arguments: this.parseArguments(false),
      directives: this.parseDirectives(false),
      selectionSet: this.peek(TokenKind.BRACE_L) ? this.parseSelectionSet() : undefined
    });
  }
  parseArguments(isConst) {
    const item = isConst ? this.parseConstArgument : this.parseArgument;
    return this.optionalMany(TokenKind.PAREN_L, item, TokenKind.PAREN_R);
  }
  parseArgument(isConst = false) {
    const start = this._lexer.token;
    const name = this.parseName();
    this.expectToken(TokenKind.COLON);
    return this.node(start, {
      kind: Kind.ARGUMENT,
      name,
      value: this.parseValueLiteral(isConst)
    });
  }
  parseConstArgument() {
    return this.parseArgument(true);
  }
  parseFragment() {
    const start = this._lexer.token;
    this.expectToken(TokenKind.SPREAD);
    const hasTypeCondition = this.expectOptionalKeyword("on");
    if (!hasTypeCondition && this.peek(TokenKind.NAME)) {
      return this.node(start, {
        kind: Kind.FRAGMENT_SPREAD,
        name: this.parseFragmentName(),
        directives: this.parseDirectives(false)
      });
    }
    return this.node(start, {
      kind: Kind.INLINE_FRAGMENT,
      typeCondition: hasTypeCondition ? this.parseNamedType() : undefined,
      directives: this.parseDirectives(false),
      selectionSet: this.parseSelectionSet()
    });
  }
  parseFragmentDefinition() {
    const start = this._lexer.token;
    this.expectKeyword("fragment");
    if (this._options.allowLegacyFragmentVariables === true) {
      return this.node(start, {
        kind: Kind.FRAGMENT_DEFINITION,
        name: this.parseFragmentName(),
        variableDefinitions: this.parseVariableDefinitions(),
        typeCondition: (this.expectKeyword("on"), this.parseNamedType()),
        directives: this.parseDirectives(false),
        selectionSet: this.parseSelectionSet()
      });
    }
    return this.node(start, {
      kind: Kind.FRAGMENT_DEFINITION,
      name: this.parseFragmentName(),
      typeCondition: (this.expectKeyword("on"), this.parseNamedType()),
      directives: this.parseDirectives(false),
      selectionSet: this.parseSelectionSet()
    });
  }
  parseFragmentName() {
    if (this._lexer.token.value === "on") {
      throw this.unexpected();
    }
    return this.parseName();
  }
  parseValueLiteral(isConst) {
    const token = this._lexer.token;
    switch (token.kind) {
      case TokenKind.BRACKET_L:
        return this.parseList(isConst);
      case TokenKind.BRACE_L:
        return this.parseObject(isConst);
      case TokenKind.INT:
        this.advanceLexer();
        return this.node(token, {
          kind: Kind.INT,
          value: token.value
        });
      case TokenKind.FLOAT:
        this.advanceLexer();
        return this.node(token, {
          kind: Kind.FLOAT,
          value: token.value
        });
      case TokenKind.STRING:
      case TokenKind.BLOCK_STRING:
        return this.parseStringLiteral();
      case TokenKind.NAME:
        this.advanceLexer();
        switch (token.value) {
          case "true":
            return this.node(token, {
              kind: Kind.BOOLEAN,
              value: true
            });
          case "false":
            return this.node(token, {
              kind: Kind.BOOLEAN,
              value: false
            });
          case "null":
            return this.node(token, {
              kind: Kind.NULL
            });
          default:
            return this.node(token, {
              kind: Kind.ENUM,
              value: token.value
            });
        }
      case TokenKind.DOLLAR:
        if (isConst) {
          this.expectToken(TokenKind.DOLLAR);
          if (this._lexer.token.kind === TokenKind.NAME) {
            const varName = this._lexer.token.value;
            throw syntaxError(this._lexer.source, token.start, `Unexpected variable "\$${varName}" in constant value.`);
          } else {
            throw this.unexpected(token);
          }
        }
        return this.parseVariable();
      default:
        throw this.unexpected();
    }
  }
  parseConstValueLiteral() {
    return this.parseValueLiteral(true);
  }
  parseStringLiteral() {
    const token = this._lexer.token;
    this.advanceLexer();
    return this.node(token, {
      kind: Kind.STRING,
      value: token.value,
      block: token.kind === TokenKind.BLOCK_STRING
    });
  }
  parseList(isConst) {
    const item = () => this.parseValueLiteral(isConst);
    return this.node(this._lexer.token, {
      kind: Kind.LIST,
      values: this.any(TokenKind.BRACKET_L, item, TokenKind.BRACKET_R)
    });
  }
  parseObject(isConst) {
    const item = () => this.parseObjectField(isConst);
    return this.node(this._lexer.token, {
      kind: Kind.OBJECT,
      fields: this.any(TokenKind.BRACE_L, item, TokenKind.BRACE_R)
    });
  }
  parseObjectField(isConst) {
    const start = this._lexer.token;
    const name = this.parseName();
    this.expectToken(TokenKind.COLON);
    return this.node(start, {
      kind: Kind.OBJECT_FIELD,
      name,
      value: this.parseValueLiteral(isConst)
    });
  }
  parseDirectives(isConst) {
    const directives = [];
    while (this.peek(TokenKind.AT)) {
      directives.push(this.parseDirective(isConst));
    }
    return directives;
  }
  parseConstDirectives() {
    return this.parseDirectives(true);
  }
  parseDirective(isConst) {
    const start = this._lexer.token;
    this.expectToken(TokenKind.AT);
    return this.node(start, {
      kind: Kind.DIRECTIVE,
      name: this.parseName(),
      arguments: this.parseArguments(isConst)
    });
  }
  parseTypeReference() {
    const start = this._lexer.token;
    let type;
    if (this.expectOptionalToken(TokenKind.BRACKET_L)) {
      const innerType = this.parseTypeReference();
      this.expectToken(TokenKind.BRACKET_R);
      type = this.node(start, {
        kind: Kind.LIST_TYPE,
        type: innerType
      });
    } else {
      type = this.parseNamedType();
    }
    if (this.expectOptionalToken(TokenKind.BANG)) {
      return this.node(start, {
        kind: Kind.NON_NULL_TYPE,
        type
      });
    }
    return type;
  }
  parseNamedType() {
    return this.node(this._lexer.token, {
      kind: Kind.NAMED_TYPE,
      name: this.parseName()
    });
  }
  peekDescription() {
    return this.peek(TokenKind.STRING) || this.peek(TokenKind.BLOCK_STRING);
  }
  parseDescription() {
    if (this.peekDescription()) {
      return this.parseStringLiteral();
    }
  }
  parseSchemaDefinition() {
    const start = this._lexer.token;
    const description = this.parseDescription();
    this.expectKeyword("schema");
    const directives = this.parseConstDirectives();
    const operationTypes = this.many(TokenKind.BRACE_L, this.parseOperationTypeDefinition, TokenKind.BRACE_R);
    return this.node(start, {
      kind: Kind.SCHEMA_DEFINITION,
      description,
      directives,
      operationTypes
    });
  }
  parseOperationTypeDefinition() {
    const start = this._lexer.token;
    const operation = this.parseOperationType();
    this.expectToken(TokenKind.COLON);
    const type = this.parseNamedType();
    return this.node(start, {
      kind: Kind.OPERATION_TYPE_DEFINITION,
      operation,
      type
    });
  }
  parseScalarTypeDefinition() {
    const start = this._lexer.token;
    const description = this.parseDescription();
    this.expectKeyword("scalar");
    const name = this.parseName();
    const directives = this.parseConstDirectives();
    return this.node(start, {
      kind: Kind.SCALAR_TYPE_DEFINITION,
      description,
      name,
      directives
    });
  }
  parseObjectTypeDefinition() {
    const start = this._lexer.token;
    const description = this.parseDescription();
    this.expectKeyword("type");
    const name = this.parseName();
    const interfaces = this.parseImplementsInterfaces();
    const directives = this.parseConstDirectives();
    const fields = this.parseFieldsDefinition();
    return this.node(start, {
      kind: Kind.OBJECT_TYPE_DEFINITION,
      description,
      name,
      interfaces,
      directives,
      fields
    });
  }
  parseImplementsInterfaces() {
    return this.expectOptionalKeyword("implements") ? this.delimitedMany(TokenKind.AMP, this.parseNamedType) : [];
  }
  parseFieldsDefinition() {
    return this.optionalMany(TokenKind.BRACE_L, this.parseFieldDefinition, TokenKind.BRACE_R);
  }
  parseFieldDefinition() {
    const start = this._lexer.token;
    const description = this.parseDescription();
    const name = this.parseName();
    const args = this.parseArgumentDefs();
    this.expectToken(TokenKind.COLON);
    const type = this.parseTypeReference();
    const directives = this.parseConstDirectives();
    return this.node(start, {
      kind: Kind.FIELD_DEFINITION,
      description,
      name,
      arguments: args,
      type,
      directives
    });
  }
  parseArgumentDefs() {
    return this.optionalMany(TokenKind.PAREN_L, this.parseInputValueDef, TokenKind.PAREN_R);
  }
  parseInputValueDef() {
    const start = this._lexer.token;
    const description = this.parseDescription();
    const name = this.parseName();
    this.expectToken(TokenKind.COLON);
    const type = this.parseTypeReference();
    let defaultValue;
    if (this.expectOptionalToken(TokenKind.EQUALS)) {
      defaultValue = this.parseConstValueLiteral();
    }
    const directives = this.parseConstDirectives();
    return this.node(start, {
      kind: Kind.INPUT_VALUE_DEFINITION,
      description,
      name,
      type,
      defaultValue,
      directives
    });
  }
  parseInterfaceTypeDefinition() {
    const start = this._lexer.token;
    const description = this.parseDescription();
    this.expectKeyword("interface");
    const name = this.parseName();
    const interfaces = this.parseImplementsInterfaces();
    const directives = this.parseConstDirectives();
    const fields = this.parseFieldsDefinition();
    return this.node(start, {
      kind: Kind.INTERFACE_TYPE_DEFINITION,
      description,
      name,
      interfaces,
      directives,
      fields
    });
  }
  parseUnionTypeDefinition() {
    const start = this._lexer.token;
    const description = this.parseDescription();
    this.expectKeyword("union");
    const name = this.parseName();
    const directives = this.parseConstDirectives();
    const types = this.parseUnionMemberTypes();
    return this.node(start, {
      kind: Kind.UNION_TYPE_DEFINITION,
      description,
      name,
      directives,
      types
    });
  }
  parseUnionMemberTypes() {
    return this.expectOptionalToken(TokenKind.EQUALS) ? this.delimitedMany(TokenKind.PIPE, this.parseNamedType) : [];
  }
  parseEnumTypeDefinition() {
    const start = this._lexer.token;
    const description = this.parseDescription();
    this.expectKeyword("enum");
    const name = this.parseName();
    const directives = this.parseConstDirectives();
    const values = this.parseEnumValuesDefinition();
    return this.node(start, {
      kind: Kind.ENUM_TYPE_DEFINITION,
      description,
      name,
      directives,
      values
    });
  }
  parseEnumValuesDefinition() {
    return this.optionalMany(TokenKind.BRACE_L, this.parseEnumValueDefinition, TokenKind.BRACE_R);
  }
  parseEnumValueDefinition() {
    const start = this._lexer.token;
    const description = this.parseDescription();
    const name = this.parseEnumValueName();
    const directives = this.parseConstDirectives();
    return this.node(start, {
      kind: Kind.ENUM_VALUE_DEFINITION,
      description,
      name,
      directives
    });
  }
  parseEnumValueName() {
    if (this._lexer.token.value === "true" || this._lexer.token.value === "false" || this._lexer.token.value === "null") {
      throw syntaxError(this._lexer.source, this._lexer.token.start, `${getTokenDesc(this._lexer.token)} is reserved and cannot be used for an enum value.`);
    }
    return this.parseName();
  }
  parseInputObjectTypeDefinition() {
    const start = this._lexer.token;
    const description = this.parseDescription();
    this.expectKeyword("input");
    const name = this.parseName();
    const directives = this.parseConstDirectives();
    const fields = this.parseInputFieldsDefinition();
    return this.node(start, {
      kind: Kind.INPUT_OBJECT_TYPE_DEFINITION,
      description,
      name,
      directives,
      fields
    });
  }
  parseInputFieldsDefinition() {
    return this.optionalMany(TokenKind.BRACE_L, this.parseInputValueDef, TokenKind.BRACE_R);
  }
  parseTypeSystemExtension() {
    const keywordToken = this._lexer.lookahead();
    if (keywordToken.kind === TokenKind.NAME) {
      switch (keywordToken.value) {
        case "schema":
          return this.parseSchemaExtension();
        case "scalar":
          return this.parseScalarTypeExtension();
        case "type":
          return this.parseObjectTypeExtension();
        case "interface":
          return this.parseInterfaceTypeExtension();
        case "union":
          return this.parseUnionTypeExtension();
        case "enum":
          return this.parseEnumTypeExtension();
        case "input":
          return this.parseInputObjectTypeExtension();
      }
    }
    throw this.unexpected(keywordToken);
  }
  parseSchemaExtension() {
    const start = this._lexer.token;
    this.expectKeyword("extend");
    this.expectKeyword("schema");
    const directives = this.parseConstDirectives();
    const operationTypes = this.optionalMany(TokenKind.BRACE_L, this.parseOperationTypeDefinition, TokenKind.BRACE_R);
    if (directives.length === 0 && operationTypes.length === 0) {
      throw this.unexpected();
    }
    return this.node(start, {
      kind: Kind.SCHEMA_EXTENSION,
      directives,
      operationTypes
    });
  }
  parseScalarTypeExtension() {
    const start = this._lexer.token;
    this.expectKeyword("extend");
    this.expectKeyword("scalar");
    const name = this.parseName();
    const directives = this.parseConstDirectives();
    if (directives.length === 0) {
      throw this.unexpected();
    }
    return this.node(start, {
      kind: Kind.SCALAR_TYPE_EXTENSION,
      name,
      directives
    });
  }
  parseObjectTypeExtension() {
    const start = this._lexer.token;
    this.expectKeyword("extend");
    this.expectKeyword("type");
    const name = this.parseName();
    const interfaces = this.parseImplementsInterfaces();
    const directives = this.parseConstDirectives();
    const fields = this.parseFieldsDefinition();
    if (interfaces.length === 0 && directives.length === 0 && fields.length === 0) {
      throw this.unexpected();
    }
    return this.node(start, {
      kind: Kind.OBJECT_TYPE_EXTENSION,
      name,
      interfaces,
      directives,
      fields
    });
  }
  parseInterfaceTypeExtension() {
    const start = this._lexer.token;
    this.expectKeyword("extend");
    this.expectKeyword("interface");
    const name = this.parseName();
    const interfaces = this.parseImplementsInterfaces();
    const directives = this.parseConstDirectives();
    const fields = this.parseFieldsDefinition();
    if (interfaces.length === 0 && directives.length === 0 && fields.length === 0) {
      throw this.unexpected();
    }
    return this.node(start, {
      kind: Kind.INTERFACE_TYPE_EXTENSION,
      name,
      interfaces,
      directives,
      fields
    });
  }
  parseUnionTypeExtension() {
    const start = this._lexer.token;
    this.expectKeyword("extend");
    this.expectKeyword("union");
    const name = this.parseName();
    const directives = this.parseConstDirectives();
    const types = this.parseUnionMemberTypes();
    if (directives.length === 0 && types.length === 0) {
      throw this.unexpected();
    }
    return this.node(start, {
      kind: Kind.UNION_TYPE_EXTENSION,
      name,
      directives,
      types
    });
  }
  parseEnumTypeExtension() {
    const start = this._lexer.token;
    this.expectKeyword("extend");
    this.expectKeyword("enum");
    const name = this.parseName();
    const directives = this.parseConstDirectives();
    const values = this.parseEnumValuesDefinition();
    if (directives.length === 0 && values.length === 0) {
      throw this.unexpected();
    }
    return this.node(start, {
      kind: Kind.ENUM_TYPE_EXTENSION,
      name,
      directives,
      values
    });
  }
  parseInputObjectTypeExtension() {
    const start = this._lexer.token;
    this.expectKeyword("extend");
    this.expectKeyword("input");
    const name = this.parseName();
    const directives = this.parseConstDirectives();
    const fields = this.parseInputFieldsDefinition();
    if (directives.length === 0 && fields.length === 0) {
      throw this.unexpected();
    }
    return this.node(start, {
      kind: Kind.INPUT_OBJECT_TYPE_EXTENSION,
      name,
      directives,
      fields
    });
  }
  parseDirectiveDefinition() {
    const start = this._lexer.token;
    const description = this.parseDescription();
    this.expectKeyword("directive");
    this.expectToken(TokenKind.AT);
    const name = this.parseName();
    const args = this.parseArgumentDefs();
    const repeatable = this.expectOptionalKeyword("repeatable");
    this.expectKeyword("on");
    const locations = this.parseDirectiveLocations();
    return this.node(start, {
      kind: Kind.DIRECTIVE_DEFINITION,
      description,
      name,
      arguments: args,
      repeatable,
      locations
    });
  }
  parseDirectiveLocations() {
    return this.delimitedMany(TokenKind.PIPE, this.parseDirectiveLocation);
  }
  parseDirectiveLocation() {
    const start = this._lexer.token;
    const name = this.parseName();
    if (Object.prototype.hasOwnProperty.call(DirectiveLocation, name.value)) {
      return name;
    }
    throw this.unexpected(start);
  }
  node(startToken, node) {
    if (this._options.noLocation !== true) {
      node.loc = new Location(startToken, this._lexer.lastToken, this._lexer.source);
    }
    return node;
  }
  peek(kind) {
    return this._lexer.token.kind === kind;
  }
  expectToken(kind) {
    const token = this._lexer.token;
    if (token.kind === kind) {
      this.advanceLexer();
      return token;
    }
    throw syntaxError(this._lexer.source, token.start, `Expected ${getTokenKindDesc(kind)}, found ${getTokenDesc(token)}.`);
  }
  expectOptionalToken(kind) {
    const token = this._lexer.token;
    if (token.kind === kind) {
      this.advanceLexer();
      return true;
    }
    return false;
  }
  expectKeyword(value) {
    const token = this._lexer.token;
    if (token.kind === TokenKind.NAME && token.value === value) {
      this.advanceLexer();
    } else {
      throw syntaxError(this._lexer.source, token.start, `Expected "${value}", found ${getTokenDesc(token)}.`);
    }
  }
  expectOptionalKeyword(value) {
    const token = this._lexer.token;
    if (token.kind === TokenKind.NAME && token.value === value) {
      this.advanceLexer();
      return true;
    }
    return false;
  }
  unexpected(atToken) {
    const token = atToken !== null && atToken !== undefined ? atToken : this._lexer.token;
    return syntaxError(this._lexer.source, token.start, `Unexpected ${getTokenDesc(token)}.`);
  }
  any(openKind, parseFn, closeKind) {
    this.expectToken(openKind);
    const nodes = [];
    while (!this.expectOptionalToken(closeKind)) {
      nodes.push(parseFn.call(this));
    }
    return nodes;
  }
  optionalMany(openKind, parseFn, closeKind) {
    if (this.expectOptionalToken(openKind)) {
      const nodes = [];
      do {
        nodes.push(parseFn.call(this));
      } while (!this.expectOptionalToken(closeKind));
      return nodes;
    }
    return [];
  }
  many(openKind, parseFn, closeKind) {
    this.expectToken(openKind);
    const nodes = [];
    do {
      nodes.push(parseFn.call(this));
    } while (!this.expectOptionalToken(closeKind));
    return nodes;
  }
  delimitedMany(delimiterKind, parseFn) {
    this.expectOptionalToken(delimiterKind);
    const nodes = [];
    do {
      nodes.push(parseFn.call(this));
    } while (this.expectOptionalToken(delimiterKind));
    return nodes;
  }
  advanceLexer() {
    const { maxTokens } = this._options;
    const token = this._lexer.advance();
    if (maxTokens !== undefined && token.kind !== TokenKind.EOF) {
      ++this._tokenCounter;
      if (this._tokenCounter > maxTokens) {
        throw syntaxError(this._lexer.source, token.start, `Document contains more that ${maxTokens} tokens. Parsing aborted.`);
      }
    }
  }
}

// node_modules/graphql/jsutils/didYouMean.mjs
function didYouMean(firstArg, secondArg) {
  const [subMessage, suggestionsArg] = secondArg ? [firstArg, secondArg] : [undefined, firstArg];
  let message = " Did you mean ";
  if (subMessage) {
    message += subMessage + " ";
  }
  const suggestions = suggestionsArg.map((x) => `"${x}"`);
  switch (suggestions.length) {
    case 0:
      return "";
    case 1:
      return message + suggestions[0] + "?";
    case 2:
      return message + suggestions[0] + " or " + suggestions[1] + "?";
  }
  const selected = suggestions.slice(0, MAX_SUGGESTIONS);
  const lastItem = selected.pop();
  return message + selected.join(", ") + ", or " + lastItem + "?";
}
var MAX_SUGGESTIONS = 5;

// node_modules/graphql/jsutils/identityFunc.mjs
function identityFunc(x) {
  return x;
}

// node_modules/graphql/jsutils/keyMap.mjs
function keyMap(list, keyFn) {
  const result = Object.create(null);
  for (const item of list) {
    result[keyFn(item)] = item;
  }
  return result;
}

// node_modules/graphql/jsutils/keyValMap.mjs
function keyValMap(list, keyFn, valFn) {
  const result = Object.create(null);
  for (const item of list) {
    result[keyFn(item)] = valFn(item);
  }
  return result;
}

// node_modules/graphql/jsutils/mapValue.mjs
function mapValue(map, fn) {
  const result = Object.create(null);
  for (const key of Object.keys(map)) {
    result[key] = fn(map[key], key);
  }
  return result;
}

// node_modules/graphql/jsutils/naturalCompare.mjs
function naturalCompare(aStr, bStr) {
  let aIndex = 0;
  let bIndex = 0;
  while (aIndex < aStr.length && bIndex < bStr.length) {
    let aChar = aStr.charCodeAt(aIndex);
    let bChar = bStr.charCodeAt(bIndex);
    if (isDigit2(aChar) && isDigit2(bChar)) {
      let aNum = 0;
      do {
        ++aIndex;
        aNum = aNum * 10 + aChar - DIGIT_0;
        aChar = aStr.charCodeAt(aIndex);
      } while (isDigit2(aChar) && aNum > 0);
      let bNum = 0;
      do {
        ++bIndex;
        bNum = bNum * 10 + bChar - DIGIT_0;
        bChar = bStr.charCodeAt(bIndex);
      } while (isDigit2(bChar) && bNum > 0);
      if (aNum < bNum) {
        return -1;
      }
      if (aNum > bNum) {
        return 1;
      }
    } else {
      if (aChar < bChar) {
        return -1;
      }
      if (aChar > bChar) {
        return 1;
      }
      ++aIndex;
      ++bIndex;
    }
  }
  return aStr.length - bStr.length;
}
var isDigit2 = function(code) {
  return !isNaN(code) && DIGIT_0 <= code && code <= DIGIT_9;
};
var DIGIT_0 = 48;
var DIGIT_9 = 57;

// node_modules/graphql/jsutils/suggestionList.mjs
function suggestionList(input, options) {
  const optionsByDistance = Object.create(null);
  const lexicalDistance = new LexicalDistance(input);
  const threshold = Math.floor(input.length * 0.4) + 1;
  for (const option of options) {
    const distance = lexicalDistance.measure(option, threshold);
    if (distance !== undefined) {
      optionsByDistance[option] = distance;
    }
  }
  return Object.keys(optionsByDistance).sort((a, b) => {
    const distanceDiff = optionsByDistance[a] - optionsByDistance[b];
    return distanceDiff !== 0 ? distanceDiff : naturalCompare(a, b);
  });
}
var stringToArray = function(str) {
  const strLength = str.length;
  const array = new Array(strLength);
  for (let i = 0;i < strLength; ++i) {
    array[i] = str.charCodeAt(i);
  }
  return array;
};

class LexicalDistance {
  constructor(input) {
    this._input = input;
    this._inputLowerCase = input.toLowerCase();
    this._inputArray = stringToArray(this._inputLowerCase);
    this._rows = [
      new Array(input.length + 1).fill(0),
      new Array(input.length + 1).fill(0),
      new Array(input.length + 1).fill(0)
    ];
  }
  measure(option, threshold) {
    if (this._input === option) {
      return 0;
    }
    const optionLowerCase = option.toLowerCase();
    if (this._inputLowerCase === optionLowerCase) {
      return 1;
    }
    let a = stringToArray(optionLowerCase);
    let b = this._inputArray;
    if (a.length < b.length) {
      const tmp = a;
      a = b;
      b = tmp;
    }
    const aLength = a.length;
    const bLength = b.length;
    if (aLength - bLength > threshold) {
      return;
    }
    const rows = this._rows;
    for (let j = 0;j <= bLength; j++) {
      rows[0][j] = j;
    }
    for (let i = 1;i <= aLength; i++) {
      const upRow = rows[(i - 1) % 3];
      const currentRow = rows[i % 3];
      let smallestCell = currentRow[0] = i;
      for (let j = 1;j <= bLength; j++) {
        const cost = a[i - 1] === b[j - 1] ? 0 : 1;
        let currentCell = Math.min(upRow[j] + 1, currentRow[j - 1] + 1, upRow[j - 1] + cost);
        if (i > 1 && j > 1 && a[i - 1] === b[j - 2] && a[i - 2] === b[j - 1]) {
          const doubleDiagonalCell = rows[(i - 2) % 3][j - 2];
          currentCell = Math.min(currentCell, doubleDiagonalCell + 1);
        }
        if (currentCell < smallestCell) {
          smallestCell = currentCell;
        }
        currentRow[j] = currentCell;
      }
      if (smallestCell > threshold) {
        return;
      }
    }
    const distance = rows[aLength % 3][bLength];
    return distance <= threshold ? distance : undefined;
  }
}

// node_modules/graphql/jsutils/toObjMap.mjs
function toObjMap(obj) {
  if (obj == null) {
    return Object.create(null);
  }
  if (Object.getPrototypeOf(obj) === null) {
    return obj;
  }
  const map = Object.create(null);
  for (const [key, value] of Object.entries(obj)) {
    map[key] = value;
  }
  return map;
}

// node_modules/graphql/language/printString.mjs
function printString(str) {
  return `"${str.replace(escapedRegExp, escapedReplacer)}"`;
}
var escapedReplacer = function(str) {
  return escapeSequences[str.charCodeAt(0)];
};
var escapedRegExp = /[\x00-\x1f\x22\x5c\x7f-\x9f]/g;
var escapeSequences = [
  "\\u0000",
  "\\u0001",
  "\\u0002",
  "\\u0003",
  "\\u0004",
  "\\u0005",
  "\\u0006",
  "\\u0007",
  "\\b",
  "\\t",
  "\\n",
  "\\u000B",
  "\\f",
  "\\r",
  "\\u000E",
  "\\u000F",
  "\\u0010",
  "\\u0011",
  "\\u0012",
  "\\u0013",
  "\\u0014",
  "\\u0015",
  "\\u0016",
  "\\u0017",
  "\\u0018",
  "\\u0019",
  "\\u001A",
  "\\u001B",
  "\\u001C",
  "\\u001D",
  "\\u001E",
  "\\u001F",
  "",
  "",
  '\\"',
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "\\\\",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "\\u007F",
  "\\u0080",
  "\\u0081",
  "\\u0082",
  "\\u0083",
  "\\u0084",
  "\\u0085",
  "\\u0086",
  "\\u0087",
  "\\u0088",
  "\\u0089",
  "\\u008A",
  "\\u008B",
  "\\u008C",
  "\\u008D",
  "\\u008E",
  "\\u008F",
  "\\u0090",
  "\\u0091",
  "\\u0092",
  "\\u0093",
  "\\u0094",
  "\\u0095",
  "\\u0096",
  "\\u0097",
  "\\u0098",
  "\\u0099",
  "\\u009A",
  "\\u009B",
  "\\u009C",
  "\\u009D",
  "\\u009E",
  "\\u009F"
];

// node_modules/graphql/language/visitor.mjs
function visit(root, visitor, visitorKeys = QueryDocumentKeys) {
  const enterLeaveMap = new Map;
  for (const kind of Object.values(Kind)) {
    enterLeaveMap.set(kind, getEnterLeaveForKind(visitor, kind));
  }
  let stack = undefined;
  let inArray = Array.isArray(root);
  let keys = [root];
  let index = -1;
  let edits = [];
  let node = root;
  let key = undefined;
  let parent = undefined;
  const path = [];
  const ancestors = [];
  do {
    index++;
    const isLeaving = index === keys.length;
    const isEdited = isLeaving && edits.length !== 0;
    if (isLeaving) {
      key = ancestors.length === 0 ? undefined : path[path.length - 1];
      node = parent;
      parent = ancestors.pop();
      if (isEdited) {
        if (inArray) {
          node = node.slice();
          let editOffset = 0;
          for (const [editKey, editValue] of edits) {
            const arrayKey = editKey - editOffset;
            if (editValue === null) {
              node.splice(arrayKey, 1);
              editOffset++;
            } else {
              node[arrayKey] = editValue;
            }
          }
        } else {
          node = Object.defineProperties({}, Object.getOwnPropertyDescriptors(node));
          for (const [editKey, editValue] of edits) {
            node[editKey] = editValue;
          }
        }
      }
      index = stack.index;
      keys = stack.keys;
      edits = stack.edits;
      inArray = stack.inArray;
      stack = stack.prev;
    } else if (parent) {
      key = inArray ? index : keys[index];
      node = parent[key];
      if (node === null || node === undefined) {
        continue;
      }
      path.push(key);
    }
    let result;
    if (!Array.isArray(node)) {
      var _enterLeaveMap$get, _enterLeaveMap$get2;
      isNode(node) || devAssert(false, `Invalid AST Node: ${inspect(node)}.`);
      const visitFn = isLeaving ? (_enterLeaveMap$get = enterLeaveMap.get(node.kind)) === null || _enterLeaveMap$get === undefined ? undefined : _enterLeaveMap$get.leave : (_enterLeaveMap$get2 = enterLeaveMap.get(node.kind)) === null || _enterLeaveMap$get2 === undefined ? undefined : _enterLeaveMap$get2.enter;
      result = visitFn === null || visitFn === undefined ? undefined : visitFn.call(visitor, node, key, parent, path, ancestors);
      if (result === BREAK) {
        break;
      }
      if (result === false) {
        if (!isLeaving) {
          path.pop();
          continue;
        }
      } else if (result !== undefined) {
        edits.push([key, result]);
        if (!isLeaving) {
          if (isNode(result)) {
            node = result;
          } else {
            path.pop();
            continue;
          }
        }
      }
    }
    if (result === undefined && isEdited) {
      edits.push([key, node]);
    }
    if (isLeaving) {
      path.pop();
    } else {
      var _node$kind;
      stack = {
        inArray,
        index,
        keys,
        edits,
        prev: stack
      };
      inArray = Array.isArray(node);
      keys = inArray ? node : (_node$kind = visitorKeys[node.kind]) !== null && _node$kind !== undefined ? _node$kind : [];
      index = -1;
      edits = [];
      if (parent) {
        ancestors.push(parent);
      }
      parent = node;
    }
  } while (stack !== undefined);
  if (edits.length !== 0) {
    return edits[edits.length - 1][1];
  }
  return root;
}
function visitInParallel(visitors) {
  const skipping = new Array(visitors.length).fill(null);
  const mergedVisitor = Object.create(null);
  for (const kind of Object.values(Kind)) {
    let hasVisitor = false;
    const enterList = new Array(visitors.length).fill(undefined);
    const leaveList = new Array(visitors.length).fill(undefined);
    for (let i = 0;i < visitors.length; ++i) {
      const { enter, leave } = getEnterLeaveForKind(visitors[i], kind);
      hasVisitor || (hasVisitor = enter != null || leave != null);
      enterList[i] = enter;
      leaveList[i] = leave;
    }
    if (!hasVisitor) {
      continue;
    }
    const mergedEnterLeave = {
      enter(...args) {
        const node = args[0];
        for (let i = 0;i < visitors.length; i++) {
          if (skipping[i] === null) {
            var _enterList$i;
            const result = (_enterList$i = enterList[i]) === null || _enterList$i === undefined ? undefined : _enterList$i.apply(visitors[i], args);
            if (result === false) {
              skipping[i] = node;
            } else if (result === BREAK) {
              skipping[i] = BREAK;
            } else if (result !== undefined) {
              return result;
            }
          }
        }
      },
      leave(...args) {
        const node = args[0];
        for (let i = 0;i < visitors.length; i++) {
          if (skipping[i] === null) {
            var _leaveList$i;
            const result = (_leaveList$i = leaveList[i]) === null || _leaveList$i === undefined ? undefined : _leaveList$i.apply(visitors[i], args);
            if (result === BREAK) {
              skipping[i] = BREAK;
            } else if (result !== undefined && result !== false) {
              return result;
            }
          } else if (skipping[i] === node) {
            skipping[i] = null;
          }
        }
      }
    };
    mergedVisitor[kind] = mergedEnterLeave;
  }
  return mergedVisitor;
}
function getEnterLeaveForKind(visitor, kind) {
  const kindVisitor = visitor[kind];
  if (typeof kindVisitor === "object") {
    return kindVisitor;
  } else if (typeof kindVisitor === "function") {
    return {
      enter: kindVisitor,
      leave: undefined
    };
  }
  return {
    enter: visitor.enter,
    leave: visitor.leave
  };
}
var BREAK = Object.freeze({});

// node_modules/graphql/language/printer.mjs
function print(ast4) {
  return visit(ast4, printDocASTReducer);
}
var join = function(maybeArray, separator = "") {
  var _maybeArray$filter$jo;
  return (_maybeArray$filter$jo = maybeArray === null || maybeArray === undefined ? undefined : maybeArray.filter((x) => x).join(separator)) !== null && _maybeArray$filter$jo !== undefined ? _maybeArray$filter$jo : "";
};
var block = function(array) {
  return wrap("{\n", indent(join(array, "\n")), "\n}");
};
var wrap = function(start, maybeString, end = "") {
  return maybeString != null && maybeString !== "" ? start + maybeString + end : "";
};
var indent = function(str) {
  return wrap("  ", str.replace(/\n/g, "\n  "));
};
var hasMultilineItems = function(maybeArray) {
  var _maybeArray$some;
  return (_maybeArray$some = maybeArray === null || maybeArray === undefined ? undefined : maybeArray.some((str) => str.includes("\n"))) !== null && _maybeArray$some !== undefined ? _maybeArray$some : false;
};
var MAX_LINE_LENGTH = 80;
var printDocASTReducer = {
  Name: {
    leave: (node) => node.value
  },
  Variable: {
    leave: (node) => "$" + node.name
  },
  Document: {
    leave: (node) => join(node.definitions, "\n\n")
  },
  OperationDefinition: {
    leave(node) {
      const varDefs = wrap("(", join(node.variableDefinitions, ", "), ")");
      const prefix = join([
        node.operation,
        join([node.name, varDefs]),
        join(node.directives, " ")
      ], " ");
      return (prefix === "query" ? "" : prefix + " ") + node.selectionSet;
    }
  },
  VariableDefinition: {
    leave: ({ variable, type, defaultValue, directives }) => variable + ": " + type + wrap(" = ", defaultValue) + wrap(" ", join(directives, " "))
  },
  SelectionSet: {
    leave: ({ selections }) => block(selections)
  },
  Field: {
    leave({ alias, name, arguments: args, directives, selectionSet }) {
      const prefix = wrap("", alias, ": ") + name;
      let argsLine = prefix + wrap("(", join(args, ", "), ")");
      if (argsLine.length > MAX_LINE_LENGTH) {
        argsLine = prefix + wrap("(\n", indent(join(args, "\n")), "\n)");
      }
      return join([argsLine, join(directives, " "), selectionSet], " ");
    }
  },
  Argument: {
    leave: ({ name, value }) => name + ": " + value
  },
  FragmentSpread: {
    leave: ({ name, directives }) => "..." + name + wrap(" ", join(directives, " "))
  },
  InlineFragment: {
    leave: ({ typeCondition, directives, selectionSet }) => join([
      "...",
      wrap("on ", typeCondition),
      join(directives, " "),
      selectionSet
    ], " ")
  },
  FragmentDefinition: {
    leave: ({ name, typeCondition, variableDefinitions, directives, selectionSet }) => `fragment ${name}${wrap("(", join(variableDefinitions, ", "), ")")} ` + `on ${typeCondition} ${wrap("", join(directives, " "), " ")}` + selectionSet
  },
  IntValue: {
    leave: ({ value }) => value
  },
  FloatValue: {
    leave: ({ value }) => value
  },
  StringValue: {
    leave: ({ value, block: isBlockString }) => isBlockString ? printBlockString(value) : printString(value)
  },
  BooleanValue: {
    leave: ({ value }) => value ? "true" : "false"
  },
  NullValue: {
    leave: () => "null"
  },
  EnumValue: {
    leave: ({ value }) => value
  },
  ListValue: {
    leave: ({ values }) => "[" + join(values, ", ") + "]"
  },
  ObjectValue: {
    leave: ({ fields }) => "{" + join(fields, ", ") + "}"
  },
  ObjectField: {
    leave: ({ name, value }) => name + ": " + value
  },
  Directive: {
    leave: ({ name, arguments: args }) => "@" + name + wrap("(", join(args, ", "), ")")
  },
  NamedType: {
    leave: ({ name }) => name
  },
  ListType: {
    leave: ({ type }) => "[" + type + "]"
  },
  NonNullType: {
    leave: ({ type }) => type + "!"
  },
  SchemaDefinition: {
    leave: ({ description, directives, operationTypes }) => wrap("", description, "\n") + join(["schema", join(directives, " "), block(operationTypes)], " ")
  },
  OperationTypeDefinition: {
    leave: ({ operation, type }) => operation + ": " + type
  },
  ScalarTypeDefinition: {
    leave: ({ description, name, directives }) => wrap("", description, "\n") + join(["scalar", name, join(directives, " ")], " ")
  },
  ObjectTypeDefinition: {
    leave: ({ description, name, interfaces, directives, fields }) => wrap("", description, "\n") + join([
      "type",
      name,
      wrap("implements ", join(interfaces, " & ")),
      join(directives, " "),
      block(fields)
    ], " ")
  },
  FieldDefinition: {
    leave: ({ description, name, arguments: args, type, directives }) => wrap("", description, "\n") + name + (hasMultilineItems(args) ? wrap("(\n", indent(join(args, "\n")), "\n)") : wrap("(", join(args, ", "), ")")) + ": " + type + wrap(" ", join(directives, " "))
  },
  InputValueDefinition: {
    leave: ({ description, name, type, defaultValue, directives }) => wrap("", description, "\n") + join([name + ": " + type, wrap("= ", defaultValue), join(directives, " ")], " ")
  },
  InterfaceTypeDefinition: {
    leave: ({ description, name, interfaces, directives, fields }) => wrap("", description, "\n") + join([
      "interface",
      name,
      wrap("implements ", join(interfaces, " & ")),
      join(directives, " "),
      block(fields)
    ], " ")
  },
  UnionTypeDefinition: {
    leave: ({ description, name, directives, types }) => wrap("", description, "\n") + join(["union", name, join(directives, " "), wrap("= ", join(types, " | "))], " ")
  },
  EnumTypeDefinition: {
    leave: ({ description, name, directives, values }) => wrap("", description, "\n") + join(["enum", name, join(directives, " "), block(values)], " ")
  },
  EnumValueDefinition: {
    leave: ({ description, name, directives }) => wrap("", description, "\n") + join([name, join(directives, " ")], " ")
  },
  InputObjectTypeDefinition: {
    leave: ({ description, name, directives, fields }) => wrap("", description, "\n") + join(["input", name, join(directives, " "), block(fields)], " ")
  },
  DirectiveDefinition: {
    leave: ({ description, name, arguments: args, repeatable, locations }) => wrap("", description, "\n") + "directive @" + name + (hasMultilineItems(args) ? wrap("(\n", indent(join(args, "\n")), "\n)") : wrap("(", join(args, ", "), ")")) + (repeatable ? " repeatable" : "") + " on " + join(locations, " | ")
  },
  SchemaExtension: {
    leave: ({ directives, operationTypes }) => join(["extend schema", join(directives, " "), block(operationTypes)], " ")
  },
  ScalarTypeExtension: {
    leave: ({ name, directives }) => join(["extend scalar", name, join(directives, " ")], " ")
  },
  ObjectTypeExtension: {
    leave: ({ name, interfaces, directives, fields }) => join([
      "extend type",
      name,
      wrap("implements ", join(interfaces, " & ")),
      join(directives, " "),
      block(fields)
    ], " ")
  },
  InterfaceTypeExtension: {
    leave: ({ name, interfaces, directives, fields }) => join([
      "extend interface",
      name,
      wrap("implements ", join(interfaces, " & ")),
      join(directives, " "),
      block(fields)
    ], " ")
  },
  UnionTypeExtension: {
    leave: ({ name, directives, types }) => join([
      "extend union",
      name,
      join(directives, " "),
      wrap("= ", join(types, " | "))
    ], " ")
  },
  EnumTypeExtension: {
    leave: ({ name, directives, values }) => join(["extend enum", name, join(directives, " "), block(values)], " ")
  },
  InputObjectTypeExtension: {
    leave: ({ name, directives, fields }) => join(["extend input", name, join(directives, " "), block(fields)], " ")
  }
};

// node_modules/graphql/utilities/valueFromASTUntyped.mjs
function valueFromASTUntyped(valueNode, variables) {
  switch (valueNode.kind) {
    case Kind.NULL:
      return null;
    case Kind.INT:
      return parseInt(valueNode.value, 10);
    case Kind.FLOAT:
      return parseFloat(valueNode.value);
    case Kind.STRING:
    case Kind.ENUM:
    case Kind.BOOLEAN:
      return valueNode.value;
    case Kind.LIST:
      return valueNode.values.map((node) => valueFromASTUntyped(node, variables));
    case Kind.OBJECT:
      return keyValMap(valueNode.fields, (field) => field.name.value, (field) => valueFromASTUntyped(field.value, variables));
    case Kind.VARIABLE:
      return variables === null || variables === undefined ? undefined : variables[valueNode.name.value];
  }
}

// node_modules/graphql/type/assertName.mjs
function assertName(name) {
  name != null || devAssert(false, "Must provide name.");
  typeof name === "string" || devAssert(false, "Expected name to be a string.");
  if (name.length === 0) {
    throw new GraphQLError("Expected name to be a non-empty string.");
  }
  for (let i = 1;i < name.length; ++i) {
    if (!isNameContinue(name.charCodeAt(i))) {
      throw new GraphQLError(`Names must only contain [_a-zA-Z0-9] but "${name}" does not.`);
    }
  }
  if (!isNameStart(name.charCodeAt(0))) {
    throw new GraphQLError(`Names must start with [_a-zA-Z] but "${name}" does not.`);
  }
  return name;
}
function assertEnumValueName(name) {
  if (name === "true" || name === "false" || name === "null") {
    throw new GraphQLError(`Enum values cannot be named: ${name}`);
  }
  return assertName(name);
}

// node_modules/graphql/type/definition.mjs
function isType(type) {
  return isScalarType(type) || isObjectType(type) || isInterfaceType(type) || isUnionType(type) || isEnumType(type) || isInputObjectType(type) || isListType(type) || isNonNullType(type);
}
function isScalarType(type) {
  return instanceOf(type, GraphQLScalarType);
}
function isObjectType(type) {
  return instanceOf(type, GraphQLObjectType);
}
function isInterfaceType(type) {
  return instanceOf(type, GraphQLInterfaceType);
}
function isUnionType(type) {
  return instanceOf(type, GraphQLUnionType);
}
function isEnumType(type) {
  return instanceOf(type, GraphQLEnumType);
}
function isInputObjectType(type) {
  return instanceOf(type, GraphQLInputObjectType);
}
function isListType(type) {
  return instanceOf(type, GraphQLList);
}
function isNonNullType(type) {
  return instanceOf(type, GraphQLNonNull);
}
function isInputType(type) {
  return isScalarType(type) || isEnumType(type) || isInputObjectType(type) || isWrappingType(type) && isInputType(type.ofType);
}
function isOutputType(type) {
  return isScalarType(type) || isObjectType(type) || isInterfaceType(type) || isUnionType(type) || isEnumType(type) || isWrappingType(type) && isOutputType(type.ofType);
}
function isLeafType(type) {
  return isScalarType(type) || isEnumType(type);
}
function isCompositeType(type) {
  return isObjectType(type) || isInterfaceType(type) || isUnionType(type);
}
function isAbstractType(type) {
  return isInterfaceType(type) || isUnionType(type);
}
function isWrappingType(type) {
  return isListType(type) || isNonNullType(type);
}
function isNullableType(type) {
  return isType(type) && !isNonNullType(type);
}
function getNullableType(type) {
  if (type) {
    return isNonNullType(type) ? type.ofType : type;
  }
}
function isNamedType(type) {
  return isScalarType(type) || isObjectType(type) || isInterfaceType(type) || isUnionType(type) || isEnumType(type) || isInputObjectType(type);
}
function getNamedType(type) {
  if (type) {
    let unwrappedType = type;
    while (isWrappingType(unwrappedType)) {
      unwrappedType = unwrappedType.ofType;
    }
    return unwrappedType;
  }
}
function resolveReadonlyArrayThunk(thunk) {
  return typeof thunk === "function" ? thunk() : thunk;
}
function resolveObjMapThunk(thunk) {
  return typeof thunk === "function" ? thunk() : thunk;
}
var defineInterfaces = function(config) {
  var _config$interfaces;
  const interfaces = resolveReadonlyArrayThunk((_config$interfaces = config.interfaces) !== null && _config$interfaces !== undefined ? _config$interfaces : []);
  Array.isArray(interfaces) || devAssert(false, `${config.name} interfaces must be an Array or a function which returns an Array.`);
  return interfaces;
};
var defineFieldMap = function(config) {
  const fieldMap = resolveObjMapThunk(config.fields);
  isPlainObj(fieldMap) || devAssert(false, `${config.name} fields must be an object with field names as keys or a function which returns such an object.`);
  return mapValue(fieldMap, (fieldConfig, fieldName) => {
    var _fieldConfig$args;
    isPlainObj(fieldConfig) || devAssert(false, `${config.name}.${fieldName} field config must be an object.`);
    fieldConfig.resolve == null || typeof fieldConfig.resolve === "function" || devAssert(false, `${config.name}.${fieldName} field resolver must be a function if ` + `provided, but got: ${inspect(fieldConfig.resolve)}.`);
    const argsConfig = (_fieldConfig$args = fieldConfig.args) !== null && _fieldConfig$args !== undefined ? _fieldConfig$args : {};
    isPlainObj(argsConfig) || devAssert(false, `${config.name}.${fieldName} args must be an object with argument names as keys.`);
    return {
      name: assertName(fieldName),
      description: fieldConfig.description,
      type: fieldConfig.type,
      args: defineArguments(argsConfig),
      resolve: fieldConfig.resolve,
      subscribe: fieldConfig.subscribe,
      deprecationReason: fieldConfig.deprecationReason,
      extensions: toObjMap(fieldConfig.extensions),
      astNode: fieldConfig.astNode
    };
  });
};
function defineArguments(config) {
  return Object.entries(config).map(([argName, argConfig]) => ({
    name: assertName(argName),
    description: argConfig.description,
    type: argConfig.type,
    defaultValue: argConfig.defaultValue,
    deprecationReason: argConfig.deprecationReason,
    extensions: toObjMap(argConfig.extensions),
    astNode: argConfig.astNode
  }));
}
var isPlainObj = function(obj) {
  return isObjectLike(obj) && !Array.isArray(obj);
};
var fieldsToFieldsConfig = function(fields) {
  return mapValue(fields, (field) => ({
    description: field.description,
    type: field.type,
    args: argsToArgsConfig(field.args),
    resolve: field.resolve,
    subscribe: field.subscribe,
    deprecationReason: field.deprecationReason,
    extensions: field.extensions,
    astNode: field.astNode
  }));
};
function argsToArgsConfig(args) {
  return keyValMap(args, (arg) => arg.name, (arg) => ({
    description: arg.description,
    type: arg.type,
    defaultValue: arg.defaultValue,
    deprecationReason: arg.deprecationReason,
    extensions: arg.extensions,
    astNode: arg.astNode
  }));
}
function isRequiredArgument(arg) {
  return isNonNullType(arg.type) && arg.defaultValue === undefined;
}
var defineTypes = function(config) {
  const types = resolveReadonlyArrayThunk(config.types);
  Array.isArray(types) || devAssert(false, `Must provide Array of types or a function which returns such an array for Union ${config.name}.`);
  return types;
};
var didYouMeanEnumValue = function(enumType, unknownValueStr) {
  const allNames = enumType.getValues().map((value) => value.name);
  const suggestedValues = suggestionList(unknownValueStr, allNames);
  return didYouMean("the enum value", suggestedValues);
};
var defineEnumValues = function(typeName, valueMap) {
  isPlainObj(valueMap) || devAssert(false, `${typeName} values must be an object with value names as keys.`);
  return Object.entries(valueMap).map(([valueName, valueConfig]) => {
    isPlainObj(valueConfig) || devAssert(false, `${typeName}.${valueName} must refer to an object with a "value" key ` + `representing an internal value but got: ${inspect(valueConfig)}.`);
    return {
      name: assertEnumValueName(valueName),
      description: valueConfig.description,
      value: valueConfig.value !== undefined ? valueConfig.value : valueName,
      deprecationReason: valueConfig.deprecationReason,
      extensions: toObjMap(valueConfig.extensions),
      astNode: valueConfig.astNode
    };
  });
};
var defineInputFieldMap = function(config) {
  const fieldMap = resolveObjMapThunk(config.fields);
  isPlainObj(fieldMap) || devAssert(false, `${config.name} fields must be an object with field names as keys or a function which returns such an object.`);
  return mapValue(fieldMap, (fieldConfig, fieldName) => {
    !("resolve" in fieldConfig) || devAssert(false, `${config.name}.${fieldName} field has a resolve property, but Input Types cannot define resolvers.`);
    return {
      name: assertName(fieldName),
      description: fieldConfig.description,
      type: fieldConfig.type,
      defaultValue: fieldConfig.defaultValue,
      deprecationReason: fieldConfig.deprecationReason,
      extensions: toObjMap(fieldConfig.extensions),
      astNode: fieldConfig.astNode
    };
  });
};
function isRequiredInputField(field) {
  return isNonNullType(field.type) && field.defaultValue === undefined;
}

class GraphQLList {
  constructor(ofType) {
    isType(ofType) || devAssert(false, `Expected ${inspect(ofType)} to be a GraphQL type.`);
    this.ofType = ofType;
  }
  get [Symbol.toStringTag]() {
    return "GraphQLList";
  }
  toString() {
    return "[" + String(this.ofType) + "]";
  }
  toJSON() {
    return this.toString();
  }
}

class GraphQLNonNull {
  constructor(ofType) {
    isNullableType(ofType) || devAssert(false, `Expected ${inspect(ofType)} to be a GraphQL nullable type.`);
    this.ofType = ofType;
  }
  get [Symbol.toStringTag]() {
    return "GraphQLNonNull";
  }
  toString() {
    return String(this.ofType) + "!";
  }
  toJSON() {
    return this.toString();
  }
}

class GraphQLScalarType {
  constructor(config) {
    var _config$parseValue, _config$serialize, _config$parseLiteral, _config$extensionASTN;
    const parseValue = (_config$parseValue = config.parseValue) !== null && _config$parseValue !== undefined ? _config$parseValue : identityFunc;
    this.name = assertName(config.name);
    this.description = config.description;
    this.specifiedByURL = config.specifiedByURL;
    this.serialize = (_config$serialize = config.serialize) !== null && _config$serialize !== undefined ? _config$serialize : identityFunc;
    this.parseValue = parseValue;
    this.parseLiteral = (_config$parseLiteral = config.parseLiteral) !== null && _config$parseLiteral !== undefined ? _config$parseLiteral : (node, variables) => parseValue(valueFromASTUntyped(node, variables));
    this.extensions = toObjMap(config.extensions);
    this.astNode = config.astNode;
    this.extensionASTNodes = (_config$extensionASTN = config.extensionASTNodes) !== null && _config$extensionASTN !== undefined ? _config$extensionASTN : [];
    config.specifiedByURL == null || typeof config.specifiedByURL === "string" || devAssert(false, `${this.name} must provide "specifiedByURL" as a string, ` + `but got: ${inspect(config.specifiedByURL)}.`);
    config.serialize == null || typeof config.serialize === "function" || devAssert(false, `${this.name} must provide "serialize" function. If this custom Scalar is also used as an input type, ensure "parseValue" and "parseLiteral" functions are also provided.`);
    if (config.parseLiteral) {
      typeof config.parseValue === "function" && typeof config.parseLiteral === "function" || devAssert(false, `${this.name} must provide both "parseValue" and "parseLiteral" functions.`);
    }
  }
  get [Symbol.toStringTag]() {
    return "GraphQLScalarType";
  }
  toConfig() {
    return {
      name: this.name,
      description: this.description,
      specifiedByURL: this.specifiedByURL,
      serialize: this.serialize,
      parseValue: this.parseValue,
      parseLiteral: this.parseLiteral,
      extensions: this.extensions,
      astNode: this.astNode,
      extensionASTNodes: this.extensionASTNodes
    };
  }
  toString() {
    return this.name;
  }
  toJSON() {
    return this.toString();
  }
}

class GraphQLObjectType {
  constructor(config) {
    var _config$extensionASTN2;
    this.name = assertName(config.name);
    this.description = config.description;
    this.isTypeOf = config.isTypeOf;
    this.extensions = toObjMap(config.extensions);
    this.astNode = config.astNode;
    this.extensionASTNodes = (_config$extensionASTN2 = config.extensionASTNodes) !== null && _config$extensionASTN2 !== undefined ? _config$extensionASTN2 : [];
    this._fields = () => defineFieldMap(config);
    this._interfaces = () => defineInterfaces(config);
    config.isTypeOf == null || typeof config.isTypeOf === "function" || devAssert(false, `${this.name} must provide "isTypeOf" as a function, ` + `but got: ${inspect(config.isTypeOf)}.`);
  }
  get [Symbol.toStringTag]() {
    return "GraphQLObjectType";
  }
  getFields() {
    if (typeof this._fields === "function") {
      this._fields = this._fields();
    }
    return this._fields;
  }
  getInterfaces() {
    if (typeof this._interfaces === "function") {
      this._interfaces = this._interfaces();
    }
    return this._interfaces;
  }
  toConfig() {
    return {
      name: this.name,
      description: this.description,
      interfaces: this.getInterfaces(),
      fields: fieldsToFieldsConfig(this.getFields()),
      isTypeOf: this.isTypeOf,
      extensions: this.extensions,
      astNode: this.astNode,
      extensionASTNodes: this.extensionASTNodes
    };
  }
  toString() {
    return this.name;
  }
  toJSON() {
    return this.toString();
  }
}

class GraphQLInterfaceType {
  constructor(config) {
    var _config$extensionASTN3;
    this.name = assertName(config.name);
    this.description = config.description;
    this.resolveType = config.resolveType;
    this.extensions = toObjMap(config.extensions);
    this.astNode = config.astNode;
    this.extensionASTNodes = (_config$extensionASTN3 = config.extensionASTNodes) !== null && _config$extensionASTN3 !== undefined ? _config$extensionASTN3 : [];
    this._fields = defineFieldMap.bind(undefined, config);
    this._interfaces = defineInterfaces.bind(undefined, config);
    config.resolveType == null || typeof config.resolveType === "function" || devAssert(false, `${this.name} must provide "resolveType" as a function, ` + `but got: ${inspect(config.resolveType)}.`);
  }
  get [Symbol.toStringTag]() {
    return "GraphQLInterfaceType";
  }
  getFields() {
    if (typeof this._fields === "function") {
      this._fields = this._fields();
    }
    return this._fields;
  }
  getInterfaces() {
    if (typeof this._interfaces === "function") {
      this._interfaces = this._interfaces();
    }
    return this._interfaces;
  }
  toConfig() {
    return {
      name: this.name,
      description: this.description,
      interfaces: this.getInterfaces(),
      fields: fieldsToFieldsConfig(this.getFields()),
      resolveType: this.resolveType,
      extensions: this.extensions,
      astNode: this.astNode,
      extensionASTNodes: this.extensionASTNodes
    };
  }
  toString() {
    return this.name;
  }
  toJSON() {
    return this.toString();
  }
}

class GraphQLUnionType {
  constructor(config) {
    var _config$extensionASTN4;
    this.name = assertName(config.name);
    this.description = config.description;
    this.resolveType = config.resolveType;
    this.extensions = toObjMap(config.extensions);
    this.astNode = config.astNode;
    this.extensionASTNodes = (_config$extensionASTN4 = config.extensionASTNodes) !== null && _config$extensionASTN4 !== undefined ? _config$extensionASTN4 : [];
    this._types = defineTypes.bind(undefined, config);
    config.resolveType == null || typeof config.resolveType === "function" || devAssert(false, `${this.name} must provide "resolveType" as a function, ` + `but got: ${inspect(config.resolveType)}.`);
  }
  get [Symbol.toStringTag]() {
    return "GraphQLUnionType";
  }
  getTypes() {
    if (typeof this._types === "function") {
      this._types = this._types();
    }
    return this._types;
  }
  toConfig() {
    return {
      name: this.name,
      description: this.description,
      types: this.getTypes(),
      resolveType: this.resolveType,
      extensions: this.extensions,
      astNode: this.astNode,
      extensionASTNodes: this.extensionASTNodes
    };
  }
  toString() {
    return this.name;
  }
  toJSON() {
    return this.toString();
  }
}

class GraphQLEnumType {
  constructor(config) {
    var _config$extensionASTN5;
    this.name = assertName(config.name);
    this.description = config.description;
    this.extensions = toObjMap(config.extensions);
    this.astNode = config.astNode;
    this.extensionASTNodes = (_config$extensionASTN5 = config.extensionASTNodes) !== null && _config$extensionASTN5 !== undefined ? _config$extensionASTN5 : [];
    this._values = defineEnumValues(this.name, config.values);
    this._valueLookup = new Map(this._values.map((enumValue) => [enumValue.value, enumValue]));
    this._nameLookup = keyMap(this._values, (value) => value.name);
  }
  get [Symbol.toStringTag]() {
    return "GraphQLEnumType";
  }
  getValues() {
    return this._values;
  }
  getValue(name) {
    return this._nameLookup[name];
  }
  serialize(outputValue) {
    const enumValue = this._valueLookup.get(outputValue);
    if (enumValue === undefined) {
      throw new GraphQLError(`Enum "${this.name}" cannot represent value: ${inspect(outputValue)}`);
    }
    return enumValue.name;
  }
  parseValue(inputValue) {
    if (typeof inputValue !== "string") {
      const valueStr = inspect(inputValue);
      throw new GraphQLError(`Enum "${this.name}" cannot represent non-string value: ${valueStr}.` + didYouMeanEnumValue(this, valueStr));
    }
    const enumValue = this.getValue(inputValue);
    if (enumValue == null) {
      throw new GraphQLError(`Value "${inputValue}" does not exist in "${this.name}" enum.` + didYouMeanEnumValue(this, inputValue));
    }
    return enumValue.value;
  }
  parseLiteral(valueNode, _variables) {
    if (valueNode.kind !== Kind.ENUM) {
      const valueStr = print(valueNode);
      throw new GraphQLError(`Enum "${this.name}" cannot represent non-enum value: ${valueStr}.` + didYouMeanEnumValue(this, valueStr), {
        nodes: valueNode
      });
    }
    const enumValue = this.getValue(valueNode.value);
    if (enumValue == null) {
      const valueStr = print(valueNode);
      throw new GraphQLError(`Value "${valueStr}" does not exist in "${this.name}" enum.` + didYouMeanEnumValue(this, valueStr), {
        nodes: valueNode
      });
    }
    return enumValue.value;
  }
  toConfig() {
    const values = keyValMap(this.getValues(), (value) => value.name, (value) => ({
      description: value.description,
      value: value.value,
      deprecationReason: value.deprecationReason,
      extensions: value.extensions,
      astNode: value.astNode
    }));
    return {
      name: this.name,
      description: this.description,
      values,
      extensions: this.extensions,
      astNode: this.astNode,
      extensionASTNodes: this.extensionASTNodes
    };
  }
  toString() {
    return this.name;
  }
  toJSON() {
    return this.toString();
  }
}

class GraphQLInputObjectType {
  constructor(config) {
    var _config$extensionASTN6;
    this.name = assertName(config.name);
    this.description = config.description;
    this.extensions = toObjMap(config.extensions);
    this.astNode = config.astNode;
    this.extensionASTNodes = (_config$extensionASTN6 = config.extensionASTNodes) !== null && _config$extensionASTN6 !== undefined ? _config$extensionASTN6 : [];
    this._fields = defineInputFieldMap.bind(undefined, config);
  }
  get [Symbol.toStringTag]() {
    return "GraphQLInputObjectType";
  }
  getFields() {
    if (typeof this._fields === "function") {
      this._fields = this._fields();
    }
    return this._fields;
  }
  toConfig() {
    const fields = mapValue(this.getFields(), (field) => ({
      description: field.description,
      type: field.type,
      defaultValue: field.defaultValue,
      deprecationReason: field.deprecationReason,
      extensions: field.extensions,
      astNode: field.astNode
    }));
    return {
      name: this.name,
      description: this.description,
      fields,
      extensions: this.extensions,
      astNode: this.astNode,
      extensionASTNodes: this.extensionASTNodes
    };
  }
  toString() {
    return this.name;
  }
  toJSON() {
    return this.toString();
  }
}

// node_modules/graphql/utilities/typeComparators.mjs
function isEqualType(typeA, typeB) {
  if (typeA === typeB) {
    return true;
  }
  if (isNonNullType(typeA) && isNonNullType(typeB)) {
    return isEqualType(typeA.ofType, typeB.ofType);
  }
  if (isListType(typeA) && isListType(typeB)) {
    return isEqualType(typeA.ofType, typeB.ofType);
  }
  return false;
}
function isTypeSubTypeOf(schema, maybeSubType, superType) {
  if (maybeSubType === superType) {
    return true;
  }
  if (isNonNullType(superType)) {
    if (isNonNullType(maybeSubType)) {
      return isTypeSubTypeOf(schema, maybeSubType.ofType, superType.ofType);
    }
    return false;
  }
  if (isNonNullType(maybeSubType)) {
    return isTypeSubTypeOf(schema, maybeSubType.ofType, superType);
  }
  if (isListType(superType)) {
    if (isListType(maybeSubType)) {
      return isTypeSubTypeOf(schema, maybeSubType.ofType, superType.ofType);
    }
    return false;
  }
  if (isListType(maybeSubType)) {
    return false;
  }
  return isAbstractType(superType) && (isInterfaceType(maybeSubType) || isObjectType(maybeSubType)) && schema.isSubType(superType, maybeSubType);
}
function doTypesOverlap(schema, typeA, typeB) {
  if (typeA === typeB) {
    return true;
  }
  if (isAbstractType(typeA)) {
    if (isAbstractType(typeB)) {
      return schema.getPossibleTypes(typeA).some((type) => schema.isSubType(typeB, type));
    }
    return schema.isSubType(typeA, typeB);
  }
  if (isAbstractType(typeB)) {
    return schema.isSubType(typeB, typeA);
  }
  return false;
}

// node_modules/graphql/type/scalars.mjs
function isSpecifiedScalarType(type) {
  return specifiedScalarTypes.some(({ name }) => type.name === name);
}
var serializeObject = function(outputValue) {
  if (isObjectLike(outputValue)) {
    if (typeof outputValue.valueOf === "function") {
      const valueOfResult = outputValue.valueOf();
      if (!isObjectLike(valueOfResult)) {
        return valueOfResult;
      }
    }
    if (typeof outputValue.toJSON === "function") {
      return outputValue.toJSON();
    }
  }
  return outputValue;
};
var GRAPHQL_MAX_INT = 2147483647;
var GRAPHQL_MIN_INT = -2147483648;
var GraphQLInt = new GraphQLScalarType({
  name: "Int",
  description: "The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.",
  serialize(outputValue) {
    const coercedValue = serializeObject(outputValue);
    if (typeof coercedValue === "boolean") {
      return coercedValue ? 1 : 0;
    }
    let num = coercedValue;
    if (typeof coercedValue === "string" && coercedValue !== "") {
      num = Number(coercedValue);
    }
    if (typeof num !== "number" || !Number.isInteger(num)) {
      throw new GraphQLError(`Int cannot represent non-integer value: ${inspect(coercedValue)}`);
    }
    if (num > GRAPHQL_MAX_INT || num < GRAPHQL_MIN_INT) {
      throw new GraphQLError("Int cannot represent non 32-bit signed integer value: " + inspect(coercedValue));
    }
    return num;
  },
  parseValue(inputValue) {
    if (typeof inputValue !== "number" || !Number.isInteger(inputValue)) {
      throw new GraphQLError(`Int cannot represent non-integer value: ${inspect(inputValue)}`);
    }
    if (inputValue > GRAPHQL_MAX_INT || inputValue < GRAPHQL_MIN_INT) {
      throw new GraphQLError(`Int cannot represent non 32-bit signed integer value: ${inputValue}`);
    }
    return inputValue;
  },
  parseLiteral(valueNode) {
    if (valueNode.kind !== Kind.INT) {
      throw new GraphQLError(`Int cannot represent non-integer value: ${print(valueNode)}`, {
        nodes: valueNode
      });
    }
    const num = parseInt(valueNode.value, 10);
    if (num > GRAPHQL_MAX_INT || num < GRAPHQL_MIN_INT) {
      throw new GraphQLError(`Int cannot represent non 32-bit signed integer value: ${valueNode.value}`, {
        nodes: valueNode
      });
    }
    return num;
  }
});
var GraphQLFloat = new GraphQLScalarType({
  name: "Float",
  description: "The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](https://en.wikipedia.org/wiki/IEEE_floating_point).",
  serialize(outputValue) {
    const coercedValue = serializeObject(outputValue);
    if (typeof coercedValue === "boolean") {
      return coercedValue ? 1 : 0;
    }
    let num = coercedValue;
    if (typeof coercedValue === "string" && coercedValue !== "") {
      num = Number(coercedValue);
    }
    if (typeof num !== "number" || !Number.isFinite(num)) {
      throw new GraphQLError(`Float cannot represent non numeric value: ${inspect(coercedValue)}`);
    }
    return num;
  },
  parseValue(inputValue) {
    if (typeof inputValue !== "number" || !Number.isFinite(inputValue)) {
      throw new GraphQLError(`Float cannot represent non numeric value: ${inspect(inputValue)}`);
    }
    return inputValue;
  },
  parseLiteral(valueNode) {
    if (valueNode.kind !== Kind.FLOAT && valueNode.kind !== Kind.INT) {
      throw new GraphQLError(`Float cannot represent non numeric value: ${print(valueNode)}`, valueNode);
    }
    return parseFloat(valueNode.value);
  }
});
var GraphQLString = new GraphQLScalarType({
  name: "String",
  description: "The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.",
  serialize(outputValue) {
    const coercedValue = serializeObject(outputValue);
    if (typeof coercedValue === "string") {
      return coercedValue;
    }
    if (typeof coercedValue === "boolean") {
      return coercedValue ? "true" : "false";
    }
    if (typeof coercedValue === "number" && Number.isFinite(coercedValue)) {
      return coercedValue.toString();
    }
    throw new GraphQLError(`String cannot represent value: ${inspect(outputValue)}`);
  },
  parseValue(inputValue) {
    if (typeof inputValue !== "string") {
      throw new GraphQLError(`String cannot represent a non string value: ${inspect(inputValue)}`);
    }
    return inputValue;
  },
  parseLiteral(valueNode) {
    if (valueNode.kind !== Kind.STRING) {
      throw new GraphQLError(`String cannot represent a non string value: ${print(valueNode)}`, {
        nodes: valueNode
      });
    }
    return valueNode.value;
  }
});
var GraphQLBoolean = new GraphQLScalarType({
  name: "Boolean",
  description: "The `Boolean` scalar type represents `true` or `false`.",
  serialize(outputValue) {
    const coercedValue = serializeObject(outputValue);
    if (typeof coercedValue === "boolean") {
      return coercedValue;
    }
    if (Number.isFinite(coercedValue)) {
      return coercedValue !== 0;
    }
    throw new GraphQLError(`Boolean cannot represent a non boolean value: ${inspect(coercedValue)}`);
  },
  parseValue(inputValue) {
    if (typeof inputValue !== "boolean") {
      throw new GraphQLError(`Boolean cannot represent a non boolean value: ${inspect(inputValue)}`);
    }
    return inputValue;
  },
  parseLiteral(valueNode) {
    if (valueNode.kind !== Kind.BOOLEAN) {
      throw new GraphQLError(`Boolean cannot represent a non boolean value: ${print(valueNode)}`, {
        nodes: valueNode
      });
    }
    return valueNode.value;
  }
});
var GraphQLID = new GraphQLScalarType({
  name: "ID",
  description: 'The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.',
  serialize(outputValue) {
    const coercedValue = serializeObject(outputValue);
    if (typeof coercedValue === "string") {
      return coercedValue;
    }
    if (Number.isInteger(coercedValue)) {
      return String(coercedValue);
    }
    throw new GraphQLError(`ID cannot represent value: ${inspect(outputValue)}`);
  },
  parseValue(inputValue) {
    if (typeof inputValue === "string") {
      return inputValue;
    }
    if (typeof inputValue === "number" && Number.isInteger(inputValue)) {
      return inputValue.toString();
    }
    throw new GraphQLError(`ID cannot represent value: ${inspect(inputValue)}`);
  },
  parseLiteral(valueNode) {
    if (valueNode.kind !== Kind.STRING && valueNode.kind !== Kind.INT) {
      throw new GraphQLError("ID cannot represent a non-string and non-integer value: " + print(valueNode), {
        nodes: valueNode
      });
    }
    return valueNode.value;
  }
});
var specifiedScalarTypes = Object.freeze([
  GraphQLString,
  GraphQLInt,
  GraphQLFloat,
  GraphQLBoolean,
  GraphQLID
]);

// node_modules/graphql/type/directives.mjs
function isDirective(directive) {
  return instanceOf(directive, GraphQLDirective);
}
function isSpecifiedDirective(directive) {
  return specifiedDirectives.some(({ name }) => name === directive.name);
}

class GraphQLDirective {
  constructor(config) {
    var _config$isRepeatable, _config$args;
    this.name = assertName(config.name);
    this.description = config.description;
    this.locations = config.locations;
    this.isRepeatable = (_config$isRepeatable = config.isRepeatable) !== null && _config$isRepeatable !== undefined ? _config$isRepeatable : false;
    this.extensions = toObjMap(config.extensions);
    this.astNode = config.astNode;
    Array.isArray(config.locations) || devAssert(false, `@${config.name} locations must be an Array.`);
    const args = (_config$args = config.args) !== null && _config$args !== undefined ? _config$args : {};
    isObjectLike(args) && !Array.isArray(args) || devAssert(false, `@${config.name} args must be an object with argument names as keys.`);
    this.args = defineArguments(args);
  }
  get [Symbol.toStringTag]() {
    return "GraphQLDirective";
  }
  toConfig() {
    return {
      name: this.name,
      description: this.description,
      locations: this.locations,
      args: argsToArgsConfig(this.args),
      isRepeatable: this.isRepeatable,
      extensions: this.extensions,
      astNode: this.astNode
    };
  }
  toString() {
    return "@" + this.name;
  }
  toJSON() {
    return this.toString();
  }
}
var GraphQLIncludeDirective = new GraphQLDirective({
  name: "include",
  description: "Directs the executor to include this field or fragment only when the `if` argument is true.",
  locations: [
    DirectiveLocation.FIELD,
    DirectiveLocation.FRAGMENT_SPREAD,
    DirectiveLocation.INLINE_FRAGMENT
  ],
  args: {
    if: {
      type: new GraphQLNonNull(GraphQLBoolean),
      description: "Included when true."
    }
  }
});
var GraphQLSkipDirective = new GraphQLDirective({
  name: "skip",
  description: "Directs the executor to skip this field or fragment when the `if` argument is true.",
  locations: [
    DirectiveLocation.FIELD,
    DirectiveLocation.FRAGMENT_SPREAD,
    DirectiveLocation.INLINE_FRAGMENT
  ],
  args: {
    if: {
      type: new GraphQLNonNull(GraphQLBoolean),
      description: "Skipped when true."
    }
  }
});
var DEFAULT_DEPRECATION_REASON = "No longer supported";
var GraphQLDeprecatedDirective = new GraphQLDirective({
  name: "deprecated",
  description: "Marks an element of a GraphQL schema as no longer supported.",
  locations: [
    DirectiveLocation.FIELD_DEFINITION,
    DirectiveLocation.ARGUMENT_DEFINITION,
    DirectiveLocation.INPUT_FIELD_DEFINITION,
    DirectiveLocation.ENUM_VALUE
  ],
  args: {
    reason: {
      type: GraphQLString,
      description: "Explains why this element was deprecated, usually also including a suggestion for how to access supported similar data. Formatted using the Markdown syntax, as specified by [CommonMark](https://commonmark.org/).",
      defaultValue: DEFAULT_DEPRECATION_REASON
    }
  }
});
var GraphQLSpecifiedByDirective = new GraphQLDirective({
  name: "specifiedBy",
  description: "Exposes a URL that specifies the behavior of this scalar.",
  locations: [DirectiveLocation.SCALAR],
  args: {
    url: {
      type: new GraphQLNonNull(GraphQLString),
      description: "The URL that specifies the behavior of this scalar."
    }
  }
});
var specifiedDirectives = Object.freeze([
  GraphQLIncludeDirective,
  GraphQLSkipDirective,
  GraphQLDeprecatedDirective,
  GraphQLSpecifiedByDirective
]);

// node_modules/graphql/jsutils/isIterableObject.mjs
function isIterableObject(maybeIterable) {
  return typeof maybeIterable === "object" && typeof (maybeIterable === null || maybeIterable === undefined ? undefined : maybeIterable[Symbol.iterator]) === "function";
}

// node_modules/graphql/utilities/astFromValue.mjs
function astFromValue(value, type) {
  if (isNonNullType(type)) {
    const astValue = astFromValue(value, type.ofType);
    if ((astValue === null || astValue === undefined ? undefined : astValue.kind) === Kind.NULL) {
      return null;
    }
    return astValue;
  }
  if (value === null) {
    return {
      kind: Kind.NULL
    };
  }
  if (value === undefined) {
    return null;
  }
  if (isListType(type)) {
    const itemType = type.ofType;
    if (isIterableObject(value)) {
      const valuesNodes = [];
      for (const item of value) {
        const itemNode = astFromValue(item, itemType);
        if (itemNode != null) {
          valuesNodes.push(itemNode);
        }
      }
      return {
        kind: Kind.LIST,
        values: valuesNodes
      };
    }
    return astFromValue(value, itemType);
  }
  if (isInputObjectType(type)) {
    if (!isObjectLike(value)) {
      return null;
    }
    const fieldNodes = [];
    for (const field of Object.values(type.getFields())) {
      const fieldValue = astFromValue(value[field.name], field.type);
      if (fieldValue) {
        fieldNodes.push({
          kind: Kind.OBJECT_FIELD,
          name: {
            kind: Kind.NAME,
            value: field.name
          },
          value: fieldValue
        });
      }
    }
    return {
      kind: Kind.OBJECT,
      fields: fieldNodes
    };
  }
  if (isLeafType(type)) {
    const serialized = type.serialize(value);
    if (serialized == null) {
      return null;
    }
    if (typeof serialized === "boolean") {
      return {
        kind: Kind.BOOLEAN,
        value: serialized
      };
    }
    if (typeof serialized === "number" && Number.isFinite(serialized)) {
      const stringNum = String(serialized);
      return integerStringRegExp.test(stringNum) ? {
        kind: Kind.INT,
        value: stringNum
      } : {
        kind: Kind.FLOAT,
        value: stringNum
      };
    }
    if (typeof serialized === "string") {
      if (isEnumType(type)) {
        return {
          kind: Kind.ENUM,
          value: serialized
        };
      }
      if (type === GraphQLID && integerStringRegExp.test(serialized)) {
        return {
          kind: Kind.INT,
          value: serialized
        };
      }
      return {
        kind: Kind.STRING,
        value: serialized
      };
    }
    throw new TypeError(`Cannot convert value to AST: ${inspect(serialized)}.`);
  }
  invariant(false, "Unexpected input type: " + inspect(type));
}
var integerStringRegExp = /^-?(?:0|[1-9][0-9]*)$/;

// node_modules/graphql/type/introspection.mjs
function isIntrospectionType(type) {
  return introspectionTypes.some(({ name }) => type.name === name);
}
var __Schema = new GraphQLObjectType({
  name: "__Schema",
  description: "A GraphQL Schema defines the capabilities of a GraphQL server. It exposes all available types and directives on the server, as well as the entry points for query, mutation, and subscription operations.",
  fields: () => ({
    description: {
      type: GraphQLString,
      resolve: (schema) => schema.description
    },
    types: {
      description: "A list of all types supported by this server.",
      type: new GraphQLNonNull(new GraphQLList(new GraphQLNonNull(__Type))),
      resolve(schema) {
        return Object.values(schema.getTypeMap());
      }
    },
    queryType: {
      description: "The type that query operations will be rooted at.",
      type: new GraphQLNonNull(__Type),
      resolve: (schema) => schema.getQueryType()
    },
    mutationType: {
      description: "If this server supports mutation, the type that mutation operations will be rooted at.",
      type: __Type,
      resolve: (schema) => schema.getMutationType()
    },
    subscriptionType: {
      description: "If this server support subscription, the type that subscription operations will be rooted at.",
      type: __Type,
      resolve: (schema) => schema.getSubscriptionType()
    },
    directives: {
      description: "A list of all directives supported by this server.",
      type: new GraphQLNonNull(new GraphQLList(new GraphQLNonNull(__Directive))),
      resolve: (schema) => schema.getDirectives()
    }
  })
});
var __Directive = new GraphQLObjectType({
  name: "__Directive",
  description: "A Directive provides a way to describe alternate runtime execution and type validation behavior in a GraphQL document.\n\nIn some cases, you need to provide options to alter GraphQL's execution behavior in ways field arguments will not suffice, such as conditionally including or skipping a field. Directives provide this by describing additional information to the executor.",
  fields: () => ({
    name: {
      type: new GraphQLNonNull(GraphQLString),
      resolve: (directive) => directive.name
    },
    description: {
      type: GraphQLString,
      resolve: (directive) => directive.description
    },
    isRepeatable: {
      type: new GraphQLNonNull(GraphQLBoolean),
      resolve: (directive) => directive.isRepeatable
    },
    locations: {
      type: new GraphQLNonNull(new GraphQLList(new GraphQLNonNull(__DirectiveLocation))),
      resolve: (directive) => directive.locations
    },
    args: {
      type: new GraphQLNonNull(new GraphQLList(new GraphQLNonNull(__InputValue))),
      args: {
        includeDeprecated: {
          type: GraphQLBoolean,
          defaultValue: false
        }
      },
      resolve(field, { includeDeprecated }) {
        return includeDeprecated ? field.args : field.args.filter((arg) => arg.deprecationReason == null);
      }
    }
  })
});
var __DirectiveLocation = new GraphQLEnumType({
  name: "__DirectiveLocation",
  description: "A Directive can be adjacent to many parts of the GraphQL language, a __DirectiveLocation describes one such possible adjacencies.",
  values: {
    QUERY: {
      value: DirectiveLocation.QUERY,
      description: "Location adjacent to a query operation."
    },
    MUTATION: {
      value: DirectiveLocation.MUTATION,
      description: "Location adjacent to a mutation operation."
    },
    SUBSCRIPTION: {
      value: DirectiveLocation.SUBSCRIPTION,
      description: "Location adjacent to a subscription operation."
    },
    FIELD: {
      value: DirectiveLocation.FIELD,
      description: "Location adjacent to a field."
    },
    FRAGMENT_DEFINITION: {
      value: DirectiveLocation.FRAGMENT_DEFINITION,
      description: "Location adjacent to a fragment definition."
    },
    FRAGMENT_SPREAD: {
      value: DirectiveLocation.FRAGMENT_SPREAD,
      description: "Location adjacent to a fragment spread."
    },
    INLINE_FRAGMENT: {
      value: DirectiveLocation.INLINE_FRAGMENT,
      description: "Location adjacent to an inline fragment."
    },
    VARIABLE_DEFINITION: {
      value: DirectiveLocation.VARIABLE_DEFINITION,
      description: "Location adjacent to a variable definition."
    },
    SCHEMA: {
      value: DirectiveLocation.SCHEMA,
      description: "Location adjacent to a schema definition."
    },
    SCALAR: {
      value: DirectiveLocation.SCALAR,
      description: "Location adjacent to a scalar definition."
    },
    OBJECT: {
      value: DirectiveLocation.OBJECT,
      description: "Location adjacent to an object type definition."
    },
    FIELD_DEFINITION: {
      value: DirectiveLocation.FIELD_DEFINITION,
      description: "Location adjacent to a field definition."
    },
    ARGUMENT_DEFINITION: {
      value: DirectiveLocation.ARGUMENT_DEFINITION,
      description: "Location adjacent to an argument definition."
    },
    INTERFACE: {
      value: DirectiveLocation.INTERFACE,
      description: "Location adjacent to an interface definition."
    },
    UNION: {
      value: DirectiveLocation.UNION,
      description: "Location adjacent to a union definition."
    },
    ENUM: {
      value: DirectiveLocation.ENUM,
      description: "Location adjacent to an enum definition."
    },
    ENUM_VALUE: {
      value: DirectiveLocation.ENUM_VALUE,
      description: "Location adjacent to an enum value definition."
    },
    INPUT_OBJECT: {
      value: DirectiveLocation.INPUT_OBJECT,
      description: "Location adjacent to an input object type definition."
    },
    INPUT_FIELD_DEFINITION: {
      value: DirectiveLocation.INPUT_FIELD_DEFINITION,
      description: "Location adjacent to an input object field definition."
    }
  }
});
var __Type = new GraphQLObjectType({
  name: "__Type",
  description: "The fundamental unit of any GraphQL Schema is the type. There are many kinds of types in GraphQL as represented by the `__TypeKind` enum.\n\nDepending on the kind of a type, certain fields describe information about that type. Scalar types provide no information beyond a name, description and optional `specifiedByURL`, while Enum types provide their values. Object and Interface types provide the fields they describe. Abstract types, Union and Interface, provide the Object types possible at runtime. List and NonNull types compose other types.",
  fields: () => ({
    kind: {
      type: new GraphQLNonNull(__TypeKind),
      resolve(type) {
        if (isScalarType(type)) {
          return TypeKind.SCALAR;
        }
        if (isObjectType(type)) {
          return TypeKind.OBJECT;
        }
        if (isInterfaceType(type)) {
          return TypeKind.INTERFACE;
        }
        if (isUnionType(type)) {
          return TypeKind.UNION;
        }
        if (isEnumType(type)) {
          return TypeKind.ENUM;
        }
        if (isInputObjectType(type)) {
          return TypeKind.INPUT_OBJECT;
        }
        if (isListType(type)) {
          return TypeKind.LIST;
        }
        if (isNonNullType(type)) {
          return TypeKind.NON_NULL;
        }
        invariant(false, `Unexpected type: "${inspect(type)}".`);
      }
    },
    name: {
      type: GraphQLString,
      resolve: (type) => ("name" in type) ? type.name : undefined
    },
    description: {
      type: GraphQLString,
      resolve: (type) => ("description" in type) ? type.description : undefined
    },
    specifiedByURL: {
      type: GraphQLString,
      resolve: (obj) => ("specifiedByURL" in obj) ? obj.specifiedByURL : undefined
    },
    fields: {
      type: new GraphQLList(new GraphQLNonNull(__Field)),
      args: {
        includeDeprecated: {
          type: GraphQLBoolean,
          defaultValue: false
        }
      },
      resolve(type, { includeDeprecated }) {
        if (isObjectType(type) || isInterfaceType(type)) {
          const fields = Object.values(type.getFields());
          return includeDeprecated ? fields : fields.filter((field) => field.deprecationReason == null);
        }
      }
    },
    interfaces: {
      type: new GraphQLList(new GraphQLNonNull(__Type)),
      resolve(type) {
        if (isObjectType(type) || isInterfaceType(type)) {
          return type.getInterfaces();
        }
      }
    },
    possibleTypes: {
      type: new GraphQLList(new GraphQLNonNull(__Type)),
      resolve(type, _args, _context, { schema }) {
        if (isAbstractType(type)) {
          return schema.getPossibleTypes(type);
        }
      }
    },
    enumValues: {
      type: new GraphQLList(new GraphQLNonNull(__EnumValue)),
      args: {
        includeDeprecated: {
          type: GraphQLBoolean,
          defaultValue: false
        }
      },
      resolve(type, { includeDeprecated }) {
        if (isEnumType(type)) {
          const values = type.getValues();
          return includeDeprecated ? values : values.filter((field) => field.deprecationReason == null);
        }
      }
    },
    inputFields: {
      type: new GraphQLList(new GraphQLNonNull(__InputValue)),
      args: {
        includeDeprecated: {
          type: GraphQLBoolean,
          defaultValue: false
        }
      },
      resolve(type, { includeDeprecated }) {
        if (isInputObjectType(type)) {
          const values = Object.values(type.getFields());
          return includeDeprecated ? values : values.filter((field) => field.deprecationReason == null);
        }
      }
    },
    ofType: {
      type: __Type,
      resolve: (type) => ("ofType" in type) ? type.ofType : undefined
    }
  })
});
var __Field = new GraphQLObjectType({
  name: "__Field",
  description: "Object and Interface types are described by a list of Fields, each of which has a name, potentially a list of arguments, and a return type.",
  fields: () => ({
    name: {
      type: new GraphQLNonNull(GraphQLString),
      resolve: (field) => field.name
    },
    description: {
      type: GraphQLString,
      resolve: (field) => field.description
    },
    args: {
      type: new GraphQLNonNull(new GraphQLList(new GraphQLNonNull(__InputValue))),
      args: {
        includeDeprecated: {
          type: GraphQLBoolean,
          defaultValue: false
        }
      },
      resolve(field, { includeDeprecated }) {
        return includeDeprecated ? field.args : field.args.filter((arg) => arg.deprecationReason == null);
      }
    },
    type: {
      type: new GraphQLNonNull(__Type),
      resolve: (field) => field.type
    },
    isDeprecated: {
      type: new GraphQLNonNull(GraphQLBoolean),
      resolve: (field) => field.deprecationReason != null
    },
    deprecationReason: {
      type: GraphQLString,
      resolve: (field) => field.deprecationReason
    }
  })
});
var __InputValue = new GraphQLObjectType({
  name: "__InputValue",
  description: "Arguments provided to Fields or Directives and the input fields of an InputObject are represented as Input Values which describe their type and optionally a default value.",
  fields: () => ({
    name: {
      type: new GraphQLNonNull(GraphQLString),
      resolve: (inputValue) => inputValue.name
    },
    description: {
      type: GraphQLString,
      resolve: (inputValue) => inputValue.description
    },
    type: {
      type: new GraphQLNonNull(__Type),
      resolve: (inputValue) => inputValue.type
    },
    defaultValue: {
      type: GraphQLString,
      description: "A GraphQL-formatted string representing the default value for this input value.",
      resolve(inputValue) {
        const { type, defaultValue } = inputValue;
        const valueAST = astFromValue(defaultValue, type);
        return valueAST ? print(valueAST) : null;
      }
    },
    isDeprecated: {
      type: new GraphQLNonNull(GraphQLBoolean),
      resolve: (field) => field.deprecationReason != null
    },
    deprecationReason: {
      type: GraphQLString,
      resolve: (obj) => obj.deprecationReason
    }
  })
});
var __EnumValue = new GraphQLObjectType({
  name: "__EnumValue",
  description: "One possible value for a given Enum. Enum values are unique values, not a placeholder for a string or numeric value. However an Enum value is returned in a JSON response as a string.",
  fields: () => ({
    name: {
      type: new GraphQLNonNull(GraphQLString),
      resolve: (enumValue) => enumValue.name
    },
    description: {
      type: GraphQLString,
      resolve: (enumValue) => enumValue.description
    },
    isDeprecated: {
      type: new GraphQLNonNull(GraphQLBoolean),
      resolve: (enumValue) => enumValue.deprecationReason != null
    },
    deprecationReason: {
      type: GraphQLString,
      resolve: (enumValue) => enumValue.deprecationReason
    }
  })
});
var TypeKind;
(function(TypeKind2) {
  TypeKind2["SCALAR"] = "SCALAR";
  TypeKind2["OBJECT"] = "OBJECT";
  TypeKind2["INTERFACE"] = "INTERFACE";
  TypeKind2["UNION"] = "UNION";
  TypeKind2["ENUM"] = "ENUM";
  TypeKind2["INPUT_OBJECT"] = "INPUT_OBJECT";
  TypeKind2["LIST"] = "LIST";
  TypeKind2["NON_NULL"] = "NON_NULL";
})(TypeKind || (TypeKind = {}));
var __TypeKind = new GraphQLEnumType({
  name: "__TypeKind",
  description: "An enum describing what kind of type a given `__Type` is.",
  values: {
    SCALAR: {
      value: TypeKind.SCALAR,
      description: "Indicates this type is a scalar."
    },
    OBJECT: {
      value: TypeKind.OBJECT,
      description: "Indicates this type is an object. `fields` and `interfaces` are valid fields."
    },
    INTERFACE: {
      value: TypeKind.INTERFACE,
      description: "Indicates this type is an interface. `fields`, `interfaces`, and `possibleTypes` are valid fields."
    },
    UNION: {
      value: TypeKind.UNION,
      description: "Indicates this type is a union. `possibleTypes` is a valid field."
    },
    ENUM: {
      value: TypeKind.ENUM,
      description: "Indicates this type is an enum. `enumValues` is a valid field."
    },
    INPUT_OBJECT: {
      value: TypeKind.INPUT_OBJECT,
      description: "Indicates this type is an input object. `inputFields` is a valid field."
    },
    LIST: {
      value: TypeKind.LIST,
      description: "Indicates this type is a list. `ofType` is a valid field."
    },
    NON_NULL: {
      value: TypeKind.NON_NULL,
      description: "Indicates this type is a non-null. `ofType` is a valid field."
    }
  }
});
var SchemaMetaFieldDef = {
  name: "__schema",
  type: new GraphQLNonNull(__Schema),
  description: "Access the current type schema of this server.",
  args: [],
  resolve: (_source, _args, _context, { schema }) => schema,
  deprecationReason: undefined,
  extensions: Object.create(null),
  astNode: undefined
};
var TypeMetaFieldDef = {
  name: "__type",
  type: __Type,
  description: "Request the type information of a single type.",
  args: [
    {
      name: "name",
      description: undefined,
      type: new GraphQLNonNull(GraphQLString),
      defaultValue: undefined,
      deprecationReason: undefined,
      extensions: Object.create(null),
      astNode: undefined
    }
  ],
  resolve: (_source, { name }, _context, { schema }) => schema.getType(name),
  deprecationReason: undefined,
  extensions: Object.create(null),
  astNode: undefined
};
var TypeNameMetaFieldDef = {
  name: "__typename",
  type: new GraphQLNonNull(GraphQLString),
  description: "The name of the current Object type at runtime.",
  args: [],
  resolve: (_source, _args, _context, { parentType }) => parentType.name,
  deprecationReason: undefined,
  extensions: Object.create(null),
  astNode: undefined
};
var introspectionTypes = Object.freeze([
  __Schema,
  __Directive,
  __DirectiveLocation,
  __Type,
  __Field,
  __InputValue,
  __EnumValue,
  __TypeKind
]);

// node_modules/graphql/type/schema.mjs
function isSchema(schema) {
  return instanceOf(schema, GraphQLSchema);
}
function assertSchema(schema) {
  if (!isSchema(schema)) {
    throw new Error(`Expected ${inspect(schema)} to be a GraphQL schema.`);
  }
  return schema;
}
var collectReferencedTypes = function(type, typeSet) {
  const namedType = getNamedType(type);
  if (!typeSet.has(namedType)) {
    typeSet.add(namedType);
    if (isUnionType(namedType)) {
      for (const memberType of namedType.getTypes()) {
        collectReferencedTypes(memberType, typeSet);
      }
    } else if (isObjectType(namedType) || isInterfaceType(namedType)) {
      for (const interfaceType of namedType.getInterfaces()) {
        collectReferencedTypes(interfaceType, typeSet);
      }
      for (const field of Object.values(namedType.getFields())) {
        collectReferencedTypes(field.type, typeSet);
        for (const arg of field.args) {
          collectReferencedTypes(arg.type, typeSet);
        }
      }
    } else if (isInputObjectType(namedType)) {
      for (const field of Object.values(namedType.getFields())) {
        collectReferencedTypes(field.type, typeSet);
      }
    }
  }
  return typeSet;
};

class GraphQLSchema {
  constructor(config) {
    var _config$extensionASTN, _config$directives;
    this.__validationErrors = config.assumeValid === true ? [] : undefined;
    isObjectLike(config) || devAssert(false, "Must provide configuration object.");
    !config.types || Array.isArray(config.types) || devAssert(false, `"types" must be Array if provided but got: ${inspect(config.types)}.`);
    !config.directives || Array.isArray(config.directives) || devAssert(false, '"directives" must be Array if provided but got: ' + `${inspect(config.directives)}.`);
    this.description = config.description;
    this.extensions = toObjMap(config.extensions);
    this.astNode = config.astNode;
    this.extensionASTNodes = (_config$extensionASTN = config.extensionASTNodes) !== null && _config$extensionASTN !== undefined ? _config$extensionASTN : [];
    this._queryType = config.query;
    this._mutationType = config.mutation;
    this._subscriptionType = config.subscription;
    this._directives = (_config$directives = config.directives) !== null && _config$directives !== undefined ? _config$directives : specifiedDirectives;
    const allReferencedTypes = new Set(config.types);
    if (config.types != null) {
      for (const type of config.types) {
        allReferencedTypes.delete(type);
        collectReferencedTypes(type, allReferencedTypes);
      }
    }
    if (this._queryType != null) {
      collectReferencedTypes(this._queryType, allReferencedTypes);
    }
    if (this._mutationType != null) {
      collectReferencedTypes(this._mutationType, allReferencedTypes);
    }
    if (this._subscriptionType != null) {
      collectReferencedTypes(this._subscriptionType, allReferencedTypes);
    }
    for (const directive of this._directives) {
      if (isDirective(directive)) {
        for (const arg of directive.args) {
          collectReferencedTypes(arg.type, allReferencedTypes);
        }
      }
    }
    collectReferencedTypes(__Schema, allReferencedTypes);
    this._typeMap = Object.create(null);
    this._subTypeMap = Object.create(null);
    this._implementationsMap = Object.create(null);
    for (const namedType of allReferencedTypes) {
      if (namedType == null) {
        continue;
      }
      const typeName = namedType.name;
      typeName || devAssert(false, "One of the provided types for building the Schema is missing a name.");
      if (this._typeMap[typeName] !== undefined) {
        throw new Error(`Schema must contain uniquely named types but contains multiple types named "${typeName}".`);
      }
      this._typeMap[typeName] = namedType;
      if (isInterfaceType(namedType)) {
        for (const iface of namedType.getInterfaces()) {
          if (isInterfaceType(iface)) {
            let implementations = this._implementationsMap[iface.name];
            if (implementations === undefined) {
              implementations = this._implementationsMap[iface.name] = {
                objects: [],
                interfaces: []
              };
            }
            implementations.interfaces.push(namedType);
          }
        }
      } else if (isObjectType(namedType)) {
        for (const iface of namedType.getInterfaces()) {
          if (isInterfaceType(iface)) {
            let implementations = this._implementationsMap[iface.name];
            if (implementations === undefined) {
              implementations = this._implementationsMap[iface.name] = {
                objects: [],
                interfaces: []
              };
            }
            implementations.objects.push(namedType);
          }
        }
      }
    }
  }
  get [Symbol.toStringTag]() {
    return "GraphQLSchema";
  }
  getQueryType() {
    return this._queryType;
  }
  getMutationType() {
    return this._mutationType;
  }
  getSubscriptionType() {
    return this._subscriptionType;
  }
  getRootType(operation) {
    switch (operation) {
      case OperationTypeNode.QUERY:
        return this.getQueryType();
      case OperationTypeNode.MUTATION:
        return this.getMutationType();
      case OperationTypeNode.SUBSCRIPTION:
        return this.getSubscriptionType();
    }
  }
  getTypeMap() {
    return this._typeMap;
  }
  getType(name) {
    return this.getTypeMap()[name];
  }
  getPossibleTypes(abstractType) {
    return isUnionType(abstractType) ? abstractType.getTypes() : this.getImplementations(abstractType).objects;
  }
  getImplementations(interfaceType) {
    const implementations = this._implementationsMap[interfaceType.name];
    return implementations !== null && implementations !== undefined ? implementations : {
      objects: [],
      interfaces: []
    };
  }
  isSubType(abstractType, maybeSubType) {
    let map = this._subTypeMap[abstractType.name];
    if (map === undefined) {
      map = Object.create(null);
      if (isUnionType(abstractType)) {
        for (const type of abstractType.getTypes()) {
          map[type.name] = true;
        }
      } else {
        const implementations = this.getImplementations(abstractType);
        for (const type of implementations.objects) {
          map[type.name] = true;
        }
        for (const type of implementations.interfaces) {
          map[type.name] = true;
        }
      }
      this._subTypeMap[abstractType.name] = map;
    }
    return map[maybeSubType.name] !== undefined;
  }
  getDirectives() {
    return this._directives;
  }
  getDirective(name) {
    return this.getDirectives().find((directive) => directive.name === name);
  }
  toConfig() {
    return {
      description: this.description,
      query: this.getQueryType(),
      mutation: this.getMutationType(),
      subscription: this.getSubscriptionType(),
      types: Object.values(this.getTypeMap()),
      directives: this.getDirectives(),
      extensions: this.extensions,
      astNode: this.astNode,
      extensionASTNodes: this.extensionASTNodes,
      assumeValid: this.__validationErrors !== undefined
    };
  }
}

// node_modules/graphql/type/validate.mjs
function validateSchema(schema2) {
  assertSchema(schema2);
  if (schema2.__validationErrors) {
    return schema2.__validationErrors;
  }
  const context = new SchemaValidationContext(schema2);
  validateRootTypes(context);
  validateDirectives(context);
  validateTypes(context);
  const errors = context.getErrors();
  schema2.__validationErrors = errors;
  return errors;
}
function assertValidSchema(schema2) {
  const errors = validateSchema(schema2);
  if (errors.length !== 0) {
    throw new Error(errors.map((error) => error.message).join("\n\n"));
  }
}
var validateRootTypes = function(context) {
  const schema2 = context.schema;
  const queryType = schema2.getQueryType();
  if (!queryType) {
    context.reportError("Query root type must be provided.", schema2.astNode);
  } else if (!isObjectType(queryType)) {
    var _getOperationTypeNode;
    context.reportError(`Query root type must be Object type, it cannot be ${inspect(queryType)}.`, (_getOperationTypeNode = getOperationTypeNode(schema2, OperationTypeNode.QUERY)) !== null && _getOperationTypeNode !== undefined ? _getOperationTypeNode : queryType.astNode);
  }
  const mutationType = schema2.getMutationType();
  if (mutationType && !isObjectType(mutationType)) {
    var _getOperationTypeNode2;
    context.reportError("Mutation root type must be Object type if provided, it cannot be " + `${inspect(mutationType)}.`, (_getOperationTypeNode2 = getOperationTypeNode(schema2, OperationTypeNode.MUTATION)) !== null && _getOperationTypeNode2 !== undefined ? _getOperationTypeNode2 : mutationType.astNode);
  }
  const subscriptionType = schema2.getSubscriptionType();
  if (subscriptionType && !isObjectType(subscriptionType)) {
    var _getOperationTypeNode3;
    context.reportError("Subscription root type must be Object type if provided, it cannot be " + `${inspect(subscriptionType)}.`, (_getOperationTypeNode3 = getOperationTypeNode(schema2, OperationTypeNode.SUBSCRIPTION)) !== null && _getOperationTypeNode3 !== undefined ? _getOperationTypeNode3 : subscriptionType.astNode);
  }
};
var getOperationTypeNode = function(schema2, operation) {
  var _flatMap$find;
  return (_flatMap$find = [schema2.astNode, ...schema2.extensionASTNodes].flatMap((schemaNode) => {
    var _schemaNode$operation;
    return (_schemaNode$operation = schemaNode === null || schemaNode === undefined ? undefined : schemaNode.operationTypes) !== null && _schemaNode$operation !== undefined ? _schemaNode$operation : [];
  }).find((operationNode) => operationNode.operation === operation)) === null || _flatMap$find === undefined ? undefined : _flatMap$find.type;
};
var validateDirectives = function(context) {
  for (const directive of context.schema.getDirectives()) {
    if (!isDirective(directive)) {
      context.reportError(`Expected directive but got: ${inspect(directive)}.`, directive === null || directive === undefined ? undefined : directive.astNode);
      continue;
    }
    validateName(context, directive);
    for (const arg of directive.args) {
      validateName(context, arg);
      if (!isInputType(arg.type)) {
        context.reportError(`The type of @${directive.name}(${arg.name}:) must be Input Type ` + `but got: ${inspect(arg.type)}.`, arg.astNode);
      }
      if (isRequiredArgument(arg) && arg.deprecationReason != null) {
        var _arg$astNode;
        context.reportError(`Required argument @${directive.name}(${arg.name}:) cannot be deprecated.`, [
          getDeprecatedDirectiveNode(arg.astNode),
          (_arg$astNode = arg.astNode) === null || _arg$astNode === undefined ? undefined : _arg$astNode.type
        ]);
      }
    }
  }
};
var validateName = function(context, node) {
  if (node.name.startsWith("__")) {
    context.reportError(`Name "${node.name}" must not begin with "__", which is reserved by GraphQL introspection.`, node.astNode);
  }
};
var validateTypes = function(context) {
  const validateInputObjectCircularRefs = createInputObjectCircularRefsValidator(context);
  const typeMap = context.schema.getTypeMap();
  for (const type of Object.values(typeMap)) {
    if (!isNamedType(type)) {
      context.reportError(`Expected GraphQL named type but got: ${inspect(type)}.`, type.astNode);
      continue;
    }
    if (!isIntrospectionType(type)) {
      validateName(context, type);
    }
    if (isObjectType(type)) {
      validateFields(context, type);
      validateInterfaces(context, type);
    } else if (isInterfaceType(type)) {
      validateFields(context, type);
      validateInterfaces(context, type);
    } else if (isUnionType(type)) {
      validateUnionMembers(context, type);
    } else if (isEnumType(type)) {
      validateEnumValues(context, type);
    } else if (isInputObjectType(type)) {
      validateInputFields(context, type);
      validateInputObjectCircularRefs(type);
    }
  }
};
var validateFields = function(context, type) {
  const fields = Object.values(type.getFields());
  if (fields.length === 0) {
    context.reportError(`Type ${type.name} must define one or more fields.`, [
      type.astNode,
      ...type.extensionASTNodes
    ]);
  }
  for (const field of fields) {
    validateName(context, field);
    if (!isOutputType(field.type)) {
      var _field$astNode;
      context.reportError(`The type of ${type.name}.${field.name} must be Output Type ` + `but got: ${inspect(field.type)}.`, (_field$astNode = field.astNode) === null || _field$astNode === undefined ? undefined : _field$astNode.type);
    }
    for (const arg of field.args) {
      const argName = arg.name;
      validateName(context, arg);
      if (!isInputType(arg.type)) {
        var _arg$astNode2;
        context.reportError(`The type of ${type.name}.${field.name}(${argName}:) must be Input ` + `Type but got: ${inspect(arg.type)}.`, (_arg$astNode2 = arg.astNode) === null || _arg$astNode2 === undefined ? undefined : _arg$astNode2.type);
      }
      if (isRequiredArgument(arg) && arg.deprecationReason != null) {
        var _arg$astNode3;
        context.reportError(`Required argument ${type.name}.${field.name}(${argName}:) cannot be deprecated.`, [
          getDeprecatedDirectiveNode(arg.astNode),
          (_arg$astNode3 = arg.astNode) === null || _arg$astNode3 === undefined ? undefined : _arg$astNode3.type
        ]);
      }
    }
  }
};
var validateInterfaces = function(context, type) {
  const ifaceTypeNames = Object.create(null);
  for (const iface of type.getInterfaces()) {
    if (!isInterfaceType(iface)) {
      context.reportError(`Type ${inspect(type)} must only implement Interface types, ` + `it cannot implement ${inspect(iface)}.`, getAllImplementsInterfaceNodes(type, iface));
      continue;
    }
    if (type === iface) {
      context.reportError(`Type ${type.name} cannot implement itself because it would create a circular reference.`, getAllImplementsInterfaceNodes(type, iface));
      continue;
    }
    if (ifaceTypeNames[iface.name]) {
      context.reportError(`Type ${type.name} can only implement ${iface.name} once.`, getAllImplementsInterfaceNodes(type, iface));
      continue;
    }
    ifaceTypeNames[iface.name] = true;
    validateTypeImplementsAncestors(context, type, iface);
    validateTypeImplementsInterface(context, type, iface);
  }
};
var validateTypeImplementsInterface = function(context, type, iface) {
  const typeFieldMap = type.getFields();
  for (const ifaceField of Object.values(iface.getFields())) {
    const fieldName = ifaceField.name;
    const typeField = typeFieldMap[fieldName];
    if (!typeField) {
      context.reportError(`Interface field ${iface.name}.${fieldName} expected but ${type.name} does not provide it.`, [ifaceField.astNode, type.astNode, ...type.extensionASTNodes]);
      continue;
    }
    if (!isTypeSubTypeOf(context.schema, typeField.type, ifaceField.type)) {
      var _ifaceField$astNode, _typeField$astNode;
      context.reportError(`Interface field ${iface.name}.${fieldName} expects type ` + `${inspect(ifaceField.type)} but ${type.name}.${fieldName} ` + `is type ${inspect(typeField.type)}.`, [
        (_ifaceField$astNode = ifaceField.astNode) === null || _ifaceField$astNode === undefined ? undefined : _ifaceField$astNode.type,
        (_typeField$astNode = typeField.astNode) === null || _typeField$astNode === undefined ? undefined : _typeField$astNode.type
      ]);
    }
    for (const ifaceArg of ifaceField.args) {
      const argName = ifaceArg.name;
      const typeArg = typeField.args.find((arg) => arg.name === argName);
      if (!typeArg) {
        context.reportError(`Interface field argument ${iface.name}.${fieldName}(${argName}:) expected but ${type.name}.${fieldName} does not provide it.`, [ifaceArg.astNode, typeField.astNode]);
        continue;
      }
      if (!isEqualType(ifaceArg.type, typeArg.type)) {
        var _ifaceArg$astNode, _typeArg$astNode;
        context.reportError(`Interface field argument ${iface.name}.${fieldName}(${argName}:) ` + `expects type ${inspect(ifaceArg.type)} but ` + `${type.name}.${fieldName}(${argName}:) is type ` + `${inspect(typeArg.type)}.`, [
          (_ifaceArg$astNode = ifaceArg.astNode) === null || _ifaceArg$astNode === undefined ? undefined : _ifaceArg$astNode.type,
          (_typeArg$astNode = typeArg.astNode) === null || _typeArg$astNode === undefined ? undefined : _typeArg$astNode.type
        ]);
      }
    }
    for (const typeArg of typeField.args) {
      const argName = typeArg.name;
      const ifaceArg = ifaceField.args.find((arg) => arg.name === argName);
      if (!ifaceArg && isRequiredArgument(typeArg)) {
        context.reportError(`Object field ${type.name}.${fieldName} includes required argument ${argName} that is missing from the Interface field ${iface.name}.${fieldName}.`, [typeArg.astNode, ifaceField.astNode]);
      }
    }
  }
};
var validateTypeImplementsAncestors = function(context, type, iface) {
  const ifaceInterfaces = type.getInterfaces();
  for (const transitive of iface.getInterfaces()) {
    if (!ifaceInterfaces.includes(transitive)) {
      context.reportError(transitive === type ? `Type ${type.name} cannot implement ${iface.name} because it would create a circular reference.` : `Type ${type.name} must implement ${transitive.name} because it is implemented by ${iface.name}.`, [
        ...getAllImplementsInterfaceNodes(iface, transitive),
        ...getAllImplementsInterfaceNodes(type, iface)
      ]);
    }
  }
};
var validateUnionMembers = function(context, union) {
  const memberTypes = union.getTypes();
  if (memberTypes.length === 0) {
    context.reportError(`Union type ${union.name} must define one or more member types.`, [union.astNode, ...union.extensionASTNodes]);
  }
  const includedTypeNames = Object.create(null);
  for (const memberType of memberTypes) {
    if (includedTypeNames[memberType.name]) {
      context.reportError(`Union type ${union.name} can only include type ${memberType.name} once.`, getUnionMemberTypeNodes(union, memberType.name));
      continue;
    }
    includedTypeNames[memberType.name] = true;
    if (!isObjectType(memberType)) {
      context.reportError(`Union type ${union.name} can only include Object types, ` + `it cannot include ${inspect(memberType)}.`, getUnionMemberTypeNodes(union, String(memberType)));
    }
  }
};
var validateEnumValues = function(context, enumType) {
  const enumValues = enumType.getValues();
  if (enumValues.length === 0) {
    context.reportError(`Enum type ${enumType.name} must define one or more values.`, [enumType.astNode, ...enumType.extensionASTNodes]);
  }
  for (const enumValue of enumValues) {
    validateName(context, enumValue);
  }
};
var validateInputFields = function(context, inputObj) {
  const fields = Object.values(inputObj.getFields());
  if (fields.length === 0) {
    context.reportError(`Input Object type ${inputObj.name} must define one or more fields.`, [inputObj.astNode, ...inputObj.extensionASTNodes]);
  }
  for (const field of fields) {
    validateName(context, field);
    if (!isInputType(field.type)) {
      var _field$astNode2;
      context.reportError(`The type of ${inputObj.name}.${field.name} must be Input Type ` + `but got: ${inspect(field.type)}.`, (_field$astNode2 = field.astNode) === null || _field$astNode2 === undefined ? undefined : _field$astNode2.type);
    }
    if (isRequiredInputField(field) && field.deprecationReason != null) {
      var _field$astNode3;
      context.reportError(`Required input field ${inputObj.name}.${field.name} cannot be deprecated.`, [
        getDeprecatedDirectiveNode(field.astNode),
        (_field$astNode3 = field.astNode) === null || _field$astNode3 === undefined ? undefined : _field$astNode3.type
      ]);
    }
  }
};
var createInputObjectCircularRefsValidator = function(context) {
  const visitedTypes = Object.create(null);
  const fieldPath = [];
  const fieldPathIndexByTypeName = Object.create(null);
  return detectCycleRecursive;
  function detectCycleRecursive(inputObj) {
    if (visitedTypes[inputObj.name]) {
      return;
    }
    visitedTypes[inputObj.name] = true;
    fieldPathIndexByTypeName[inputObj.name] = fieldPath.length;
    const fields = Object.values(inputObj.getFields());
    for (const field of fields) {
      if (isNonNullType(field.type) && isInputObjectType(field.type.ofType)) {
        const fieldType = field.type.ofType;
        const cycleIndex = fieldPathIndexByTypeName[fieldType.name];
        fieldPath.push(field);
        if (cycleIndex === undefined) {
          detectCycleRecursive(fieldType);
        } else {
          const cyclePath = fieldPath.slice(cycleIndex);
          const pathStr = cyclePath.map((fieldObj) => fieldObj.name).join(".");
          context.reportError(`Cannot reference Input Object "${fieldType.name}" within itself through a series of non-null fields: "${pathStr}".`, cyclePath.map((fieldObj) => fieldObj.astNode));
        }
        fieldPath.pop();
      }
    }
    fieldPathIndexByTypeName[inputObj.name] = undefined;
  }
};
var getAllImplementsInterfaceNodes = function(type, iface) {
  const { astNode, extensionASTNodes } = type;
  const nodes = astNode != null ? [astNode, ...extensionASTNodes] : extensionASTNodes;
  return nodes.flatMap((typeNode) => {
    var _typeNode$interfaces;
    return (_typeNode$interfaces = typeNode.interfaces) !== null && _typeNode$interfaces !== undefined ? _typeNode$interfaces : [];
  }).filter((ifaceNode) => ifaceNode.name.value === iface.name);
};
var getUnionMemberTypeNodes = function(union, typeName) {
  const { astNode, extensionASTNodes } = union;
  const nodes = astNode != null ? [astNode, ...extensionASTNodes] : extensionASTNodes;
  return nodes.flatMap((unionNode) => {
    var _unionNode$types;
    return (_unionNode$types = unionNode.types) !== null && _unionNode$types !== undefined ? _unionNode$types : [];
  }).filter((typeNode) => typeNode.name.value === typeName);
};
var getDeprecatedDirectiveNode = function(definitionNode) {
  var _definitionNode$direc;
  return definitionNode === null || definitionNode === undefined ? undefined : (_definitionNode$direc = definitionNode.directives) === null || _definitionNode$direc === undefined ? undefined : _definitionNode$direc.find((node) => node.name.value === GraphQLDeprecatedDirective.name);
};

class SchemaValidationContext {
  constructor(schema2) {
    this._errors = [];
    this.schema = schema2;
  }
  reportError(message, nodes) {
    const _nodes = Array.isArray(nodes) ? nodes.filter(Boolean) : nodes;
    this._errors.push(new GraphQLError(message, {
      nodes: _nodes
    }));
  }
  getErrors() {
    return this._errors;
  }
}

// node_modules/graphql/utilities/typeFromAST.mjs
function typeFromAST(schema2, typeNode) {
  switch (typeNode.kind) {
    case Kind.LIST_TYPE: {
      const innerType = typeFromAST(schema2, typeNode.type);
      return innerType && new GraphQLList(innerType);
    }
    case Kind.NON_NULL_TYPE: {
      const innerType = typeFromAST(schema2, typeNode.type);
      return innerType && new GraphQLNonNull(innerType);
    }
    case Kind.NAMED_TYPE:
      return schema2.getType(typeNode.name.value);
  }
}

// node_modules/graphql/utilities/TypeInfo.mjs
var getFieldDef = function(schema2, parentType, fieldNode) {
  const name = fieldNode.name.value;
  if (name === SchemaMetaFieldDef.name && schema2.getQueryType() === parentType) {
    return SchemaMetaFieldDef;
  }
  if (name === TypeMetaFieldDef.name && schema2.getQueryType() === parentType) {
    return TypeMetaFieldDef;
  }
  if (name === TypeNameMetaFieldDef.name && isCompositeType(parentType)) {
    return TypeNameMetaFieldDef;
  }
  if (isObjectType(parentType) || isInterfaceType(parentType)) {
    return parentType.getFields()[name];
  }
};
function visitWithTypeInfo(typeInfo, visitor3) {
  return {
    enter(...args) {
      const node = args[0];
      typeInfo.enter(node);
      const fn = getEnterLeaveForKind(visitor3, node.kind).enter;
      if (fn) {
        const result = fn.apply(visitor3, args);
        if (result !== undefined) {
          typeInfo.leave(node);
          if (isNode(result)) {
            typeInfo.enter(result);
          }
        }
        return result;
      }
    },
    leave(...args) {
      const node = args[0];
      const fn = getEnterLeaveForKind(visitor3, node.kind).leave;
      let result;
      if (fn) {
        result = fn.apply(visitor3, args);
      }
      typeInfo.leave(node);
      return result;
    }
  };
}

class TypeInfo {
  constructor(schema2, initialType, getFieldDefFn) {
    this._schema = schema2;
    this._typeStack = [];
    this._parentTypeStack = [];
    this._inputTypeStack = [];
    this._fieldDefStack = [];
    this._defaultValueStack = [];
    this._directive = null;
    this._argument = null;
    this._enumValue = null;
    this._getFieldDef = getFieldDefFn !== null && getFieldDefFn !== undefined ? getFieldDefFn : getFieldDef;
    if (initialType) {
      if (isInputType(initialType)) {
        this._inputTypeStack.push(initialType);
      }
      if (isCompositeType(initialType)) {
        this._parentTypeStack.push(initialType);
      }
      if (isOutputType(initialType)) {
        this._typeStack.push(initialType);
      }
    }
  }
  get [Symbol.toStringTag]() {
    return "TypeInfo";
  }
  getType() {
    if (this._typeStack.length > 0) {
      return this._typeStack[this._typeStack.length - 1];
    }
  }
  getParentType() {
    if (this._parentTypeStack.length > 0) {
      return this._parentTypeStack[this._parentTypeStack.length - 1];
    }
  }
  getInputType() {
    if (this._inputTypeStack.length > 0) {
      return this._inputTypeStack[this._inputTypeStack.length - 1];
    }
  }
  getParentInputType() {
    if (this._inputTypeStack.length > 1) {
      return this._inputTypeStack[this._inputTypeStack.length - 2];
    }
  }
  getFieldDef() {
    if (this._fieldDefStack.length > 0) {
      return this._fieldDefStack[this._fieldDefStack.length - 1];
    }
  }
  getDefaultValue() {
    if (this._defaultValueStack.length > 0) {
      return this._defaultValueStack[this._defaultValueStack.length - 1];
    }
  }
  getDirective() {
    return this._directive;
  }
  getArgument() {
    return this._argument;
  }
  getEnumValue() {
    return this._enumValue;
  }
  enter(node) {
    const schema2 = this._schema;
    switch (node.kind) {
      case Kind.SELECTION_SET: {
        const namedType = getNamedType(this.getType());
        this._parentTypeStack.push(isCompositeType(namedType) ? namedType : undefined);
        break;
      }
      case Kind.FIELD: {
        const parentType = this.getParentType();
        let fieldDef;
        let fieldType;
        if (parentType) {
          fieldDef = this._getFieldDef(schema2, parentType, node);
          if (fieldDef) {
            fieldType = fieldDef.type;
          }
        }
        this._fieldDefStack.push(fieldDef);
        this._typeStack.push(isOutputType(fieldType) ? fieldType : undefined);
        break;
      }
      case Kind.DIRECTIVE:
        this._directive = schema2.getDirective(node.name.value);
        break;
      case Kind.OPERATION_DEFINITION: {
        const rootType = schema2.getRootType(node.operation);
        this._typeStack.push(isObjectType(rootType) ? rootType : undefined);
        break;
      }
      case Kind.INLINE_FRAGMENT:
      case Kind.FRAGMENT_DEFINITION: {
        const typeConditionAST = node.typeCondition;
        const outputType = typeConditionAST ? typeFromAST(schema2, typeConditionAST) : getNamedType(this.getType());
        this._typeStack.push(isOutputType(outputType) ? outputType : undefined);
        break;
      }
      case Kind.VARIABLE_DEFINITION: {
        const inputType = typeFromAST(schema2, node.type);
        this._inputTypeStack.push(isInputType(inputType) ? inputType : undefined);
        break;
      }
      case Kind.ARGUMENT: {
        var _this$getDirective;
        let argDef;
        let argType;
        const fieldOrDirective = (_this$getDirective = this.getDirective()) !== null && _this$getDirective !== undefined ? _this$getDirective : this.getFieldDef();
        if (fieldOrDirective) {
          argDef = fieldOrDirective.args.find((arg) => arg.name === node.name.value);
          if (argDef) {
            argType = argDef.type;
          }
        }
        this._argument = argDef;
        this._defaultValueStack.push(argDef ? argDef.defaultValue : undefined);
        this._inputTypeStack.push(isInputType(argType) ? argType : undefined);
        break;
      }
      case Kind.LIST: {
        const listType = getNullableType(this.getInputType());
        const itemType = isListType(listType) ? listType.ofType : listType;
        this._defaultValueStack.push(undefined);
        this._inputTypeStack.push(isInputType(itemType) ? itemType : undefined);
        break;
      }
      case Kind.OBJECT_FIELD: {
        const objectType = getNamedType(this.getInputType());
        let inputFieldType;
        let inputField;
        if (isInputObjectType(objectType)) {
          inputField = objectType.getFields()[node.name.value];
          if (inputField) {
            inputFieldType = inputField.type;
          }
        }
        this._defaultValueStack.push(inputField ? inputField.defaultValue : undefined);
        this._inputTypeStack.push(isInputType(inputFieldType) ? inputFieldType : undefined);
        break;
      }
      case Kind.ENUM: {
        const enumType = getNamedType(this.getInputType());
        let enumValue;
        if (isEnumType(enumType)) {
          enumValue = enumType.getValue(node.value);
        }
        this._enumValue = enumValue;
        break;
      }
      default:
    }
  }
  leave(node) {
    switch (node.kind) {
      case Kind.SELECTION_SET:
        this._parentTypeStack.pop();
        break;
      case Kind.FIELD:
        this._fieldDefStack.pop();
        this._typeStack.pop();
        break;
      case Kind.DIRECTIVE:
        this._directive = null;
        break;
      case Kind.OPERATION_DEFINITION:
      case Kind.INLINE_FRAGMENT:
      case Kind.FRAGMENT_DEFINITION:
        this._typeStack.pop();
        break;
      case Kind.VARIABLE_DEFINITION:
        this._inputTypeStack.pop();
        break;
      case Kind.ARGUMENT:
        this._argument = null;
        this._defaultValueStack.pop();
        this._inputTypeStack.pop();
        break;
      case Kind.LIST:
      case Kind.OBJECT_FIELD:
        this._defaultValueStack.pop();
        this._inputTypeStack.pop();
        break;
      case Kind.ENUM:
        this._enumValue = null;
        break;
      default:
    }
  }
}

// node_modules/graphql/language/predicates.mjs
function isExecutableDefinitionNode(node) {
  return node.kind === Kind.OPERATION_DEFINITION || node.kind === Kind.FRAGMENT_DEFINITION;
}
function isTypeSystemDefinitionNode(node) {
  return node.kind === Kind.SCHEMA_DEFINITION || isTypeDefinitionNode(node) || node.kind === Kind.DIRECTIVE_DEFINITION;
}
function isTypeDefinitionNode(node) {
  return node.kind === Kind.SCALAR_TYPE_DEFINITION || node.kind === Kind.OBJECT_TYPE_DEFINITION || node.kind === Kind.INTERFACE_TYPE_DEFINITION || node.kind === Kind.UNION_TYPE_DEFINITION || node.kind === Kind.ENUM_TYPE_DEFINITION || node.kind === Kind.INPUT_OBJECT_TYPE_DEFINITION;
}
function isTypeSystemExtensionNode(node) {
  return node.kind === Kind.SCHEMA_EXTENSION || isTypeExtensionNode(node);
}
function isTypeExtensionNode(node) {
  return node.kind === Kind.SCALAR_TYPE_EXTENSION || node.kind === Kind.OBJECT_TYPE_EXTENSION || node.kind === Kind.INTERFACE_TYPE_EXTENSION || node.kind === Kind.UNION_TYPE_EXTENSION || node.kind === Kind.ENUM_TYPE_EXTENSION || node.kind === Kind.INPUT_OBJECT_TYPE_EXTENSION;
}

// node_modules/graphql/validation/rules/ExecutableDefinitionsRule.mjs
function ExecutableDefinitionsRule(context) {
  return {
    Document(node) {
      for (const definition10 of node.definitions) {
        if (!isExecutableDefinitionNode(definition10)) {
          const defName = definition10.kind === Kind.SCHEMA_DEFINITION || definition10.kind === Kind.SCHEMA_EXTENSION ? "schema" : '"' + definition10.name.value + '"';
          context.reportError(new GraphQLError(`The ${defName} definition is not executable.`, {
            nodes: definition10
          }));
        }
      }
      return false;
    }
  };
}

// node_modules/graphql/validation/rules/FieldsOnCorrectTypeRule.mjs
function FieldsOnCorrectTypeRule(context) {
  return {
    Field(node) {
      const type = context.getParentType();
      if (type) {
        const fieldDef = context.getFieldDef();
        if (!fieldDef) {
          const schema2 = context.getSchema();
          const fieldName = node.name.value;
          let suggestion = didYouMean("to use an inline fragment on", getSuggestedTypeNames(schema2, type, fieldName));
          if (suggestion === "") {
            suggestion = didYouMean(getSuggestedFieldNames(type, fieldName));
          }
          context.reportError(new GraphQLError(`Cannot query field "${fieldName}" on type "${type.name}".` + suggestion, {
            nodes: node
          }));
        }
      }
    }
  };
}
var getSuggestedTypeNames = function(schema2, type, fieldName) {
  if (!isAbstractType(type)) {
    return [];
  }
  const suggestedTypes = new Set;
  const usageCount = Object.create(null);
  for (const possibleType of schema2.getPossibleTypes(type)) {
    if (!possibleType.getFields()[fieldName]) {
      continue;
    }
    suggestedTypes.add(possibleType);
    usageCount[possibleType.name] = 1;
    for (const possibleInterface of possibleType.getInterfaces()) {
      var _usageCount$possibleI;
      if (!possibleInterface.getFields()[fieldName]) {
        continue;
      }
      suggestedTypes.add(possibleInterface);
      usageCount[possibleInterface.name] = ((_usageCount$possibleI = usageCount[possibleInterface.name]) !== null && _usageCount$possibleI !== undefined ? _usageCount$possibleI : 0) + 1;
    }
  }
  return [...suggestedTypes].sort((typeA, typeB) => {
    const usageCountDiff = usageCount[typeB.name] - usageCount[typeA.name];
    if (usageCountDiff !== 0) {
      return usageCountDiff;
    }
    if (isInterfaceType(typeA) && schema2.isSubType(typeA, typeB)) {
      return -1;
    }
    if (isInterfaceType(typeB) && schema2.isSubType(typeB, typeA)) {
      return 1;
    }
    return naturalCompare(typeA.name, typeB.name);
  }).map((x) => x.name);
};
var getSuggestedFieldNames = function(type, fieldName) {
  if (isObjectType(type) || isInterfaceType(type)) {
    const possibleFieldNames = Object.keys(type.getFields());
    return suggestionList(fieldName, possibleFieldNames);
  }
  return [];
};

// node_modules/graphql/validation/rules/FragmentsOnCompositeTypesRule.mjs
function FragmentsOnCompositeTypesRule(context) {
  return {
    InlineFragment(node) {
      const typeCondition = node.typeCondition;
      if (typeCondition) {
        const type = typeFromAST(context.getSchema(), typeCondition);
        if (type && !isCompositeType(type)) {
          const typeStr = print(typeCondition);
          context.reportError(new GraphQLError(`Fragment cannot condition on non composite type "${typeStr}".`, {
            nodes: typeCondition
          }));
        }
      }
    },
    FragmentDefinition(node) {
      const type = typeFromAST(context.getSchema(), node.typeCondition);
      if (type && !isCompositeType(type)) {
        const typeStr = print(node.typeCondition);
        context.reportError(new GraphQLError(`Fragment "${node.name.value}" cannot condition on non composite type "${typeStr}".`, {
          nodes: node.typeCondition
        }));
      }
    }
  };
}

// node_modules/graphql/validation/rules/KnownArgumentNamesRule.mjs
function KnownArgumentNamesRule(context) {
  return {
    ...KnownArgumentNamesOnDirectivesRule(context),
    Argument(argNode) {
      const argDef = context.getArgument();
      const fieldDef = context.getFieldDef();
      const parentType = context.getParentType();
      if (!argDef && fieldDef && parentType) {
        const argName = argNode.name.value;
        const knownArgsNames = fieldDef.args.map((arg) => arg.name);
        const suggestions = suggestionList(argName, knownArgsNames);
        context.reportError(new GraphQLError(`Unknown argument "${argName}" on field "${parentType.name}.${fieldDef.name}".` + didYouMean(suggestions), {
          nodes: argNode
        }));
      }
    }
  };
}
function KnownArgumentNamesOnDirectivesRule(context) {
  const directiveArgs = Object.create(null);
  const schema2 = context.getSchema();
  const definedDirectives = schema2 ? schema2.getDirectives() : specifiedDirectives;
  for (const directive of definedDirectives) {
    directiveArgs[directive.name] = directive.args.map((arg) => arg.name);
  }
  const astDefinitions = context.getDocument().definitions;
  for (const def of astDefinitions) {
    if (def.kind === Kind.DIRECTIVE_DEFINITION) {
      var _def$arguments;
      const argsNodes = (_def$arguments = def.arguments) !== null && _def$arguments !== undefined ? _def$arguments : [];
      directiveArgs[def.name.value] = argsNodes.map((arg) => arg.name.value);
    }
  }
  return {
    Directive(directiveNode) {
      const directiveName = directiveNode.name.value;
      const knownArgs = directiveArgs[directiveName];
      if (directiveNode.arguments && knownArgs) {
        for (const argNode of directiveNode.arguments) {
          const argName = argNode.name.value;
          if (!knownArgs.includes(argName)) {
            const suggestions = suggestionList(argName, knownArgs);
            context.reportError(new GraphQLError(`Unknown argument "${argName}" on directive "@${directiveName}".` + didYouMean(suggestions), {
              nodes: argNode
            }));
          }
        }
      }
      return false;
    }
  };
}

// node_modules/graphql/validation/rules/KnownDirectivesRule.mjs
function KnownDirectivesRule(context) {
  const locationsMap = Object.create(null);
  const schema2 = context.getSchema();
  const definedDirectives = schema2 ? schema2.getDirectives() : specifiedDirectives;
  for (const directive of definedDirectives) {
    locationsMap[directive.name] = directive.locations;
  }
  const astDefinitions = context.getDocument().definitions;
  for (const def of astDefinitions) {
    if (def.kind === Kind.DIRECTIVE_DEFINITION) {
      locationsMap[def.name.value] = def.locations.map((name) => name.value);
    }
  }
  return {
    Directive(node, _key, _parent, _path, ancestors) {
      const name = node.name.value;
      const locations = locationsMap[name];
      if (!locations) {
        context.reportError(new GraphQLError(`Unknown directive "@${name}".`, {
          nodes: node
        }));
        return;
      }
      const candidateLocation = getDirectiveLocationForASTPath(ancestors);
      if (candidateLocation && !locations.includes(candidateLocation)) {
        context.reportError(new GraphQLError(`Directive "@${name}" may not be used on ${candidateLocation}.`, {
          nodes: node
        }));
      }
    }
  };
}
var getDirectiveLocationForASTPath = function(ancestors) {
  const appliedTo = ancestors[ancestors.length - 1];
  ("kind" in appliedTo) || invariant(false);
  switch (appliedTo.kind) {
    case Kind.OPERATION_DEFINITION:
      return getDirectiveLocationForOperation(appliedTo.operation);
    case Kind.FIELD:
      return DirectiveLocation.FIELD;
    case Kind.FRAGMENT_SPREAD:
      return DirectiveLocation.FRAGMENT_SPREAD;
    case Kind.INLINE_FRAGMENT:
      return DirectiveLocation.INLINE_FRAGMENT;
    case Kind.FRAGMENT_DEFINITION:
      return DirectiveLocation.FRAGMENT_DEFINITION;
    case Kind.VARIABLE_DEFINITION:
      return DirectiveLocation.VARIABLE_DEFINITION;
    case Kind.SCHEMA_DEFINITION:
    case Kind.SCHEMA_EXTENSION:
      return DirectiveLocation.SCHEMA;
    case Kind.SCALAR_TYPE_DEFINITION:
    case Kind.SCALAR_TYPE_EXTENSION:
      return DirectiveLocation.SCALAR;
    case Kind.OBJECT_TYPE_DEFINITION:
    case Kind.OBJECT_TYPE_EXTENSION:
      return DirectiveLocation.OBJECT;
    case Kind.FIELD_DEFINITION:
      return DirectiveLocation.FIELD_DEFINITION;
    case Kind.INTERFACE_TYPE_DEFINITION:
    case Kind.INTERFACE_TYPE_EXTENSION:
      return DirectiveLocation.INTERFACE;
    case Kind.UNION_TYPE_DEFINITION:
    case Kind.UNION_TYPE_EXTENSION:
      return DirectiveLocation.UNION;
    case Kind.ENUM_TYPE_DEFINITION:
    case Kind.ENUM_TYPE_EXTENSION:
      return DirectiveLocation.ENUM;
    case Kind.ENUM_VALUE_DEFINITION:
      return DirectiveLocation.ENUM_VALUE;
    case Kind.INPUT_OBJECT_TYPE_DEFINITION:
    case Kind.INPUT_OBJECT_TYPE_EXTENSION:
      return DirectiveLocation.INPUT_OBJECT;
    case Kind.INPUT_VALUE_DEFINITION: {
      const parentNode = ancestors[ancestors.length - 3];
      ("kind" in parentNode) || invariant(false);
      return parentNode.kind === Kind.INPUT_OBJECT_TYPE_DEFINITION ? DirectiveLocation.INPUT_FIELD_DEFINITION : DirectiveLocation.ARGUMENT_DEFINITION;
    }
    default:
      invariant(false, "Unexpected kind: " + inspect(appliedTo.kind));
  }
};
var getDirectiveLocationForOperation = function(operation) {
  switch (operation) {
    case OperationTypeNode.QUERY:
      return DirectiveLocation.QUERY;
    case OperationTypeNode.MUTATION:
      return DirectiveLocation.MUTATION;
    case OperationTypeNode.SUBSCRIPTION:
      return DirectiveLocation.SUBSCRIPTION;
  }
};

// node_modules/graphql/validation/rules/KnownFragmentNamesRule.mjs
function KnownFragmentNamesRule(context) {
  return {
    FragmentSpread(node) {
      const fragmentName = node.name.value;
      const fragment = context.getFragment(fragmentName);
      if (!fragment) {
        context.reportError(new GraphQLError(`Unknown fragment "${fragmentName}".`, {
          nodes: node.name
        }));
      }
    }
  };
}

// node_modules/graphql/validation/rules/KnownTypeNamesRule.mjs
function KnownTypeNamesRule(context) {
  const schema2 = context.getSchema();
  const existingTypesMap = schema2 ? schema2.getTypeMap() : Object.create(null);
  const definedTypes = Object.create(null);
  for (const def of context.getDocument().definitions) {
    if (isTypeDefinitionNode(def)) {
      definedTypes[def.name.value] = true;
    }
  }
  const typeNames = [
    ...Object.keys(existingTypesMap),
    ...Object.keys(definedTypes)
  ];
  return {
    NamedType(node, _1, parent, _2, ancestors) {
      const typeName = node.name.value;
      if (!existingTypesMap[typeName] && !definedTypes[typeName]) {
        var _ancestors$;
        const definitionNode = (_ancestors$ = ancestors[2]) !== null && _ancestors$ !== undefined ? _ancestors$ : parent;
        const isSDL = definitionNode != null && isSDLNode(definitionNode);
        if (isSDL && standardTypeNames.includes(typeName)) {
          return;
        }
        const suggestedTypes = suggestionList(typeName, isSDL ? standardTypeNames.concat(typeNames) : typeNames);
        context.reportError(new GraphQLError(`Unknown type "${typeName}".` + didYouMean(suggestedTypes), {
          nodes: node
        }));
      }
    }
  };
}
var isSDLNode = function(value) {
  return ("kind" in value) && (isTypeSystemDefinitionNode(value) || isTypeSystemExtensionNode(value));
};
var standardTypeNames = [...specifiedScalarTypes, ...introspectionTypes].map((type) => type.name);

// node_modules/graphql/validation/rules/LoneAnonymousOperationRule.mjs
function LoneAnonymousOperationRule(context) {
  let operationCount = 0;
  return {
    Document(node) {
      operationCount = node.definitions.filter((definition12) => definition12.kind === Kind.OPERATION_DEFINITION).length;
    },
    OperationDefinition(node) {
      if (!node.name && operationCount > 1) {
        context.reportError(new GraphQLError("This anonymous operation must be the only defined operation.", {
          nodes: node
        }));
      }
    }
  };
}

// node_modules/graphql/validation/rules/LoneSchemaDefinitionRule.mjs
function LoneSchemaDefinitionRule(context) {
  var _ref, _ref2, _oldSchema$astNode;
  const oldSchema = context.getSchema();
  const alreadyDefined = (_ref = (_ref2 = (_oldSchema$astNode = oldSchema === null || oldSchema === undefined ? undefined : oldSchema.astNode) !== null && _oldSchema$astNode !== undefined ? _oldSchema$astNode : oldSchema === null || oldSchema === undefined ? undefined : oldSchema.getQueryType()) !== null && _ref2 !== undefined ? _ref2 : oldSchema === null || oldSchema === undefined ? undefined : oldSchema.getMutationType()) !== null && _ref !== undefined ? _ref : oldSchema === null || oldSchema === undefined ? undefined : oldSchema.getSubscriptionType();
  let schemaDefinitionsCount = 0;
  return {
    SchemaDefinition(node) {
      if (alreadyDefined) {
        context.reportError(new GraphQLError("Cannot define a new schema within a schema extension.", {
          nodes: node
        }));
        return;
      }
      if (schemaDefinitionsCount > 0) {
        context.reportError(new GraphQLError("Must provide only one schema definition.", {
          nodes: node
        }));
      }
      ++schemaDefinitionsCount;
    }
  };
}

// node_modules/graphql/validation/rules/NoFragmentCyclesRule.mjs
function NoFragmentCyclesRule(context) {
  const visitedFrags = Object.create(null);
  const spreadPath = [];
  const spreadPathIndexByName = Object.create(null);
  return {
    OperationDefinition: () => false,
    FragmentDefinition(node) {
      detectCycleRecursive(node);
      return false;
    }
  };
  function detectCycleRecursive(fragment) {
    if (visitedFrags[fragment.name.value]) {
      return;
    }
    const fragmentName = fragment.name.value;
    visitedFrags[fragmentName] = true;
    const spreadNodes = context.getFragmentSpreads(fragment.selectionSet);
    if (spreadNodes.length === 0) {
      return;
    }
    spreadPathIndexByName[fragmentName] = spreadPath.length;
    for (const spreadNode of spreadNodes) {
      const spreadName = spreadNode.name.value;
      const cycleIndex = spreadPathIndexByName[spreadName];
      spreadPath.push(spreadNode);
      if (cycleIndex === undefined) {
        const spreadFragment = context.getFragment(spreadName);
        if (spreadFragment) {
          detectCycleRecursive(spreadFragment);
        }
      } else {
        const cyclePath = spreadPath.slice(cycleIndex);
        const viaPath = cyclePath.slice(0, -1).map((s) => '"' + s.name.value + '"').join(", ");
        context.reportError(new GraphQLError(`Cannot spread fragment "${spreadName}" within itself` + (viaPath !== "" ? ` via ${viaPath}.` : "."), {
          nodes: cyclePath
        }));
      }
      spreadPath.pop();
    }
    spreadPathIndexByName[fragmentName] = undefined;
  }
}

// node_modules/graphql/validation/rules/NoUndefinedVariablesRule.mjs
function NoUndefinedVariablesRule(context) {
  let variableNameDefined = Object.create(null);
  return {
    OperationDefinition: {
      enter() {
        variableNameDefined = Object.create(null);
      },
      leave(operation) {
        const usages = context.getRecursiveVariableUsages(operation);
        for (const { node } of usages) {
          const varName = node.name.value;
          if (variableNameDefined[varName] !== true) {
            context.reportError(new GraphQLError(operation.name ? `Variable "\$${varName}" is not defined by operation "${operation.name.value}".` : `Variable "\$${varName}" is not defined.`, {
              nodes: [node, operation]
            }));
          }
        }
      }
    },
    VariableDefinition(node) {
      variableNameDefined[node.variable.name.value] = true;
    }
  };
}

// node_modules/graphql/validation/rules/NoUnusedFragmentsRule.mjs
function NoUnusedFragmentsRule(context) {
  const operationDefs = [];
  const fragmentDefs = [];
  return {
    OperationDefinition(node) {
      operationDefs.push(node);
      return false;
    },
    FragmentDefinition(node) {
      fragmentDefs.push(node);
      return false;
    },
    Document: {
      leave() {
        const fragmentNameUsed = Object.create(null);
        for (const operation of operationDefs) {
          for (const fragment of context.getRecursivelyReferencedFragments(operation)) {
            fragmentNameUsed[fragment.name.value] = true;
          }
        }
        for (const fragmentDef of fragmentDefs) {
          const fragName = fragmentDef.name.value;
          if (fragmentNameUsed[fragName] !== true) {
            context.reportError(new GraphQLError(`Fragment "${fragName}" is never used.`, {
              nodes: fragmentDef
            }));
          }
        }
      }
    }
  };
}

// node_modules/graphql/validation/rules/NoUnusedVariablesRule.mjs
function NoUnusedVariablesRule(context) {
  let variableDefs = [];
  return {
    OperationDefinition: {
      enter() {
        variableDefs = [];
      },
      leave(operation) {
        const variableNameUsed = Object.create(null);
        const usages = context.getRecursiveVariableUsages(operation);
        for (const { node } of usages) {
          variableNameUsed[node.name.value] = true;
        }
        for (const variableDef of variableDefs) {
          const variableName = variableDef.variable.name.value;
          if (variableNameUsed[variableName] !== true) {
            context.reportError(new GraphQLError(operation.name ? `Variable "\$${variableName}" is never used in operation "${operation.name.value}".` : `Variable "\$${variableName}" is never used.`, {
              nodes: variableDef
            }));
          }
        }
      }
    },
    VariableDefinition(def) {
      variableDefs.push(def);
    }
  };
}

// node_modules/graphql/utilities/sortValueNode.mjs
function sortValueNode(valueNode) {
  switch (valueNode.kind) {
    case Kind.OBJECT:
      return { ...valueNode, fields: sortFields(valueNode.fields) };
    case Kind.LIST:
      return { ...valueNode, values: valueNode.values.map(sortValueNode) };
    case Kind.INT:
    case Kind.FLOAT:
    case Kind.STRING:
    case Kind.BOOLEAN:
    case Kind.NULL:
    case Kind.ENUM:
    case Kind.VARIABLE:
      return valueNode;
  }
}
var sortFields = function(fields) {
  return fields.map((fieldNode) => ({
    ...fieldNode,
    value: sortValueNode(fieldNode.value)
  })).sort((fieldA, fieldB) => naturalCompare(fieldA.name.value, fieldB.name.value));
};

// node_modules/graphql/validation/rules/OverlappingFieldsCanBeMergedRule.mjs
var reasonMessage = function(reason) {
  if (Array.isArray(reason)) {
    return reason.map(([responseName, subReason]) => `subfields "${responseName}" conflict because ` + reasonMessage(subReason)).join(" and ");
  }
  return reason;
};
function OverlappingFieldsCanBeMergedRule(context) {
  const comparedFragmentPairs = new PairSet;
  const cachedFieldsAndFragmentNames = new Map;
  return {
    SelectionSet(selectionSet) {
      const conflicts = findConflictsWithinSelectionSet(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, context.getParentType(), selectionSet);
      for (const [[responseName, reason], fields1, fields2] of conflicts) {
        const reasonMsg = reasonMessage(reason);
        context.reportError(new GraphQLError(`Fields "${responseName}" conflict because ${reasonMsg}. Use different aliases on the fields to fetch both if this was intentional.`, {
          nodes: fields1.concat(fields2)
        }));
      }
    }
  };
}
var findConflictsWithinSelectionSet = function(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, parentType, selectionSet) {
  const conflicts = [];
  const [fieldMap, fragmentNames] = getFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, parentType, selectionSet);
  collectConflictsWithin(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, fieldMap);
  if (fragmentNames.length !== 0) {
    for (let i = 0;i < fragmentNames.length; i++) {
      collectConflictsBetweenFieldsAndFragment(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, false, fieldMap, fragmentNames[i]);
      for (let j = i + 1;j < fragmentNames.length; j++) {
        collectConflictsBetweenFragments(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, false, fragmentNames[i], fragmentNames[j]);
      }
    }
  }
  return conflicts;
};
var collectConflictsBetweenFieldsAndFragment = function(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fieldMap, fragmentName) {
  const fragment = context.getFragment(fragmentName);
  if (!fragment) {
    return;
  }
  const [fieldMap2, referencedFragmentNames] = getReferencedFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, fragment);
  if (fieldMap === fieldMap2) {
    return;
  }
  collectConflictsBetween(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fieldMap, fieldMap2);
  for (const referencedFragmentName of referencedFragmentNames) {
    if (comparedFragmentPairs.has(referencedFragmentName, fragmentName, areMutuallyExclusive)) {
      continue;
    }
    comparedFragmentPairs.add(referencedFragmentName, fragmentName, areMutuallyExclusive);
    collectConflictsBetweenFieldsAndFragment(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fieldMap, referencedFragmentName);
  }
};
var collectConflictsBetweenFragments = function(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fragmentName1, fragmentName2) {
  if (fragmentName1 === fragmentName2) {
    return;
  }
  if (comparedFragmentPairs.has(fragmentName1, fragmentName2, areMutuallyExclusive)) {
    return;
  }
  comparedFragmentPairs.add(fragmentName1, fragmentName2, areMutuallyExclusive);
  const fragment1 = context.getFragment(fragmentName1);
  const fragment2 = context.getFragment(fragmentName2);
  if (!fragment1 || !fragment2) {
    return;
  }
  const [fieldMap1, referencedFragmentNames1] = getReferencedFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, fragment1);
  const [fieldMap2, referencedFragmentNames2] = getReferencedFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, fragment2);
  collectConflictsBetween(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fieldMap1, fieldMap2);
  for (const referencedFragmentName2 of referencedFragmentNames2) {
    collectConflictsBetweenFragments(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fragmentName1, referencedFragmentName2);
  }
  for (const referencedFragmentName1 of referencedFragmentNames1) {
    collectConflictsBetweenFragments(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, referencedFragmentName1, fragmentName2);
  }
};
var findConflictsBetweenSubSelectionSets = function(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, parentType1, selectionSet1, parentType2, selectionSet2) {
  const conflicts = [];
  const [fieldMap1, fragmentNames1] = getFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, parentType1, selectionSet1);
  const [fieldMap2, fragmentNames2] = getFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, parentType2, selectionSet2);
  collectConflictsBetween(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fieldMap1, fieldMap2);
  for (const fragmentName2 of fragmentNames2) {
    collectConflictsBetweenFieldsAndFragment(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fieldMap1, fragmentName2);
  }
  for (const fragmentName1 of fragmentNames1) {
    collectConflictsBetweenFieldsAndFragment(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fieldMap2, fragmentName1);
  }
  for (const fragmentName1 of fragmentNames1) {
    for (const fragmentName2 of fragmentNames2) {
      collectConflictsBetweenFragments(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fragmentName1, fragmentName2);
    }
  }
  return conflicts;
};
var collectConflictsWithin = function(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, fieldMap) {
  for (const [responseName, fields] of Object.entries(fieldMap)) {
    if (fields.length > 1) {
      for (let i = 0;i < fields.length; i++) {
        for (let j = i + 1;j < fields.length; j++) {
          const conflict = findConflict(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, false, responseName, fields[i], fields[j]);
          if (conflict) {
            conflicts.push(conflict);
          }
        }
      }
    }
  }
};
var collectConflictsBetween = function(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, parentFieldsAreMutuallyExclusive, fieldMap1, fieldMap2) {
  for (const [responseName, fields1] of Object.entries(fieldMap1)) {
    const fields2 = fieldMap2[responseName];
    if (fields2) {
      for (const field1 of fields1) {
        for (const field2 of fields2) {
          const conflict = findConflict(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, parentFieldsAreMutuallyExclusive, responseName, field1, field2);
          if (conflict) {
            conflicts.push(conflict);
          }
        }
      }
    }
  }
};
var findConflict = function(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, parentFieldsAreMutuallyExclusive, responseName, field1, field2) {
  const [parentType1, node1, def1] = field1;
  const [parentType2, node2, def2] = field2;
  const areMutuallyExclusive = parentFieldsAreMutuallyExclusive || parentType1 !== parentType2 && isObjectType(parentType1) && isObjectType(parentType2);
  if (!areMutuallyExclusive) {
    const name1 = node1.name.value;
    const name2 = node2.name.value;
    if (name1 !== name2) {
      return [
        [responseName, `"${name1}" and "${name2}" are different fields`],
        [node1],
        [node2]
      ];
    }
    if (!sameArguments(node1, node2)) {
      return [
        [responseName, "they have differing arguments"],
        [node1],
        [node2]
      ];
    }
  }
  const type1 = def1 === null || def1 === undefined ? undefined : def1.type;
  const type2 = def2 === null || def2 === undefined ? undefined : def2.type;
  if (type1 && type2 && doTypesConflict(type1, type2)) {
    return [
      [
        responseName,
        `they return conflicting types "${inspect(type1)}" and "${inspect(type2)}"`
      ],
      [node1],
      [node2]
    ];
  }
  const selectionSet1 = node1.selectionSet;
  const selectionSet2 = node2.selectionSet;
  if (selectionSet1 && selectionSet2) {
    const conflicts = findConflictsBetweenSubSelectionSets(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, getNamedType(type1), selectionSet1, getNamedType(type2), selectionSet2);
    return subfieldConflicts(conflicts, responseName, node1, node2);
  }
};
var sameArguments = function(node1, node2) {
  const args1 = node1.arguments;
  const args2 = node2.arguments;
  if (args1 === undefined || args1.length === 0) {
    return args2 === undefined || args2.length === 0;
  }
  if (args2 === undefined || args2.length === 0) {
    return false;
  }
  if (args1.length !== args2.length) {
    return false;
  }
  const values2 = new Map(args2.map(({ name, value }) => [name.value, value]));
  return args1.every((arg1) => {
    const value1 = arg1.value;
    const value2 = values2.get(arg1.name.value);
    if (value2 === undefined) {
      return false;
    }
    return stringifyValue(value1) === stringifyValue(value2);
  });
};
var stringifyValue = function(value) {
  return print(sortValueNode(value));
};
var doTypesConflict = function(type1, type2) {
  if (isListType(type1)) {
    return isListType(type2) ? doTypesConflict(type1.ofType, type2.ofType) : true;
  }
  if (isListType(type2)) {
    return true;
  }
  if (isNonNullType(type1)) {
    return isNonNullType(type2) ? doTypesConflict(type1.ofType, type2.ofType) : true;
  }
  if (isNonNullType(type2)) {
    return true;
  }
  if (isLeafType(type1) || isLeafType(type2)) {
    return type1 !== type2;
  }
  return false;
};
var getFieldsAndFragmentNames = function(context, cachedFieldsAndFragmentNames, parentType, selectionSet) {
  const cached = cachedFieldsAndFragmentNames.get(selectionSet);
  if (cached) {
    return cached;
  }
  const nodeAndDefs = Object.create(null);
  const fragmentNames = Object.create(null);
  _collectFieldsAndFragmentNames(context, parentType, selectionSet, nodeAndDefs, fragmentNames);
  const result = [nodeAndDefs, Object.keys(fragmentNames)];
  cachedFieldsAndFragmentNames.set(selectionSet, result);
  return result;
};
var getReferencedFieldsAndFragmentNames = function(context, cachedFieldsAndFragmentNames, fragment) {
  const cached = cachedFieldsAndFragmentNames.get(fragment.selectionSet);
  if (cached) {
    return cached;
  }
  const fragmentType = typeFromAST(context.getSchema(), fragment.typeCondition);
  return getFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, fragmentType, fragment.selectionSet);
};
var _collectFieldsAndFragmentNames = function(context, parentType, selectionSet, nodeAndDefs, fragmentNames) {
  for (const selection of selectionSet.selections) {
    switch (selection.kind) {
      case Kind.FIELD: {
        const fieldName = selection.name.value;
        let fieldDef;
        if (isObjectType(parentType) || isInterfaceType(parentType)) {
          fieldDef = parentType.getFields()[fieldName];
        }
        const responseName = selection.alias ? selection.alias.value : fieldName;
        if (!nodeAndDefs[responseName]) {
          nodeAndDefs[responseName] = [];
        }
        nodeAndDefs[responseName].push([parentType, selection, fieldDef]);
        break;
      }
      case Kind.FRAGMENT_SPREAD:
        fragmentNames[selection.name.value] = true;
        break;
      case Kind.INLINE_FRAGMENT: {
        const typeCondition = selection.typeCondition;
        const inlineFragmentType = typeCondition ? typeFromAST(context.getSchema(), typeCondition) : parentType;
        _collectFieldsAndFragmentNames(context, inlineFragmentType, selection.selectionSet, nodeAndDefs, fragmentNames);
        break;
      }
    }
  }
};
var subfieldConflicts = function(conflicts, responseName, node1, node2) {
  if (conflicts.length > 0) {
    return [
      [responseName, conflicts.map(([reason]) => reason)],
      [node1, ...conflicts.map(([, fields1]) => fields1).flat()],
      [node2, ...conflicts.map(([, , fields2]) => fields2).flat()]
    ];
  }
};

class PairSet {
  constructor() {
    this._data = new Map;
  }
  has(a, b, areMutuallyExclusive) {
    var _this$_data$get;
    const [key1, key2] = a < b ? [a, b] : [b, a];
    const result = (_this$_data$get = this._data.get(key1)) === null || _this$_data$get === undefined ? undefined : _this$_data$get.get(key2);
    if (result === undefined) {
      return false;
    }
    return areMutuallyExclusive ? true : areMutuallyExclusive === result;
  }
  add(a, b, areMutuallyExclusive) {
    const [key1, key2] = a < b ? [a, b] : [b, a];
    const map = this._data.get(key1);
    if (map === undefined) {
      this._data.set(key1, new Map([[key2, areMutuallyExclusive]]));
    } else {
      map.set(key2, areMutuallyExclusive);
    }
  }
}

// node_modules/graphql/validation/rules/PossibleFragmentSpreadsRule.mjs
function PossibleFragmentSpreadsRule(context) {
  return {
    InlineFragment(node) {
      const fragType = context.getType();
      const parentType = context.getParentType();
      if (isCompositeType(fragType) && isCompositeType(parentType) && !doTypesOverlap(context.getSchema(), fragType, parentType)) {
        const parentTypeStr = inspect(parentType);
        const fragTypeStr = inspect(fragType);
        context.reportError(new GraphQLError(`Fragment cannot be spread here as objects of type "${parentTypeStr}" can never be of type "${fragTypeStr}".`, {
          nodes: node
        }));
      }
    },
    FragmentSpread(node) {
      const fragName = node.name.value;
      const fragType = getFragmentType(context, fragName);
      const parentType = context.getParentType();
      if (fragType && parentType && !doTypesOverlap(context.getSchema(), fragType, parentType)) {
        const parentTypeStr = inspect(parentType);
        const fragTypeStr = inspect(fragType);
        context.reportError(new GraphQLError(`Fragment "${fragName}" cannot be spread here as objects of type "${parentTypeStr}" can never be of type "${fragTypeStr}".`, {
          nodes: node
        }));
      }
    }
  };
}
var getFragmentType = function(context, name) {
  const frag = context.getFragment(name);
  if (frag) {
    const type = typeFromAST(context.getSchema(), frag.typeCondition);
    if (isCompositeType(type)) {
      return type;
    }
  }
};

// node_modules/graphql/validation/rules/PossibleTypeExtensionsRule.mjs
function PossibleTypeExtensionsRule(context) {
  const schema2 = context.getSchema();
  const definedTypes = Object.create(null);
  for (const def of context.getDocument().definitions) {
    if (isTypeDefinitionNode(def)) {
      definedTypes[def.name.value] = def;
    }
  }
  return {
    ScalarTypeExtension: checkExtension,
    ObjectTypeExtension: checkExtension,
    InterfaceTypeExtension: checkExtension,
    UnionTypeExtension: checkExtension,
    EnumTypeExtension: checkExtension,
    InputObjectTypeExtension: checkExtension
  };
  function checkExtension(node) {
    const typeName = node.name.value;
    const defNode = definedTypes[typeName];
    const existingType = schema2 === null || schema2 === undefined ? undefined : schema2.getType(typeName);
    let expectedKind;
    if (defNode) {
      expectedKind = defKindToExtKind[defNode.kind];
    } else if (existingType) {
      expectedKind = typeToExtKind(existingType);
    }
    if (expectedKind) {
      if (expectedKind !== node.kind) {
        const kindStr = extensionKindToTypeName(node.kind);
        context.reportError(new GraphQLError(`Cannot extend non-${kindStr} type "${typeName}".`, {
          nodes: defNode ? [defNode, node] : node
        }));
      }
    } else {
      const allTypeNames = Object.keys({
        ...definedTypes,
        ...schema2 === null || schema2 === undefined ? undefined : schema2.getTypeMap()
      });
      const suggestedTypes = suggestionList(typeName, allTypeNames);
      context.reportError(new GraphQLError(`Cannot extend type "${typeName}" because it is not defined.` + didYouMean(suggestedTypes), {
        nodes: node.name
      }));
    }
  }
}
var typeToExtKind = function(type) {
  if (isScalarType(type)) {
    return Kind.SCALAR_TYPE_EXTENSION;
  }
  if (isObjectType(type)) {
    return Kind.OBJECT_TYPE_EXTENSION;
  }
  if (isInterfaceType(type)) {
    return Kind.INTERFACE_TYPE_EXTENSION;
  }
  if (isUnionType(type)) {
    return Kind.UNION_TYPE_EXTENSION;
  }
  if (isEnumType(type)) {
    return Kind.ENUM_TYPE_EXTENSION;
  }
  if (isInputObjectType(type)) {
    return Kind.INPUT_OBJECT_TYPE_EXTENSION;
  }
  invariant(false, "Unexpected type: " + inspect(type));
};
var extensionKindToTypeName = function(kind) {
  switch (kind) {
    case Kind.SCALAR_TYPE_EXTENSION:
      return "scalar";
    case Kind.OBJECT_TYPE_EXTENSION:
      return "object";
    case Kind.INTERFACE_TYPE_EXTENSION:
      return "interface";
    case Kind.UNION_TYPE_EXTENSION:
      return "union";
    case Kind.ENUM_TYPE_EXTENSION:
      return "enum";
    case Kind.INPUT_OBJECT_TYPE_EXTENSION:
      return "input object";
    default:
      invariant(false, "Unexpected kind: " + inspect(kind));
  }
};
var defKindToExtKind = {
  [Kind.SCALAR_TYPE_DEFINITION]: Kind.SCALAR_TYPE_EXTENSION,
  [Kind.OBJECT_TYPE_DEFINITION]: Kind.OBJECT_TYPE_EXTENSION,
  [Kind.INTERFACE_TYPE_DEFINITION]: Kind.INTERFACE_TYPE_EXTENSION,
  [Kind.UNION_TYPE_DEFINITION]: Kind.UNION_TYPE_EXTENSION,
  [Kind.ENUM_TYPE_DEFINITION]: Kind.ENUM_TYPE_EXTENSION,
  [Kind.INPUT_OBJECT_TYPE_DEFINITION]: Kind.INPUT_OBJECT_TYPE_EXTENSION
};

// node_modules/graphql/validation/rules/ProvidedRequiredArgumentsRule.mjs
function ProvidedRequiredArgumentsRule(context) {
  return {
    ...ProvidedRequiredArgumentsOnDirectivesRule(context),
    Field: {
      leave(fieldNode) {
        var _fieldNode$arguments;
        const fieldDef = context.getFieldDef();
        if (!fieldDef) {
          return false;
        }
        const providedArgs = new Set((_fieldNode$arguments = fieldNode.arguments) === null || _fieldNode$arguments === undefined ? undefined : _fieldNode$arguments.map((arg) => arg.name.value));
        for (const argDef of fieldDef.args) {
          if (!providedArgs.has(argDef.name) && isRequiredArgument(argDef)) {
            const argTypeStr = inspect(argDef.type);
            context.reportError(new GraphQLError(`Field "${fieldDef.name}" argument "${argDef.name}" of type "${argTypeStr}" is required, but it was not provided.`, {
              nodes: fieldNode
            }));
          }
        }
      }
    }
  };
}
function ProvidedRequiredArgumentsOnDirectivesRule(context) {
  var _schema$getDirectives;
  const requiredArgsMap = Object.create(null);
  const schema2 = context.getSchema();
  const definedDirectives = (_schema$getDirectives = schema2 === null || schema2 === undefined ? undefined : schema2.getDirectives()) !== null && _schema$getDirectives !== undefined ? _schema$getDirectives : specifiedDirectives;
  for (const directive of definedDirectives) {
    requiredArgsMap[directive.name] = keyMap(directive.args.filter(isRequiredArgument), (arg) => arg.name);
  }
  const astDefinitions = context.getDocument().definitions;
  for (const def of astDefinitions) {
    if (def.kind === Kind.DIRECTIVE_DEFINITION) {
      var _def$arguments;
      const argNodes = (_def$arguments = def.arguments) !== null && _def$arguments !== undefined ? _def$arguments : [];
      requiredArgsMap[def.name.value] = keyMap(argNodes.filter(isRequiredArgumentNode), (arg) => arg.name.value);
    }
  }
  return {
    Directive: {
      leave(directiveNode) {
        const directiveName = directiveNode.name.value;
        const requiredArgs = requiredArgsMap[directiveName];
        if (requiredArgs) {
          var _directiveNode$argume;
          const argNodes = (_directiveNode$argume = directiveNode.arguments) !== null && _directiveNode$argume !== undefined ? _directiveNode$argume : [];
          const argNodeMap = new Set(argNodes.map((arg) => arg.name.value));
          for (const [argName, argDef] of Object.entries(requiredArgs)) {
            if (!argNodeMap.has(argName)) {
              const argType = isType(argDef.type) ? inspect(argDef.type) : print(argDef.type);
              context.reportError(new GraphQLError(`Directive "@${directiveName}" argument "${argName}" of type "${argType}" is required, but it was not provided.`, {
                nodes: directiveNode
              }));
            }
          }
        }
      }
    }
  };
}
var isRequiredArgumentNode = function(arg) {
  return arg.type.kind === Kind.NON_NULL_TYPE && arg.defaultValue == null;
};

// node_modules/graphql/validation/rules/ScalarLeafsRule.mjs
function ScalarLeafsRule(context) {
  return {
    Field(node) {
      const type = context.getType();
      const selectionSet = node.selectionSet;
      if (type) {
        if (isLeafType(getNamedType(type))) {
          if (selectionSet) {
            const fieldName = node.name.value;
            const typeStr = inspect(type);
            context.reportError(new GraphQLError(`Field "${fieldName}" must not have a selection since type "${typeStr}" has no subfields.`, {
              nodes: selectionSet
            }));
          }
        } else if (!selectionSet) {
          const fieldName = node.name.value;
          const typeStr = inspect(type);
          context.reportError(new GraphQLError(`Field "${fieldName}" of type "${typeStr}" must have a selection of subfields. Did you mean "${fieldName} { ... }"?`, {
            nodes: node
          }));
        }
      }
    }
  };
}

// node_modules/graphql/jsutils/printPathArray.mjs
function printPathArray(path) {
  return path.map((key) => typeof key === "number" ? "[" + key.toString() + "]" : "." + key).join("");
}

// node_modules/graphql/jsutils/Path.mjs
function addPath(prev, key, typename) {
  return {
    prev,
    key,
    typename
  };
}
function pathToArray(path) {
  const flattened = [];
  let curr = path;
  while (curr) {
    flattened.push(curr.key);
    curr = curr.prev;
  }
  return flattened.reverse();
}

// node_modules/graphql/utilities/coerceInputValue.mjs
function coerceInputValue(inputValue, type, onError = defaultOnError) {
  return coerceInputValueImpl(inputValue, type, onError, undefined);
}
var defaultOnError = function(path, invalidValue, error) {
  let errorPrefix = "Invalid value " + inspect(invalidValue);
  if (path.length > 0) {
    errorPrefix += ` at "value${printPathArray(path)}"`;
  }
  error.message = errorPrefix + ": " + error.message;
  throw error;
};
var coerceInputValueImpl = function(inputValue, type, onError, path) {
  if (isNonNullType(type)) {
    if (inputValue != null) {
      return coerceInputValueImpl(inputValue, type.ofType, onError, path);
    }
    onError(pathToArray(path), inputValue, new GraphQLError(`Expected non-nullable type "${inspect(type)}" not to be null.`));
    return;
  }
  if (inputValue == null) {
    return null;
  }
  if (isListType(type)) {
    const itemType = type.ofType;
    if (isIterableObject(inputValue)) {
      return Array.from(inputValue, (itemValue, index) => {
        const itemPath = addPath(path, index, undefined);
        return coerceInputValueImpl(itemValue, itemType, onError, itemPath);
      });
    }
    return [coerceInputValueImpl(inputValue, itemType, onError, path)];
  }
  if (isInputObjectType(type)) {
    if (!isObjectLike(inputValue)) {
      onError(pathToArray(path), inputValue, new GraphQLError(`Expected type "${type.name}" to be an object.`));
      return;
    }
    const coercedValue = {};
    const fieldDefs = type.getFields();
    for (const field of Object.values(fieldDefs)) {
      const fieldValue = inputValue[field.name];
      if (fieldValue === undefined) {
        if (field.defaultValue !== undefined) {
          coercedValue[field.name] = field.defaultValue;
        } else if (isNonNullType(field.type)) {
          const typeStr = inspect(field.type);
          onError(pathToArray(path), inputValue, new GraphQLError(`Field "${field.name}" of required type "${typeStr}" was not provided.`));
        }
        continue;
      }
      coercedValue[field.name] = coerceInputValueImpl(fieldValue, field.type, onError, addPath(path, field.name, type.name));
    }
    for (const fieldName of Object.keys(inputValue)) {
      if (!fieldDefs[fieldName]) {
        const suggestions = suggestionList(fieldName, Object.keys(type.getFields()));
        onError(pathToArray(path), inputValue, new GraphQLError(`Field "${fieldName}" is not defined by type "${type.name}".` + didYouMean(suggestions)));
      }
    }
    return coercedValue;
  }
  if (isLeafType(type)) {
    let parseResult;
    try {
      parseResult = type.parseValue(inputValue);
    } catch (error) {
      if (error instanceof GraphQLError) {
        onError(pathToArray(path), inputValue, error);
      } else {
        onError(pathToArray(path), inputValue, new GraphQLError(`Expected type "${type.name}". ` + error.message, {
          originalError: error
        }));
      }
      return;
    }
    if (parseResult === undefined) {
      onError(pathToArray(path), inputValue, new GraphQLError(`Expected type "${type.name}".`));
    }
    return parseResult;
  }
  invariant(false, "Unexpected input type: " + inspect(type));
};

// node_modules/graphql/utilities/valueFromAST.mjs
function valueFromAST(valueNode, type, variables) {
  if (!valueNode) {
    return;
  }
  if (valueNode.kind === Kind.VARIABLE) {
    const variableName = valueNode.name.value;
    if (variables == null || variables[variableName] === undefined) {
      return;
    }
    const variableValue = variables[variableName];
    if (variableValue === null && isNonNullType(type)) {
      return;
    }
    return variableValue;
  }
  if (isNonNullType(type)) {
    if (valueNode.kind === Kind.NULL) {
      return;
    }
    return valueFromAST(valueNode, type.ofType, variables);
  }
  if (valueNode.kind === Kind.NULL) {
    return null;
  }
  if (isListType(type)) {
    const itemType = type.ofType;
    if (valueNode.kind === Kind.LIST) {
      const coercedValues = [];
      for (const itemNode of valueNode.values) {
        if (isMissingVariable(itemNode, variables)) {
          if (isNonNullType(itemType)) {
            return;
          }
          coercedValues.push(null);
        } else {
          const itemValue = valueFromAST(itemNode, itemType, variables);
          if (itemValue === undefined) {
            return;
          }
          coercedValues.push(itemValue);
        }
      }
      return coercedValues;
    }
    const coercedValue = valueFromAST(valueNode, itemType, variables);
    if (coercedValue === undefined) {
      return;
    }
    return [coercedValue];
  }
  if (isInputObjectType(type)) {
    if (valueNode.kind !== Kind.OBJECT) {
      return;
    }
    const coercedObj = Object.create(null);
    const fieldNodes = keyMap(valueNode.fields, (field) => field.name.value);
    for (const field of Object.values(type.getFields())) {
      const fieldNode = fieldNodes[field.name];
      if (!fieldNode || isMissingVariable(fieldNode.value, variables)) {
        if (field.defaultValue !== undefined) {
          coercedObj[field.name] = field.defaultValue;
        } else if (isNonNullType(field.type)) {
          return;
        }
        continue;
      }
      const fieldValue = valueFromAST(fieldNode.value, field.type, variables);
      if (fieldValue === undefined) {
        return;
      }
      coercedObj[field.name] = fieldValue;
    }
    return coercedObj;
  }
  if (isLeafType(type)) {
    let result;
    try {
      result = type.parseLiteral(valueNode, variables);
    } catch (_error) {
      return;
    }
    if (result === undefined) {
      return;
    }
    return result;
  }
  invariant(false, "Unexpected input type: " + inspect(type));
}
var isMissingVariable = function(valueNode, variables) {
  return valueNode.kind === Kind.VARIABLE && (variables == null || variables[valueNode.name.value] === undefined);
};

// node_modules/graphql/execution/values.mjs
function getArgumentValues(def, node, variableValues) {
  var _node$arguments;
  const coercedValues = {};
  const argumentNodes = (_node$arguments = node.arguments) !== null && _node$arguments !== undefined ? _node$arguments : [];
  const argNodeMap = keyMap(argumentNodes, (arg) => arg.name.value);
  for (const argDef of def.args) {
    const name = argDef.name;
    const argType = argDef.type;
    const argumentNode = argNodeMap[name];
    if (!argumentNode) {
      if (argDef.defaultValue !== undefined) {
        coercedValues[name] = argDef.defaultValue;
      } else if (isNonNullType(argType)) {
        throw new GraphQLError(`Argument "${name}" of required type "${inspect(argType)}" ` + "was not provided.", {
          nodes: node
        });
      }
      continue;
    }
    const valueNode = argumentNode.value;
    let isNull = valueNode.kind === Kind.NULL;
    if (valueNode.kind === Kind.VARIABLE) {
      const variableName = valueNode.name.value;
      if (variableValues == null || !hasOwnProperty(variableValues, variableName)) {
        if (argDef.defaultValue !== undefined) {
          coercedValues[name] = argDef.defaultValue;
        } else if (isNonNullType(argType)) {
          throw new GraphQLError(`Argument "${name}" of required type "${inspect(argType)}" ` + `was provided the variable "\$${variableName}" which was not provided a runtime value.`, {
            nodes: valueNode
          });
        }
        continue;
      }
      isNull = variableValues[variableName] == null;
    }
    if (isNull && isNonNullType(argType)) {
      throw new GraphQLError(`Argument "${name}" of non-null type "${inspect(argType)}" ` + "must not be null.", {
        nodes: valueNode
      });
    }
    const coercedValue = valueFromAST(valueNode, argType, variableValues);
    if (coercedValue === undefined) {
      throw new GraphQLError(`Argument "${name}" has invalid value ${print(valueNode)}.`, {
        nodes: valueNode
      });
    }
    coercedValues[name] = coercedValue;
  }
  return coercedValues;
}
function getDirectiveValues(directiveDef, node, variableValues) {
  var _node$directives;
  const directiveNode = (_node$directives = node.directives) === null || _node$directives === undefined ? undefined : _node$directives.find((directive) => directive.name.value === directiveDef.name);
  if (directiveNode) {
    return getArgumentValues(directiveDef, directiveNode, variableValues);
  }
}
var hasOwnProperty = function(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
};

// node_modules/graphql/execution/collectFields.mjs
function collectFields(schema2, fragments, variableValues, runtimeType, selectionSet) {
  const fields = new Map;
  collectFieldsImpl(schema2, fragments, variableValues, runtimeType, selectionSet, fields, new Set);
  return fields;
}
function collectSubfields(schema2, fragments, variableValues, returnType, fieldNodes) {
  const subFieldNodes = new Map;
  const visitedFragmentNames = new Set;
  for (const node of fieldNodes) {
    if (node.selectionSet) {
      collectFieldsImpl(schema2, fragments, variableValues, returnType, node.selectionSet, subFieldNodes, visitedFragmentNames);
    }
  }
  return subFieldNodes;
}
var collectFieldsImpl = function(schema2, fragments, variableValues, runtimeType, selectionSet, fields, visitedFragmentNames) {
  for (const selection of selectionSet.selections) {
    switch (selection.kind) {
      case Kind.FIELD: {
        if (!shouldIncludeNode(variableValues, selection)) {
          continue;
        }
        const name = getFieldEntryKey(selection);
        const fieldList = fields.get(name);
        if (fieldList !== undefined) {
          fieldList.push(selection);
        } else {
          fields.set(name, [selection]);
        }
        break;
      }
      case Kind.INLINE_FRAGMENT: {
        if (!shouldIncludeNode(variableValues, selection) || !doesFragmentConditionMatch(schema2, selection, runtimeType)) {
          continue;
        }
        collectFieldsImpl(schema2, fragments, variableValues, runtimeType, selection.selectionSet, fields, visitedFragmentNames);
        break;
      }
      case Kind.FRAGMENT_SPREAD: {
        const fragName = selection.name.value;
        if (visitedFragmentNames.has(fragName) || !shouldIncludeNode(variableValues, selection)) {
          continue;
        }
        visitedFragmentNames.add(fragName);
        const fragment = fragments[fragName];
        if (!fragment || !doesFragmentConditionMatch(schema2, fragment, runtimeType)) {
          continue;
        }
        collectFieldsImpl(schema2, fragments, variableValues, runtimeType, fragment.selectionSet, fields, visitedFragmentNames);
        break;
      }
    }
  }
};
var shouldIncludeNode = function(variableValues, node) {
  const skip = getDirectiveValues(GraphQLSkipDirective, node, variableValues);
  if ((skip === null || skip === undefined ? undefined : skip.if) === true) {
    return false;
  }
  const include = getDirectiveValues(GraphQLIncludeDirective, node, variableValues);
  if ((include === null || include === undefined ? undefined : include.if) === false) {
    return false;
  }
  return true;
};
var doesFragmentConditionMatch = function(schema2, fragment, type) {
  const typeConditionNode = fragment.typeCondition;
  if (!typeConditionNode) {
    return true;
  }
  const conditionalType = typeFromAST(schema2, typeConditionNode);
  if (conditionalType === type) {
    return true;
  }
  if (isAbstractType(conditionalType)) {
    return schema2.isSubType(conditionalType, type);
  }
  return false;
};
var getFieldEntryKey = function(node) {
  return node.alias ? node.alias.value : node.name.value;
};

// node_modules/graphql/validation/rules/SingleFieldSubscriptionsRule.mjs
function SingleFieldSubscriptionsRule(context) {
  return {
    OperationDefinition(node) {
      if (node.operation === "subscription") {
        const schema2 = context.getSchema();
        const subscriptionType = schema2.getSubscriptionType();
        if (subscriptionType) {
          const operationName = node.name ? node.name.value : null;
          const variableValues = Object.create(null);
          const document2 = context.getDocument();
          const fragments = Object.create(null);
          for (const definition21 of document2.definitions) {
            if (definition21.kind === Kind.FRAGMENT_DEFINITION) {
              fragments[definition21.name.value] = definition21;
            }
          }
          const fields = collectFields(schema2, fragments, variableValues, subscriptionType, node.selectionSet);
          if (fields.size > 1) {
            const fieldSelectionLists = [...fields.values()];
            const extraFieldSelectionLists = fieldSelectionLists.slice(1);
            const extraFieldSelections = extraFieldSelectionLists.flat();
            context.reportError(new GraphQLError(operationName != null ? `Subscription "${operationName}" must select only one top level field.` : "Anonymous Subscription must select only one top level field.", {
              nodes: extraFieldSelections
            }));
          }
          for (const fieldNodes of fields.values()) {
            const field = fieldNodes[0];
            const fieldName = field.name.value;
            if (fieldName.startsWith("__")) {
              context.reportError(new GraphQLError(operationName != null ? `Subscription "${operationName}" must not select an introspection top level field.` : "Anonymous Subscription must not select an introspection top level field.", {
                nodes: fieldNodes
              }));
            }
          }
        }
      }
    }
  };
}

// node_modules/graphql/jsutils/groupBy.mjs
function groupBy(list, keyFn) {
  const result = new Map;
  for (const item of list) {
    const key = keyFn(item);
    const group = result.get(key);
    if (group === undefined) {
      result.set(key, [item]);
    } else {
      group.push(item);
    }
  }
  return result;
}

// node_modules/graphql/validation/rules/UniqueArgumentDefinitionNamesRule.mjs
function UniqueArgumentDefinitionNamesRule(context) {
  return {
    DirectiveDefinition(directiveNode) {
      var _directiveNode$argume;
      const argumentNodes = (_directiveNode$argume = directiveNode.arguments) !== null && _directiveNode$argume !== undefined ? _directiveNode$argume : [];
      return checkArgUniqueness(`@${directiveNode.name.value}`, argumentNodes);
    },
    InterfaceTypeDefinition: checkArgUniquenessPerField,
    InterfaceTypeExtension: checkArgUniquenessPerField,
    ObjectTypeDefinition: checkArgUniquenessPerField,
    ObjectTypeExtension: checkArgUniquenessPerField
  };
  function checkArgUniquenessPerField(typeNode) {
    var _typeNode$fields;
    const typeName = typeNode.name.value;
    const fieldNodes = (_typeNode$fields = typeNode.fields) !== null && _typeNode$fields !== undefined ? _typeNode$fields : [];
    for (const fieldDef of fieldNodes) {
      var _fieldDef$arguments;
      const fieldName = fieldDef.name.value;
      const argumentNodes = (_fieldDef$arguments = fieldDef.arguments) !== null && _fieldDef$arguments !== undefined ? _fieldDef$arguments : [];
      checkArgUniqueness(`${typeName}.${fieldName}`, argumentNodes);
    }
    return false;
  }
  function checkArgUniqueness(parentName, argumentNodes) {
    const seenArgs = groupBy(argumentNodes, (arg) => arg.name.value);
    for (const [argName, argNodes] of seenArgs) {
      if (argNodes.length > 1) {
        context.reportError(new GraphQLError(`Argument "${parentName}(${argName}:)" can only be defined once.`, {
          nodes: argNodes.map((node) => node.name)
        }));
      }
    }
    return false;
  }
}

// node_modules/graphql/validation/rules/UniqueArgumentNamesRule.mjs
function UniqueArgumentNamesRule(context) {
  return {
    Field: checkArgUniqueness,
    Directive: checkArgUniqueness
  };
  function checkArgUniqueness(parentNode) {
    var _parentNode$arguments;
    const argumentNodes = (_parentNode$arguments = parentNode.arguments) !== null && _parentNode$arguments !== undefined ? _parentNode$arguments : [];
    const seenArgs = groupBy(argumentNodes, (arg) => arg.name.value);
    for (const [argName, argNodes] of seenArgs) {
      if (argNodes.length > 1) {
        context.reportError(new GraphQLError(`There can be only one argument named "${argName}".`, {
          nodes: argNodes.map((node) => node.name)
        }));
      }
    }
  }
}

// node_modules/graphql/validation/rules/UniqueDirectiveNamesRule.mjs
function UniqueDirectiveNamesRule(context) {
  const knownDirectiveNames = Object.create(null);
  const schema2 = context.getSchema();
  return {
    DirectiveDefinition(node) {
      const directiveName = node.name.value;
      if (schema2 !== null && schema2 !== undefined && schema2.getDirective(directiveName)) {
        context.reportError(new GraphQLError(`Directive "@${directiveName}" already exists in the schema. It cannot be redefined.`, {
          nodes: node.name
        }));
        return;
      }
      if (knownDirectiveNames[directiveName]) {
        context.reportError(new GraphQLError(`There can be only one directive named "@${directiveName}".`, {
          nodes: [knownDirectiveNames[directiveName], node.name]
        }));
      } else {
        knownDirectiveNames[directiveName] = node.name;
      }
      return false;
    }
  };
}

// node_modules/graphql/validation/rules/UniqueDirectivesPerLocationRule.mjs
function UniqueDirectivesPerLocationRule(context) {
  const uniqueDirectiveMap = Object.create(null);
  const schema2 = context.getSchema();
  const definedDirectives = schema2 ? schema2.getDirectives() : specifiedDirectives;
  for (const directive of definedDirectives) {
    uniqueDirectiveMap[directive.name] = !directive.isRepeatable;
  }
  const astDefinitions = context.getDocument().definitions;
  for (const def of astDefinitions) {
    if (def.kind === Kind.DIRECTIVE_DEFINITION) {
      uniqueDirectiveMap[def.name.value] = !def.repeatable;
    }
  }
  const schemaDirectives = Object.create(null);
  const typeDirectivesMap = Object.create(null);
  return {
    enter(node) {
      if (!("directives" in node) || !node.directives) {
        return;
      }
      let seenDirectives;
      if (node.kind === Kind.SCHEMA_DEFINITION || node.kind === Kind.SCHEMA_EXTENSION) {
        seenDirectives = schemaDirectives;
      } else if (isTypeDefinitionNode(node) || isTypeExtensionNode(node)) {
        const typeName = node.name.value;
        seenDirectives = typeDirectivesMap[typeName];
        if (seenDirectives === undefined) {
          typeDirectivesMap[typeName] = seenDirectives = Object.create(null);
        }
      } else {
        seenDirectives = Object.create(null);
      }
      for (const directive of node.directives) {
        const directiveName = directive.name.value;
        if (uniqueDirectiveMap[directiveName]) {
          if (seenDirectives[directiveName]) {
            context.reportError(new GraphQLError(`The directive "@${directiveName}" can only be used once at this location.`, {
              nodes: [seenDirectives[directiveName], directive]
            }));
          } else {
            seenDirectives[directiveName] = directive;
          }
        }
      }
    }
  };
}

// node_modules/graphql/validation/rules/UniqueEnumValueNamesRule.mjs
function UniqueEnumValueNamesRule(context) {
  const schema2 = context.getSchema();
  const existingTypeMap = schema2 ? schema2.getTypeMap() : Object.create(null);
  const knownValueNames = Object.create(null);
  return {
    EnumTypeDefinition: checkValueUniqueness,
    EnumTypeExtension: checkValueUniqueness
  };
  function checkValueUniqueness(node) {
    var _node$values;
    const typeName = node.name.value;
    if (!knownValueNames[typeName]) {
      knownValueNames[typeName] = Object.create(null);
    }
    const valueNodes = (_node$values = node.values) !== null && _node$values !== undefined ? _node$values : [];
    const valueNames = knownValueNames[typeName];
    for (const valueDef of valueNodes) {
      const valueName = valueDef.name.value;
      const existingType = existingTypeMap[typeName];
      if (isEnumType(existingType) && existingType.getValue(valueName)) {
        context.reportError(new GraphQLError(`Enum value "${typeName}.${valueName}" already exists in the schema. It cannot also be defined in this type extension.`, {
          nodes: valueDef.name
        }));
      } else if (valueNames[valueName]) {
        context.reportError(new GraphQLError(`Enum value "${typeName}.${valueName}" can only be defined once.`, {
          nodes: [valueNames[valueName], valueDef.name]
        }));
      } else {
        valueNames[valueName] = valueDef.name;
      }
    }
    return false;
  }
}

// node_modules/graphql/validation/rules/UniqueFieldDefinitionNamesRule.mjs
function UniqueFieldDefinitionNamesRule(context) {
  const schema2 = context.getSchema();
  const existingTypeMap = schema2 ? schema2.getTypeMap() : Object.create(null);
  const knownFieldNames = Object.create(null);
  return {
    InputObjectTypeDefinition: checkFieldUniqueness,
    InputObjectTypeExtension: checkFieldUniqueness,
    InterfaceTypeDefinition: checkFieldUniqueness,
    InterfaceTypeExtension: checkFieldUniqueness,
    ObjectTypeDefinition: checkFieldUniqueness,
    ObjectTypeExtension: checkFieldUniqueness
  };
  function checkFieldUniqueness(node) {
    var _node$fields;
    const typeName = node.name.value;
    if (!knownFieldNames[typeName]) {
      knownFieldNames[typeName] = Object.create(null);
    }
    const fieldNodes = (_node$fields = node.fields) !== null && _node$fields !== undefined ? _node$fields : [];
    const fieldNames = knownFieldNames[typeName];
    for (const fieldDef of fieldNodes) {
      const fieldName = fieldDef.name.value;
      if (hasField(existingTypeMap[typeName], fieldName)) {
        context.reportError(new GraphQLError(`Field "${typeName}.${fieldName}" already exists in the schema. It cannot also be defined in this type extension.`, {
          nodes: fieldDef.name
        }));
      } else if (fieldNames[fieldName]) {
        context.reportError(new GraphQLError(`Field "${typeName}.${fieldName}" can only be defined once.`, {
          nodes: [fieldNames[fieldName], fieldDef.name]
        }));
      } else {
        fieldNames[fieldName] = fieldDef.name;
      }
    }
    return false;
  }
}
var hasField = function(type, fieldName) {
  if (isObjectType(type) || isInterfaceType(type) || isInputObjectType(type)) {
    return type.getFields()[fieldName] != null;
  }
  return false;
};

// node_modules/graphql/validation/rules/UniqueFragmentNamesRule.mjs
function UniqueFragmentNamesRule(context) {
  const knownFragmentNames = Object.create(null);
  return {
    OperationDefinition: () => false,
    FragmentDefinition(node) {
      const fragmentName = node.name.value;
      if (knownFragmentNames[fragmentName]) {
        context.reportError(new GraphQLError(`There can be only one fragment named "${fragmentName}".`, {
          nodes: [knownFragmentNames[fragmentName], node.name]
        }));
      } else {
        knownFragmentNames[fragmentName] = node.name;
      }
      return false;
    }
  };
}

// node_modules/graphql/validation/rules/UniqueInputFieldNamesRule.mjs
function UniqueInputFieldNamesRule(context) {
  const knownNameStack = [];
  let knownNames = Object.create(null);
  return {
    ObjectValue: {
      enter() {
        knownNameStack.push(knownNames);
        knownNames = Object.create(null);
      },
      leave() {
        const prevKnownNames = knownNameStack.pop();
        prevKnownNames || invariant(false);
        knownNames = prevKnownNames;
      }
    },
    ObjectField(node) {
      const fieldName = node.name.value;
      if (knownNames[fieldName]) {
        context.reportError(new GraphQLError(`There can be only one input field named "${fieldName}".`, {
          nodes: [knownNames[fieldName], node.name]
        }));
      } else {
        knownNames[fieldName] = node.name;
      }
    }
  };
}

// node_modules/graphql/validation/rules/UniqueOperationNamesRule.mjs
function UniqueOperationNamesRule(context) {
  const knownOperationNames = Object.create(null);
  return {
    OperationDefinition(node) {
      const operationName = node.name;
      if (operationName) {
        if (knownOperationNames[operationName.value]) {
          context.reportError(new GraphQLError(`There can be only one operation named "${operationName.value}".`, {
            nodes: [
              knownOperationNames[operationName.value],
              operationName
            ]
          }));
        } else {
          knownOperationNames[operationName.value] = operationName;
        }
      }
      return false;
    },
    FragmentDefinition: () => false
  };
}

// node_modules/graphql/validation/rules/UniqueOperationTypesRule.mjs
function UniqueOperationTypesRule(context) {
  const schema2 = context.getSchema();
  const definedOperationTypes = Object.create(null);
  const existingOperationTypes = schema2 ? {
    query: schema2.getQueryType(),
    mutation: schema2.getMutationType(),
    subscription: schema2.getSubscriptionType()
  } : {};
  return {
    SchemaDefinition: checkOperationTypes,
    SchemaExtension: checkOperationTypes
  };
  function checkOperationTypes(node) {
    var _node$operationTypes;
    const operationTypesNodes = (_node$operationTypes = node.operationTypes) !== null && _node$operationTypes !== undefined ? _node$operationTypes : [];
    for (const operationType of operationTypesNodes) {
      const operation = operationType.operation;
      const alreadyDefinedOperationType = definedOperationTypes[operation];
      if (existingOperationTypes[operation]) {
        context.reportError(new GraphQLError(`Type for ${operation} already defined in the schema. It cannot be redefined.`, {
          nodes: operationType
        }));
      } else if (alreadyDefinedOperationType) {
        context.reportError(new GraphQLError(`There can be only one ${operation} type in schema.`, {
          nodes: [alreadyDefinedOperationType, operationType]
        }));
      } else {
        definedOperationTypes[operation] = operationType;
      }
    }
    return false;
  }
}

// node_modules/graphql/validation/rules/UniqueTypeNamesRule.mjs
function UniqueTypeNamesRule(context) {
  const knownTypeNames = Object.create(null);
  const schema2 = context.getSchema();
  return {
    ScalarTypeDefinition: checkTypeName,
    ObjectTypeDefinition: checkTypeName,
    InterfaceTypeDefinition: checkTypeName,
    UnionTypeDefinition: checkTypeName,
    EnumTypeDefinition: checkTypeName,
    InputObjectTypeDefinition: checkTypeName
  };
  function checkTypeName(node) {
    const typeName = node.name.value;
    if (schema2 !== null && schema2 !== undefined && schema2.getType(typeName)) {
      context.reportError(new GraphQLError(`Type "${typeName}" already exists in the schema. It cannot also be defined in this type definition.`, {
        nodes: node.name
      }));
      return;
    }
    if (knownTypeNames[typeName]) {
      context.reportError(new GraphQLError(`There can be only one type named "${typeName}".`, {
        nodes: [knownTypeNames[typeName], node.name]
      }));
    } else {
      knownTypeNames[typeName] = node.name;
    }
    return false;
  }
}

// node_modules/graphql/validation/rules/UniqueVariableNamesRule.mjs
function UniqueVariableNamesRule(context) {
  return {
    OperationDefinition(operationNode) {
      var _operationNode$variab;
      const variableDefinitions = (_operationNode$variab = operationNode.variableDefinitions) !== null && _operationNode$variab !== undefined ? _operationNode$variab : [];
      const seenVariableDefinitions = groupBy(variableDefinitions, (node) => node.variable.name.value);
      for (const [variableName, variableNodes] of seenVariableDefinitions) {
        if (variableNodes.length > 1) {
          context.reportError(new GraphQLError(`There can be only one variable named "\$${variableName}".`, {
            nodes: variableNodes.map((node) => node.variable.name)
          }));
        }
      }
    }
  };
}

// node_modules/graphql/validation/rules/ValuesOfCorrectTypeRule.mjs
function ValuesOfCorrectTypeRule(context) {
  return {
    ListValue(node) {
      const type = getNullableType(context.getParentInputType());
      if (!isListType(type)) {
        isValidValueNode(context, node);
        return false;
      }
    },
    ObjectValue(node) {
      const type = getNamedType(context.getInputType());
      if (!isInputObjectType(type)) {
        isValidValueNode(context, node);
        return false;
      }
      const fieldNodeMap = keyMap(node.fields, (field) => field.name.value);
      for (const fieldDef of Object.values(type.getFields())) {
        const fieldNode = fieldNodeMap[fieldDef.name];
        if (!fieldNode && isRequiredInputField(fieldDef)) {
          const typeStr = inspect(fieldDef.type);
          context.reportError(new GraphQLError(`Field "${type.name}.${fieldDef.name}" of required type "${typeStr}" was not provided.`, {
            nodes: node
          }));
        }
      }
    },
    ObjectField(node) {
      const parentType = getNamedType(context.getParentInputType());
      const fieldType = context.getInputType();
      if (!fieldType && isInputObjectType(parentType)) {
        const suggestions = suggestionList(node.name.value, Object.keys(parentType.getFields()));
        context.reportError(new GraphQLError(`Field "${node.name.value}" is not defined by type "${parentType.name}".` + didYouMean(suggestions), {
          nodes: node
        }));
      }
    },
    NullValue(node) {
      const type = context.getInputType();
      if (isNonNullType(type)) {
        context.reportError(new GraphQLError(`Expected value of type "${inspect(type)}", found ${print(node)}.`, {
          nodes: node
        }));
      }
    },
    EnumValue: (node) => isValidValueNode(context, node),
    IntValue: (node) => isValidValueNode(context, node),
    FloatValue: (node) => isValidValueNode(context, node),
    StringValue: (node) => isValidValueNode(context, node),
    BooleanValue: (node) => isValidValueNode(context, node)
  };
}
var isValidValueNode = function(context, node) {
  const locationType = context.getInputType();
  if (!locationType) {
    return;
  }
  const type = getNamedType(locationType);
  if (!isLeafType(type)) {
    const typeStr = inspect(locationType);
    context.reportError(new GraphQLError(`Expected value of type "${typeStr}", found ${print(node)}.`, {
      nodes: node
    }));
    return;
  }
  try {
    const parseResult = type.parseLiteral(node, undefined);
    if (parseResult === undefined) {
      const typeStr = inspect(locationType);
      context.reportError(new GraphQLError(`Expected value of type "${typeStr}", found ${print(node)}.`, {
        nodes: node
      }));
    }
  } catch (error) {
    const typeStr = inspect(locationType);
    if (error instanceof GraphQLError) {
      context.reportError(error);
    } else {
      context.reportError(new GraphQLError(`Expected value of type "${typeStr}", found ${print(node)}; ` + error.message, {
        nodes: node,
        originalError: error
      }));
    }
  }
};

// node_modules/graphql/validation/rules/VariablesAreInputTypesRule.mjs
function VariablesAreInputTypesRule(context) {
  return {
    VariableDefinition(node) {
      const type = typeFromAST(context.getSchema(), node.type);
      if (type !== undefined && !isInputType(type)) {
        const variableName = node.variable.name.value;
        const typeName = print(node.type);
        context.reportError(new GraphQLError(`Variable "\$${variableName}" cannot be non-input type "${typeName}".`, {
          nodes: node.type
        }));
      }
    }
  };
}

// node_modules/graphql/validation/rules/VariablesInAllowedPositionRule.mjs
function VariablesInAllowedPositionRule(context) {
  let varDefMap = Object.create(null);
  return {
    OperationDefinition: {
      enter() {
        varDefMap = Object.create(null);
      },
      leave(operation) {
        const usages = context.getRecursiveVariableUsages(operation);
        for (const { node, type, defaultValue } of usages) {
          const varName = node.name.value;
          const varDef = varDefMap[varName];
          if (varDef && type) {
            const schema2 = context.getSchema();
            const varType = typeFromAST(schema2, varDef.type);
            if (varType && !allowedVariableUsage(schema2, varType, varDef.defaultValue, type, defaultValue)) {
              const varTypeStr = inspect(varType);
              const typeStr = inspect(type);
              context.reportError(new GraphQLError(`Variable "\$${varName}" of type "${varTypeStr}" used in position expecting type "${typeStr}".`, {
                nodes: [varDef, node]
              }));
            }
          }
        }
      }
    },
    VariableDefinition(node) {
      varDefMap[node.variable.name.value] = node;
    }
  };
}
var allowedVariableUsage = function(schema2, varType, varDefaultValue, locationType, locationDefaultValue) {
  if (isNonNullType(locationType) && !isNonNullType(varType)) {
    const hasNonNullVariableDefaultValue = varDefaultValue != null && varDefaultValue.kind !== Kind.NULL;
    const hasLocationDefaultValue = locationDefaultValue !== undefined;
    if (!hasNonNullVariableDefaultValue && !hasLocationDefaultValue) {
      return false;
    }
    const nullableLocationType = locationType.ofType;
    return isTypeSubTypeOf(schema2, varType, nullableLocationType);
  }
  return isTypeSubTypeOf(schema2, varType, locationType);
};

// node_modules/graphql/validation/specifiedRules.mjs
var specifiedRules = Object.freeze([
  ExecutableDefinitionsRule,
  UniqueOperationNamesRule,
  LoneAnonymousOperationRule,
  SingleFieldSubscriptionsRule,
  KnownTypeNamesRule,
  FragmentsOnCompositeTypesRule,
  VariablesAreInputTypesRule,
  ScalarLeafsRule,
  FieldsOnCorrectTypeRule,
  UniqueFragmentNamesRule,
  KnownFragmentNamesRule,
  NoUnusedFragmentsRule,
  PossibleFragmentSpreadsRule,
  NoFragmentCyclesRule,
  UniqueVariableNamesRule,
  NoUndefinedVariablesRule,
  NoUnusedVariablesRule,
  KnownDirectivesRule,
  UniqueDirectivesPerLocationRule,
  KnownArgumentNamesRule,
  UniqueArgumentNamesRule,
  ValuesOfCorrectTypeRule,
  ProvidedRequiredArgumentsRule,
  VariablesInAllowedPositionRule,
  OverlappingFieldsCanBeMergedRule,
  UniqueInputFieldNamesRule
]);
var specifiedSDLRules = Object.freeze([
  LoneSchemaDefinitionRule,
  UniqueOperationTypesRule,
  UniqueTypeNamesRule,
  UniqueEnumValueNamesRule,
  UniqueFieldDefinitionNamesRule,
  UniqueArgumentDefinitionNamesRule,
  UniqueDirectiveNamesRule,
  KnownTypeNamesRule,
  KnownDirectivesRule,
  UniqueDirectivesPerLocationRule,
  PossibleTypeExtensionsRule,
  KnownArgumentNamesOnDirectivesRule,
  UniqueArgumentNamesRule,
  UniqueInputFieldNamesRule,
  ProvidedRequiredArgumentsOnDirectivesRule
]);

// node_modules/graphql/validation/ValidationContext.mjs
class ASTValidationContext {
  constructor(ast8, onError) {
    this._ast = ast8;
    this._fragments = undefined;
    this._fragmentSpreads = new Map;
    this._recursivelyReferencedFragments = new Map;
    this._onError = onError;
  }
  get [Symbol.toStringTag]() {
    return "ASTValidationContext";
  }
  reportError(error) {
    this._onError(error);
  }
  getDocument() {
    return this._ast;
  }
  getFragment(name) {
    let fragments;
    if (this._fragments) {
      fragments = this._fragments;
    } else {
      fragments = Object.create(null);
      for (const defNode of this.getDocument().definitions) {
        if (defNode.kind === Kind.FRAGMENT_DEFINITION) {
          fragments[defNode.name.value] = defNode;
        }
      }
      this._fragments = fragments;
    }
    return fragments[name];
  }
  getFragmentSpreads(node) {
    let spreads = this._fragmentSpreads.get(node);
    if (!spreads) {
      spreads = [];
      const setsToVisit = [node];
      let set;
      while (set = setsToVisit.pop()) {
        for (const selection of set.selections) {
          if (selection.kind === Kind.FRAGMENT_SPREAD) {
            spreads.push(selection);
          } else if (selection.selectionSet) {
            setsToVisit.push(selection.selectionSet);
          }
        }
      }
      this._fragmentSpreads.set(node, spreads);
    }
    return spreads;
  }
  getRecursivelyReferencedFragments(operation) {
    let fragments = this._recursivelyReferencedFragments.get(operation);
    if (!fragments) {
      fragments = [];
      const collectedNames = Object.create(null);
      const nodesToVisit = [operation.selectionSet];
      let node;
      while (node = nodesToVisit.pop()) {
        for (const spread of this.getFragmentSpreads(node)) {
          const fragName = spread.name.value;
          if (collectedNames[fragName] !== true) {
            collectedNames[fragName] = true;
            const fragment = this.getFragment(fragName);
            if (fragment) {
              fragments.push(fragment);
              nodesToVisit.push(fragment.selectionSet);
            }
          }
        }
      }
      this._recursivelyReferencedFragments.set(operation, fragments);
    }
    return fragments;
  }
}

class SDLValidationContext extends ASTValidationContext {
  constructor(ast8, schema2, onError) {
    super(ast8, onError);
    this._schema = schema2;
  }
  get [Symbol.toStringTag]() {
    return "SDLValidationContext";
  }
  getSchema() {
    return this._schema;
  }
}

class ValidationContext extends ASTValidationContext {
  constructor(schema2, ast8, typeInfo, onError) {
    super(ast8, onError);
    this._schema = schema2;
    this._typeInfo = typeInfo;
    this._variableUsages = new Map;
    this._recursiveVariableUsages = new Map;
  }
  get [Symbol.toStringTag]() {
    return "ValidationContext";
  }
  getSchema() {
    return this._schema;
  }
  getVariableUsages(node) {
    let usages = this._variableUsages.get(node);
    if (!usages) {
      const newUsages = [];
      const typeInfo = new TypeInfo(this._schema);
      visit(node, visitWithTypeInfo(typeInfo, {
        VariableDefinition: () => false,
        Variable(variable) {
          newUsages.push({
            node: variable,
            type: typeInfo.getInputType(),
            defaultValue: typeInfo.getDefaultValue()
          });
        }
      }));
      usages = newUsages;
      this._variableUsages.set(node, usages);
    }
    return usages;
  }
  getRecursiveVariableUsages(operation) {
    let usages = this._recursiveVariableUsages.get(operation);
    if (!usages) {
      usages = this.getVariableUsages(operation);
      for (const frag of this.getRecursivelyReferencedFragments(operation)) {
        usages = usages.concat(this.getVariableUsages(frag));
      }
      this._recursiveVariableUsages.set(operation, usages);
    }
    return usages;
  }
  getType() {
    return this._typeInfo.getType();
  }
  getParentType() {
    return this._typeInfo.getParentType();
  }
  getInputType() {
    return this._typeInfo.getInputType();
  }
  getParentInputType() {
    return this._typeInfo.getParentInputType();
  }
  getFieldDef() {
    return this._typeInfo.getFieldDef();
  }
  getDirective() {
    return this._typeInfo.getDirective();
  }
  getArgument() {
    return this._typeInfo.getArgument();
  }
  getEnumValue() {
    return this._typeInfo.getEnumValue();
  }
}

// node_modules/graphql/validation/validate.mjs
function validate2(schema2, documentAST, rules = specifiedRules, options, typeInfo = new TypeInfo(schema2)) {
  var _options$maxErrors;
  const maxErrors = (_options$maxErrors = options === null || options === undefined ? undefined : options.maxErrors) !== null && _options$maxErrors !== undefined ? _options$maxErrors : 100;
  documentAST || devAssert(false, "Must provide document.");
  assertValidSchema(schema2);
  const abortObj = Object.freeze({});
  const errors = [];
  const context = new ValidationContext(schema2, documentAST, typeInfo, (error) => {
    if (errors.length >= maxErrors) {
      errors.push(new GraphQLError("Too many validation errors, error limit reached. Validation aborted."));
      throw abortObj;
    }
    errors.push(error);
  });
  const visitor5 = visitInParallel(rules.map((rule) => rule(context)));
  try {
    visit(documentAST, visitWithTypeInfo(typeInfo, visitor5));
  } catch (e) {
    if (e !== abortObj) {
      throw e;
    }
  }
  return errors;
}

// node_modules/graphql/jsutils/memoize3.mjs
function memoize3(fn) {
  let cache0;
  return function memoized(a1, a2, a3) {
    if (cache0 === undefined) {
      cache0 = new WeakMap;
    }
    let cache1 = cache0.get(a1);
    if (cache1 === undefined) {
      cache1 = new WeakMap;
      cache0.set(a1, cache1);
    }
    let cache2 = cache1.get(a2);
    if (cache2 === undefined) {
      cache2 = new WeakMap;
      cache1.set(a2, cache2);
    }
    let fnResult = cache2.get(a3);
    if (fnResult === undefined) {
      fnResult = fn(a1, a2, a3);
      cache2.set(a3, fnResult);
    }
    return fnResult;
  };
}

// node_modules/graphql/jsutils/toError.mjs
function toError(thrownValue) {
  return thrownValue instanceof Error ? thrownValue : new NonErrorThrown(thrownValue);
}

class NonErrorThrown extends Error {
  constructor(thrownValue) {
    super("Unexpected error value: " + inspect(thrownValue));
    this.name = "NonErrorThrown";
    this.thrownValue = thrownValue;
  }
}

// node_modules/graphql/error/locatedError.mjs
function locatedError(rawOriginalError, nodes, path) {
  var _nodes;
  const originalError = toError(rawOriginalError);
  if (isLocatedGraphQLError(originalError)) {
    return originalError;
  }
  return new GraphQLError(originalError.message, {
    nodes: (_nodes = originalError.nodes) !== null && _nodes !== undefined ? _nodes : nodes,
    source: originalError.source,
    positions: originalError.positions,
    path,
    originalError
  });
}
var isLocatedGraphQLError = function(error) {
  return Array.isArray(error.path);
};

// node_modules/graphql/execution/execute.mjs
var collectSubfields2 = memoize3((exeContext, returnType, fieldNodes) => collectSubfields(exeContext.schema, exeContext.fragments, exeContext.variableValues, returnType, fieldNodes));
var defaultTypeResolver = function(value, contextValue, info, abstractType) {
  if (isObjectLike(value) && typeof value.__typename === "string") {
    return value.__typename;
  }
  const possibleTypes = info.schema.getPossibleTypes(abstractType);
  const promisedIsTypeOfResults = [];
  for (let i = 0;i < possibleTypes.length; i++) {
    const type = possibleTypes[i];
    if (type.isTypeOf) {
      const isTypeOfResult = type.isTypeOf(value, contextValue, info);
      if (isPromise(isTypeOfResult)) {
        promisedIsTypeOfResults[i] = isTypeOfResult;
      } else if (isTypeOfResult) {
        return type.name;
      }
    }
  }
  if (promisedIsTypeOfResults.length) {
    return Promise.all(promisedIsTypeOfResults).then((isTypeOfResults) => {
      for (let i = 0;i < isTypeOfResults.length; i++) {
        if (isTypeOfResults[i]) {
          return possibleTypes[i].name;
        }
      }
    });
  }
};
var defaultFieldResolver = function(source2, args, contextValue, info) {
  if (isObjectLike(source2) || typeof source2 === "function") {
    const property = source2[info.fieldName];
    if (typeof property === "function") {
      return source2[info.fieldName](args, contextValue, info);
    }
    return property;
  }
};
// node_modules/graphql/utilities/getOperationAST.mjs
function getOperationAST(documentAST, operationName) {
  let operation = null;
  for (const definition26 of documentAST.definitions) {
    if (definition26.kind === Kind.OPERATION_DEFINITION) {
      var _definition$name;
      if (operationName == null) {
        if (operation) {
          return null;
        }
        operation = definition26;
      } else if (((_definition$name = definition26.name) === null || _definition$name === undefined ? undefined : _definition$name.value) === operationName) {
        return definition26;
      }
    }
  }
  return operation;
}
// node_modules/graphql/utilities/lexicographicSortSchema.mjs
function lexicographicSortSchema(schema3) {
  const schemaConfig = schema3.toConfig();
  const typeMap = keyValMap(sortByName(schemaConfig.types), (type) => type.name, sortNamedType);
  return new GraphQLSchema({
    ...schemaConfig,
    types: Object.values(typeMap),
    directives: sortByName(schemaConfig.directives).map(sortDirective),
    query: replaceMaybeType(schemaConfig.query),
    mutation: replaceMaybeType(schemaConfig.mutation),
    subscription: replaceMaybeType(schemaConfig.subscription)
  });
  function replaceType(type) {
    if (isListType(type)) {
      return new GraphQLList(replaceType(type.ofType));
    } else if (isNonNullType(type)) {
      return new GraphQLNonNull(replaceType(type.ofType));
    }
    return replaceNamedType(type);
  }
  function replaceNamedType(type) {
    return typeMap[type.name];
  }
  function replaceMaybeType(maybeType) {
    return maybeType && replaceNamedType(maybeType);
  }
  function sortDirective(directive) {
    const config = directive.toConfig();
    return new GraphQLDirective({
      ...config,
      locations: sortBy(config.locations, (x) => x),
      args: sortArgs(config.args)
    });
  }
  function sortArgs(args) {
    return sortObjMap(args, (arg) => ({ ...arg, type: replaceType(arg.type) }));
  }
  function sortFields2(fieldsMap) {
    return sortObjMap(fieldsMap, (field) => ({
      ...field,
      type: replaceType(field.type),
      args: field.args && sortArgs(field.args)
    }));
  }
  function sortInputFields(fieldsMap) {
    return sortObjMap(fieldsMap, (field) => ({
      ...field,
      type: replaceType(field.type)
    }));
  }
  function sortTypes(array) {
    return sortByName(array).map(replaceNamedType);
  }
  function sortNamedType(type) {
    if (isScalarType(type) || isIntrospectionType(type)) {
      return type;
    }
    if (isObjectType(type)) {
      const config = type.toConfig();
      return new GraphQLObjectType({
        ...config,
        interfaces: () => sortTypes(config.interfaces),
        fields: () => sortFields2(config.fields)
      });
    }
    if (isInterfaceType(type)) {
      const config = type.toConfig();
      return new GraphQLInterfaceType({
        ...config,
        interfaces: () => sortTypes(config.interfaces),
        fields: () => sortFields2(config.fields)
      });
    }
    if (isUnionType(type)) {
      const config = type.toConfig();
      return new GraphQLUnionType({
        ...config,
        types: () => sortTypes(config.types)
      });
    }
    if (isEnumType(type)) {
      const config = type.toConfig();
      return new GraphQLEnumType({
        ...config,
        values: sortObjMap(config.values, (value) => value)
      });
    }
    if (isInputObjectType(type)) {
      const config = type.toConfig();
      return new GraphQLInputObjectType({
        ...config,
        fields: () => sortInputFields(config.fields)
      });
    }
    invariant(false, "Unexpected type: " + inspect(type));
  }
}
var sortObjMap = function(map, sortValueFn) {
  const sortedMap = Object.create(null);
  for (const key of Object.keys(map).sort(naturalCompare)) {
    sortedMap[key] = sortValueFn(map[key]);
  }
  return sortedMap;
};
var sortByName = function(array) {
  return sortBy(array, (obj) => obj.name);
};
var sortBy = function(array, mapToKey) {
  return array.slice().sort((obj1, obj2) => {
    const key1 = mapToKey(obj1);
    const key2 = mapToKey(obj2);
    return naturalCompare(key1, key2);
  });
};
// node_modules/graphql/utilities/printSchema.mjs
function printSchema(schema3) {
  return printFilteredSchema(schema3, (n) => !isSpecifiedDirective(n), isDefinedType);
}
var isDefinedType = function(type) {
  return !isSpecifiedScalarType(type) && !isIntrospectionType(type);
};
var printFilteredSchema = function(schema3, directiveFilter, typeFilter) {
  const directives10 = schema3.getDirectives().filter(directiveFilter);
  const types = Object.values(schema3.getTypeMap()).filter(typeFilter);
  return [
    printSchemaDefinition(schema3),
    ...directives10.map((directive) => printDirective(directive)),
    ...types.map((type) => printType(type))
  ].filter(Boolean).join("\n\n");
};
var printSchemaDefinition = function(schema3) {
  if (schema3.description == null && isSchemaOfCommonNames(schema3)) {
    return;
  }
  const operationTypes = [];
  const queryType = schema3.getQueryType();
  if (queryType) {
    operationTypes.push(`  query: ${queryType.name}`);
  }
  const mutationType = schema3.getMutationType();
  if (mutationType) {
    operationTypes.push(`  mutation: ${mutationType.name}`);
  }
  const subscriptionType = schema3.getSubscriptionType();
  if (subscriptionType) {
    operationTypes.push(`  subscription: ${subscriptionType.name}`);
  }
  return printDescription(schema3) + `schema {\n${operationTypes.join("\n")}\n}`;
};
var isSchemaOfCommonNames = function(schema3) {
  const queryType = schema3.getQueryType();
  if (queryType && queryType.name !== "Query") {
    return false;
  }
  const mutationType = schema3.getMutationType();
  if (mutationType && mutationType.name !== "Mutation") {
    return false;
  }
  const subscriptionType = schema3.getSubscriptionType();
  if (subscriptionType && subscriptionType.name !== "Subscription") {
    return false;
  }
  return true;
};
function printType(type) {
  if (isScalarType(type)) {
    return printScalar(type);
  }
  if (isObjectType(type)) {
    return printObject(type);
  }
  if (isInterfaceType(type)) {
    return printInterface(type);
  }
  if (isUnionType(type)) {
    return printUnion(type);
  }
  if (isEnumType(type)) {
    return printEnum(type);
  }
  if (isInputObjectType(type)) {
    return printInputObject(type);
  }
  invariant(false, "Unexpected type: " + inspect(type));
}
var printScalar = function(type) {
  return printDescription(type) + `scalar ${type.name}` + printSpecifiedByURL(type);
};
var printImplementedInterfaces = function(type) {
  const interfaces = type.getInterfaces();
  return interfaces.length ? " implements " + interfaces.map((i) => i.name).join(" & ") : "";
};
var printObject = function(type) {
  return printDescription(type) + `type ${type.name}` + printImplementedInterfaces(type) + printFields(type);
};
var printInterface = function(type) {
  return printDescription(type) + `interface ${type.name}` + printImplementedInterfaces(type) + printFields(type);
};
var printUnion = function(type) {
  const types = type.getTypes();
  const possibleTypes = types.length ? " = " + types.join(" | ") : "";
  return printDescription(type) + "union " + type.name + possibleTypes;
};
var printEnum = function(type) {
  const values2 = type.getValues().map((value, i) => printDescription(value, "  ", !i) + "  " + value.name + printDeprecated(value.deprecationReason));
  return printDescription(type) + `enum ${type.name}` + printBlock(values2);
};
var printInputObject = function(type) {
  const fields = Object.values(type.getFields()).map((f, i) => printDescription(f, "  ", !i) + "  " + printInputValue(f));
  return printDescription(type) + `input ${type.name}` + printBlock(fields);
};
var printFields = function(type) {
  const fields = Object.values(type.getFields()).map((f, i) => printDescription(f, "  ", !i) + "  " + f.name + printArgs(f.args, "  ") + ": " + String(f.type) + printDeprecated(f.deprecationReason));
  return printBlock(fields);
};
var printBlock = function(items) {
  return items.length !== 0 ? " {\n" + items.join("\n") + "\n}" : "";
};
var printArgs = function(args, indentation = "") {
  if (args.length === 0) {
    return "";
  }
  if (args.every((arg) => !arg.description)) {
    return "(" + args.map(printInputValue).join(", ") + ")";
  }
  return "(\n" + args.map((arg, i) => printDescription(arg, "  " + indentation, !i) + "  " + indentation + printInputValue(arg)).join("\n") + "\n" + indentation + ")";
};
var printInputValue = function(arg) {
  const defaultAST = astFromValue(arg.defaultValue, arg.type);
  let argDecl = arg.name + ": " + String(arg.type);
  if (defaultAST) {
    argDecl += ` = ${print(defaultAST)}`;
  }
  return argDecl + printDeprecated(arg.deprecationReason);
};
var printDirective = function(directive) {
  return printDescription(directive) + "directive @" + directive.name + printArgs(directive.args) + (directive.isRepeatable ? " repeatable" : "") + " on " + directive.locations.join(" | ");
};
var printDeprecated = function(reason) {
  if (reason == null) {
    return "";
  }
  if (reason !== DEFAULT_DEPRECATION_REASON) {
    const astValue = print({
      kind: Kind.STRING,
      value: reason
    });
    return ` @deprecated(reason: ${astValue})`;
  }
  return " @deprecated";
};
var printSpecifiedByURL = function(scalar) {
  if (scalar.specifiedByURL == null) {
    return "";
  }
  const astValue = print({
    kind: Kind.STRING,
    value: scalar.specifiedByURL
  });
  return ` @specifiedBy(url: ${astValue})`;
};
var printDescription = function(def, indentation = "", firstInBlock = true) {
  const { description } = def;
  if (description == null) {
    return "";
  }
  const blockString4 = print({
    kind: Kind.STRING,
    value: description,
    block: isPrintableAsBlockString(description)
  });
  const prefix = indentation && !firstInBlock ? "\n" + indentation : indentation;
  return prefix + blockString4.replace(/\n/g, "\n" + indentation) + "\n";
};
// node_modules/graphql/utilities/assertValidName.mjs
function assertValidName(name) {
  const error = isValidNameError(name);
  if (error) {
    throw error;
  }
  return name;
}
function isValidNameError(name) {
  typeof name === "string" || devAssert(false, "Expected name to be a string.");
  if (name.startsWith("__")) {
    return new GraphQLError(`Name "${name}" must not begin with "__", which is reserved by GraphQL introspection.`);
  }
  try {
    assertName(name);
  } catch (error) {
    return error;
  }
}
// node_modules/nexus/dist-esm/definitions/_types.js
function withNexusSymbol(obj, nexusType) {
  obj.prototype[NexusWrappedSymbol] = nexusType;
}
var NexusTypes;
(function(NexusTypes2) {
  NexusTypes2["Arg"] = "Arg";
  NexusTypes2["DynamicInput"] = "DynamicInput";
  NexusTypes2["DynamicOutputMethod"] = "DynamicOutputMethod";
  NexusTypes2["DynamicOutputProperty"] = "DynamicOutputProperty";
  NexusTypes2["Enum"] = "Enum";
  NexusTypes2["ExtendInputObject"] = "ExtendInputObject";
  NexusTypes2["ExtendObject"] = "ExtendObject";
  NexusTypes2["InputField"] = "InputField";
  NexusTypes2["InputObject"] = "InputObject";
  NexusTypes2["Interface"] = "Interface";
  NexusTypes2["List"] = "List";
  NexusTypes2["NonNull"] = "NonNull";
  NexusTypes2["Null"] = "Null";
  NexusTypes2["Object"] = "Object";
  NexusTypes2["OutputField"] = "OutputField";
  NexusTypes2["Plugin"] = "Plugin";
  NexusTypes2["PrintedGenTyping"] = "PrintedGenTyping";
  NexusTypes2["PrintedGenTypingImport"] = "PrintedGenTypingImport";
  NexusTypes2["Scalar"] = "Scalar";
  NexusTypes2["Union"] = "Union";
})(NexusTypes || (NexusTypes = {}));
var NexusWrappedSymbol = Symbol.for("@nexus/wrapped");

// node_modules/nexus/dist-esm/definitions/interfaceType.js
function interfaceType(config) {
  return new NexusInterfaceTypeDef(config.name, config);
}

class InterfaceDefinitionBlock extends OutputDefinitionBlock {
  constructor(typeBuilder) {
    super(typeBuilder);
    this.typeBuilder = typeBuilder;
  }
  implements(...interfaceName) {
    this.typeBuilder.addInterfaces(interfaceName);
  }
  modify(field, modifications) {
    this.typeBuilder.addModification(Object.assign(Object.assign({}, modifications), { field }));
  }
}

class NexusInterfaceTypeDef {
  constructor(name, config) {
    this.name = name;
    this.config = config;
    assertValidName(name);
  }
  get value() {
    return this.config;
  }
}
withNexusSymbol(NexusInterfaceTypeDef, NexusTypes.Interface);
// node_modules/nexus/dist-esm/definitions/objectType.js
function objectType(config) {
  return new NexusObjectTypeDef(config.name, config);
}

class ObjectDefinitionBlock extends OutputDefinitionBlock {
  constructor(typeBuilder) {
    super(typeBuilder);
    this.typeBuilder = typeBuilder;
  }
  implements(...interfaceName) {
    this.typeBuilder.addInterfaces(interfaceName);
  }
  modify(field, modifications) {
    this.typeBuilder.addModification(Object.assign(Object.assign({}, modifications), { field }));
  }
}

class NexusObjectTypeDef {
  constructor(name, config) {
    this.name = name;
    this.config = config;
    assertValidName(name);
  }
  get value() {
    return this.config;
  }
}
withNexusSymbol(NexusObjectTypeDef, NexusTypes.Object);
// node_modules/nexus/dist-esm/definitions/unionType.js
function unionType(config) {
  return new NexusUnionTypeDef(config.name, config);
}

class UnionDefinitionBlock {
  constructor(typeBuilder) {
    this.typeBuilder = typeBuilder;
  }
  members(...unionMembers) {
    this.typeBuilder.addUnionMembers(unionMembers);
  }
}

class NexusUnionTypeDef {
  constructor(name, config) {
    this.name = name;
    this.config = config;
    assertValidName(name);
  }
  get value() {
    return this.config;
  }
}
withNexusSymbol(NexusUnionTypeDef, NexusTypes.Union);
// node_modules/tslib/modules/index.js
var tslib = __toESM(require_tslib(), 1);
var {
  __extends,
  __assign,
  __rest,
  __decorate,
  __param,
  __esDecorate,
  __runInitializers,
  __propKey,
  __setFunctionName,
  __metadata,
  __awaiter,
  __generator,
  __exportStar,
  __createBinding,
  __values,
  __read,
  __spread,
  __spreadArrays,
  __spreadArray,
  __await,
  __asyncGenerator,
  __asyncDelegator,
  __asyncValues,
  __makeTemplateObject,
  __importStar,
  __importDefault,
  __classPrivateFieldGet,
  __classPrivateFieldSet,
  __classPrivateFieldIn,
  __addDisposableResource,
  __disposeResources
} = tslib.default;

// node_modules/nexus/dist-esm/utils.js
import * as fs from "fs";
import * as Path2 from "path";

// node_modules/nexus/dist-esm/definitions/decorateType.js
function decorateType(type, config) {
  var _a;
  type.extensions = Object.assign(Object.assign({}, type.extensions), { nexus: Object.assign(Object.assign({}, Object((_a = type.extensions) === null || _a === undefined ? undefined : _a.nexus)), config) });
  return type;
}

// node_modules/nexus/dist-esm/definitions/nexusMeta.js
function isNexusMetaBuild(obj) {
  return Boolean(obj && typeof ownProp.get(obj, NEXUS_BUILD) === "function");
}
function isNexusMetaType(obj) {
  return isNexusMetaTypeProp(obj) || isNexusMetaTypeFn(obj);
}
function isNexusMetaTypeProp(obj) {
  return Boolean(obj && ownProp.has(obj, NEXUS_TYPE) && isNexusStruct(ownProp.get(obj, NEXUS_TYPE)));
}
function isNexusMetaTypeFn(obj) {
  return Boolean(obj && ownProp.has(obj, NEXUS_TYPE) && typeof ownProp.get(obj, NEXUS_TYPE) === "function");
}
function isNexusMeta(obj) {
  return isNexusMetaBuild(obj) || isNexusMetaType(obj) || isNexusMetaTypeFn(obj);
}
function resolveNexusMetaType(obj) {
  let value = ownProp.get(obj, NEXUS_TYPE);
  if (typeof value === "function") {
    value = ownProp.set(obj, NEXUS_TYPE, value.call(obj));
  }
  if (!isNexusObjectTypeDef(value) && !isNexusInterfaceTypeDef(value)) {
    throw new Error(`Expected property of NEXUS_TYPE to be an object or interface type`);
  }
  return value;
}
var NEXUS_TYPE = Symbol.for("@nexus/meta/NEXUS_TYPE");
var NEXUS_BUILD = Symbol.for("@nexus/meta/NEXUS_BUILD");

// node_modules/nexus/dist-esm/utils.js
function suggestionList9(input = "", options = []) {
  var optionsByDistance = Object.create(null);
  var oLength = options.length;
  var inputThreshold = input.length / 2;
  for (var i = 0;i < oLength; i++) {
    var distance = lexicalDistance(input, options[i]);
    var threshold = Math.max(inputThreshold, options[i].length / 2, 1);
    if (distance <= threshold) {
      optionsByDistance[options[i]] = distance;
    }
  }
  return Object.keys(optionsByDistance).sort(function(a, b) {
    return optionsByDistance[a] - optionsByDistance[b];
  });
}
var lexicalDistance = function(aStr, bStr) {
  if (aStr === bStr) {
    return 0;
  }
  let i;
  let j;
  const d = [];
  const a = aStr.toLowerCase();
  const b = bStr.toLowerCase();
  const aLength = a.length;
  const bLength = b.length;
  if (a === b) {
    return 1;
  }
  for (i = 0;i <= aLength; i++) {
    d[i] = [i];
  }
  for (j = 1;j <= bLength; j++) {
    d[0][j] = j;
  }
  for (i = 1;i <= aLength; i++) {
    for (j = 1;j <= bLength; j++) {
      var cost = a[i - 1] === b[j - 1] ? 0 : 1;
      d[i][j] = Math.min(d[i - 1][j] + 1, d[i][j - 1] + 1, d[i - 1][j - 1] + cost);
      if (i > 1 && j > 1 && a[i - 1] === b[j - 2] && a[i - 2] === b[j - 1]) {
        d[i][j] = Math.min(d[i][j], d[i - 2][j - 2] + cost);
      }
    }
  }
  return d[aLength][bLength];
};
function objValues(obj) {
  return Object.keys(obj).reduce((result, key) => {
    result.push(obj[key]);
    return result;
  }, []);
}
function mapObj(obj, mapper) {
  return Object.keys(obj).map((key, index) => mapper(obj[key], key, index));
}
function mapValues(obj, mapper) {
  const result = {};
  Object.keys(obj).forEach((key, index) => result[key] = mapper(obj[key], key, index));
  return result;
}
function eachObj(obj, iter) {
  Object.keys(obj).forEach((name, i) => iter(obj[name], name, i));
}
function groupTypes(schema3) {
  const groupedTypes = {
    input: [],
    interface: [],
    object: [],
    union: [],
    enum: [],
    scalar: Array.from(specifiedScalarTypes)
  };
  const schemaTypeMap = schema3.getTypeMap();
  Object.keys(schemaTypeMap).sort().forEach((typeName) => {
    if (typeName.startsWith("__")) {
      return;
    }
    const type = schema3.getType(typeName);
    if (isObjectType(type)) {
      groupedTypes.object.push(type);
    } else if (isInputObjectType(type)) {
      groupedTypes.input.push(type);
    } else if (isScalarType(type) && !isSpecifiedScalarType(type) && !isUnknownType(type)) {
      groupedTypes.scalar.push(type);
    } else if (isUnionType(type)) {
      groupedTypes.union.push(type);
    } else if (isInterfaceType(type)) {
      groupedTypes.interface.push(type);
    } else if (isEnumType(type)) {
      groupedTypes.enum.push(type);
    }
  });
  return groupedTypes;
}
function isUnknownType(type) {
  return type.name === UNKNOWN_TYPE_SCALAR.name;
}
function isPromiseLike(value) {
  return Boolean(value && typeof value.then === "function");
}
var makeRelativePathExplicitlyRelative = function(path) {
  if (Path2.isAbsolute(path))
    return path;
  if (path.startsWith("./"))
    return path;
  return `./${path}`;
};
var nixifyPathSlashes = function(path) {
  return path.replace(/\\+/g, "/");
};
function formatPathForModuleImport(path) {
  return nixifyPathSlashes(makeRelativePathExplicitlyRelative(path).replace(typeScriptFileExtension, ""));
}
function relativePathTo(absolutePath, fromPath) {
  const filename = Path2.basename(absolutePath);
  const relative2 = Path2.relative(Path2.dirname(fromPath), Path2.dirname(absolutePath));
  return formatPathForModuleImport(Path2.join(relative2, filename));
}
function printedGenTypingImport(config) {
  return new PrintedGenTypingImport(config);
}
function printedGenTyping(config) {
  return new PrintedGenTyping(config);
}
function assertNoMissingTypes(schema3, missingTypes) {
  const missingTypesNames = Object.keys(missingTypes);
  const schemaTypeMap = schema3.getTypeMap();
  const schemaTypeNames = Object.keys(schemaTypeMap).filter((typeName) => !isUnknownType(schemaTypeMap[typeName]));
  if (missingTypesNames.length > 0) {
    const errors = missingTypesNames.map((typeName) => {
      const { fromObject } = missingTypes[typeName];
      if (fromObject) {
        return `- Looks like you forgot to import ${typeName} in the root "types" passed to Nexus makeSchema`;
      }
      const suggestions = suggestionList9(typeName, schemaTypeNames);
      let suggestionsString = "";
      if (suggestions.length > 0) {
        suggestionsString = ` or mean ${suggestions.join(", ")}`;
      }
      return `- Missing type ${typeName}, did you forget to import a type to the root query${suggestionsString}?`;
    }).join("\n");
    throw new Error("\n" + errors);
  }
}
function runAbstractTypeRuntimeChecks(schema3, features) {
  if (features.abstractTypeRuntimeChecks === false) {
    return;
  }
  const abstractTypes = Object.values(schema3.getTypeMap()).filter(isAbstractType);
  abstractTypes.forEach((type) => {
    const kind = isInterfaceType(type) ? "Interface" : "Union";
    const resolveTypeImplemented = type.resolveType !== undefined;
    const typesWithoutIsTypeOf = schema3.getPossibleTypes(type).filter((type2) => type2.isTypeOf === undefined);
    if (resolveTypeImplemented === false && features.abstractTypeStrategies.resolveType === true && features.abstractTypeStrategies.isTypeOf === false) {
      const messagePrefix = `You have a faulty implementation for your ${kind.toLowerCase()} type "${type.name}".`;
      const message = `${messagePrefix} It is missing a \`resolveType\` implementation.`;
      raiseProgrammerError(new Error(message));
    }
    if (typesWithoutIsTypeOf.length > 0 && features.abstractTypeStrategies.isTypeOf === true && features.abstractTypeStrategies.resolveType === false) {
      const messageBadTypes = typesWithoutIsTypeOf.map((t) => `"${t.name}"`).join(", ");
      const messagePrefix = `You have a faulty implementation for your ${kind.toLowerCase()} type "${type.name}".`;
      const messageSuffix = `are missing an \`isTypeOf\` implementation: ${messageBadTypes}`;
      let message;
      if (kind === "Union") {
        message = `${messagePrefix} Some members of union type "${type.name}" ${messageSuffix}`;
      } else if (kind === "Interface") {
        message = `${messagePrefix} Some objects implementing the interface type "${type.name}" ${messageSuffix}`;
      } else {
        casesHandled(kind);
      }
      raiseProgrammerError(new Error(message));
    }
    if ((resolveTypeImplemented === false || typesWithoutIsTypeOf.length > 0) && features.abstractTypeStrategies.isTypeOf === true && features.abstractTypeStrategies.resolveType === true) {
      const messageBadTypes = typesWithoutIsTypeOf.map((t) => `"${t.name}"`).join(", ");
      const messagePrefix = `You have a faulty implementation for your ${kind.toLowerCase()} type "${type.name}". Either implement its \`resolveType\` or implement \`isTypeOf\` on each object`;
      const messageSuffix = `These objects are missing an \`isTypeOf\` implementation: ${messageBadTypes}`;
      let message;
      if (kind === "Union") {
        message = `${messagePrefix} in the union. ${messageSuffix}`;
      } else if (kind === "Interface") {
        message = `${messagePrefix} that implements this interface. ${messageSuffix}`;
      } else {
        casesHandled(kind);
      }
      raiseProgrammerError(new Error(message));
    }
  });
}
function consoleWarn(msg) {
  console.warn(msg);
}
function log(msg) {
  console.log(`Nexus Schema: ${msg}`);
}
function venn(xs, ys) {
  const lefts = new Set(xs);
  const boths = new Set;
  const rights = new Set(ys);
  lefts.forEach((l) => {
    if (rights.has(l)) {
      boths.add(l);
      lefts.delete(l);
      rights.delete(l);
    }
  });
  return [lefts, boths, rights];
}
function pathToArray2(infoPath) {
  const flattened = [];
  let curr = infoPath;
  while (curr) {
    flattened.push(curr.key);
    curr = curr.prev;
  }
  return flattened.reverse();
}
function getOwnPackage() {
  return require_package();
}
function casesHandled(x) {
  throw new Error(`A case was not handled for value: "${x}"`);
}
var isNodeModule = function(path) {
  return !Path2.isAbsolute(path) && /^([A-z0-9@])/.test(path);
};
function resolveImportPath(rootType, typeName, outputPath) {
  const rootTypePath = rootType.module;
  if (typeof rootTypePath !== "string" || !Path2.isAbsolute(rootTypePath) && !isNodeModule(rootTypePath)) {
    throw new Error(`Expected an absolute path or Node package for the root typing path of the type "${typeName}", saw "${rootTypePath}"`);
  }
  if (isNodeModule(rootTypePath)) {
    try {
      require.resolve(rootTypePath);
    } catch (e) {
      throw new Error(`Module "${rootTypePath}" for the type "${typeName}" does not exist`);
    }
  } else if (!fs.existsSync(rootTypePath)) {
    throw new Error(`Root typing path "${rootTypePath}" for the type "${typeName}" does not exist`);
  }
  if (isNodeModule(rootTypePath)) {
    return rootTypePath;
  }
  if (Path2.isAbsolute(rootTypePath)) {
    return relativePathTo(rootTypePath, outputPath);
  }
  return rootTypePath;
}
function getArgNamedType(argDef) {
  let finalValue = argDef;
  if (typeof finalValue === "string") {
    return finalValue;
  }
  while (isNexusWrappingType(finalValue) || isWrappingType(finalValue) || isNexusArgDef(finalValue)) {
    if (isNexusArgDef(finalValue)) {
      finalValue = finalValue.value.type;
    } else if (isNexusWrappingType(finalValue)) {
      finalValue = finalValue.ofNexusType;
    } else if (isWrappingType(finalValue)) {
      finalValue = finalValue.ofType;
    }
  }
  return finalValue;
}
function getNexusNamedType(type) {
  if (typeof type === "string") {
    return type;
  }
  let namedType = type;
  while (isNexusWrappingType(namedType) || isWrappingType(namedType) || isNexusMetaType(namedType)) {
    if (isNexusWrappingType(namedType)) {
      namedType = namedType.ofNexusType;
    }
    if (isWrappingType(namedType)) {
      namedType = namedType.ofType;
    }
    if (isNexusMetaType(namedType)) {
      namedType = resolveNexusMetaType(namedType);
    }
  }
  return namedType;
}
function invariantGuard(val) {
  if (Boolean(val) === false) {
    throw new Error("Nexus Error: This should never happen, please check your code or if you think this is a bug open a GitHub issue https://github.com/graphql-nexus/schema/issues/new.");
  }
}
function isProductionStage() {
  return false;
}
function raiseProgrammerError(error) {
  if (isProductionStage()) {
    throw error;
  } else {
    console.error(error);
  }
}
function graphql15InterfaceConfig(config) {
  return Object.assign(Object.assign({}, config), { interfaces: [] });
}
function graphql15InterfaceType(type) {
  if (typeof type.getInterfaces !== "function") {
    type.getInterfaces = () => [];
  }
  return type;
}
function isArray(arg) {
  return Array.isArray(arg);
}
var isObject = (obj) => obj !== null && typeof obj === "object";
var assertAbsolutePath = (pathName, property) => {
  if (!Path2.isAbsolute(pathName)) {
    throw new Error(`Expected path for "${property}" to be an absolute path, saw "${pathName}"`);
  }
  return pathName;
};
var typeScriptFileExtension = /(\.d)?\.ts$/;

class PrintedGenTypingImport {
  constructor(config) {
    this.config = config;
  }
}
withNexusSymbol(PrintedGenTypingImport, NexusTypes.PrintedGenTypingImport);

class PrintedGenTyping {
  constructor(config) {
    this.config = config;
  }
  get imports() {
    return this.config.imports || [];
  }
  toString() {
    let str = ``;
    if (this.config.description) {
      const descriptionLines = this.config.description.split("\n").map((s) => s.trim()).filter((s) => s).map((s) => ` * ${s}`).join("\n");
      str = `/**\n${descriptionLines}\n */\n`;
    }
    const field = `${this.config.name}${this.config.optional ? "?" : ""}`;
    str += `${field}: ${this.config.type}`;
    return str;
  }
}
withNexusSymbol(PrintedGenTyping, NexusTypes.PrintedGenTyping);
var UNKNOWN_TYPE_SCALAR = decorateType(new GraphQLScalarType({
  name: "NEXUS__UNKNOWN__TYPE",
  description: `
    This scalar should never make it into production. It is used as a placeholder for situations
    where GraphQL Nexus encounters a missing type. We don't want to error immediately, otherwise
    the TypeScript definitions will not be updated.
  `,
  parseValue(value) {
    throw new Error("Error: NEXUS__UNKNOWN__TYPE is not a valid scalar.");
  },
  parseLiteral(value) {
    throw new Error("Error: NEXUS__UNKNOWN__TYPE is not a valid scalar.");
  },
  serialize(value) {
    throw new Error("Error: NEXUS__UNKNOWN__TYPE is not a valid scalar.");
  }
}), {
  sourceType: "never"
});

class Unreachable extends Error {
  constructor(val) {
    super(`Unreachable case or branch, unexpected ${val}`);
  }
}
var ownProp = {
  has(obj, key) {
    return Boolean(Object.getOwnPropertyDescriptor(obj, key));
  },
  set(obj, key, value) {
    Object.defineProperty(obj, key, { value });
    return value;
  },
  get(obj, key) {
    var _a;
    return (_a = Object.getOwnPropertyDescriptor(obj, key)) === null || _a === undefined ? undefined : _a.value;
  }
};

// node_modules/nexus/dist-esm/definitions/args.js
function arg(config) {
  if (!config.type) {
    throw new Error('You must provide a "type" for the arg()');
  }
  return new NexusArgDef(typeof config.type === "string" ? config.type : config.type.name, config);
}
function stringArg(config) {
  return arg(Object.assign({ type: "String" }, config));
}
function intArg(config) {
  return arg(Object.assign({ type: "Int" }, config));
}
class NexusArgDef {
  constructor(name, config) {
    this.name = name;
    this.config = config;
  }
  get value() {
    return this.config;
  }
}
withNexusSymbol(NexusArgDef, NexusTypes.Arg);

// node_modules/nexus/dist-esm/definitions/list.js
function list(type) {
  return new NexusListDef(type);
}

class NexusListDef {
  constructor(ofNexusType) {
    this.ofNexusType = ofNexusType;
    this._isNexusListDef = true;
    if (typeof ofNexusType !== "string" && !isNexusStruct(ofNexusType) && !isNexusMeta(ofNexusType) && !isType(ofNexusType)) {
      throw new Error("Cannot wrap unknown types in list(). Saw " + ofNexusType);
    }
  }
}
withNexusSymbol(NexusListDef, NexusTypes.List);

// node_modules/nexus/dist-esm/definitions/nonNull.js
function nonNull(type) {
  if (isNexusNonNullTypeDef(type) || isNonNullType(type)) {
    return type;
  }
  if (isNexusNullTypeDef(type)) {
    return new NexusNonNullDef(type.ofNexusType);
  }
  return new NexusNonNullDef(type);
}

class NexusNonNullDef {
  constructor(ofNexusType) {
    this.ofNexusType = ofNexusType;
    this._isNexusNonNullDef = true;
    if (typeof ofNexusType !== "string" && !isNexusStruct(ofNexusType) && !isNexusMeta(ofNexusType) && !isType(ofNexusType)) {
      throw new Error("Cannot wrap unknown types in a nonNull(). Saw " + ofNexusType);
    }
  }
}
withNexusSymbol(NexusNonNullDef, NexusTypes.NonNull);

// node_modules/nexus/dist-esm/definitions/nullable.js
function nullable(type) {
  if (isNexusNonNullTypeDef(type)) {
    return new NexusNullDef(type.ofNexusType);
  }
  if (isNexusNullTypeDef(type)) {
    return type;
  }
  return new NexusNullDef(type);
}

class NexusNullDef {
  constructor(ofNexusType) {
    this.ofNexusType = ofNexusType;
    this._isNexusNullDef = true;
    if (typeof ofNexusType !== "string" && !isNexusStruct(ofNexusType) && !isNexusMeta(ofNexusType) && !isType(ofNexusType)) {
      throw new Error("Cannot wrap unknown types in nullable(). Saw " + ofNexusType);
    }
  }
}
withNexusSymbol(NexusNullDef, NexusTypes.Null);

// node_modules/nexus/dist-esm/definitions/wrapping.js
function isNexusStruct(obj) {
  return obj && Boolean(obj[NexusWrappedSymbol]);
}
function isNexusNamedTypeDef(obj) {
  return isNexusStruct(obj) && NamedTypeDefs.has(obj[NexusWrappedSymbol]) && ("name" in obj);
}
function isNexusListTypeDef(obj) {
  return isNexusStruct(obj) && obj[NexusWrappedSymbol] === NexusTypes.List;
}
function isNexusNonNullTypeDef(obj) {
  return isNexusStruct(obj) && obj[NexusWrappedSymbol] === NexusTypes.NonNull;
}
function isNexusNullTypeDef(obj) {
  return isNexusStruct(obj) && obj[NexusWrappedSymbol] === NexusTypes.Null;
}
function isNexusWrappingType(obj) {
  return isNexusListTypeDef(obj) || isNexusNullTypeDef(obj) || isNexusNonNullTypeDef(obj);
}
function isNexusExtendInputTypeDef(obj) {
  return isNexusStruct(obj) && obj[NexusWrappedSymbol] === NexusTypes.ExtendInputObject;
}
function isNexusExtendTypeDef(obj) {
  return isNexusStruct(obj) && obj[NexusWrappedSymbol] === NexusTypes.ExtendObject;
}
function isNexusEnumTypeDef(obj) {
  return isNexusStruct(obj) && obj[NexusWrappedSymbol] === NexusTypes.Enum;
}
function isNexusInputObjectTypeDef(obj) {
  return isNexusStruct(obj) && obj[NexusWrappedSymbol] === NexusTypes.InputObject;
}
function isNexusObjectTypeDef(obj) {
  return isNexusStruct(obj) && obj[NexusWrappedSymbol] === NexusTypes.Object;
}
function isNexusScalarTypeDef(obj) {
  return isNexusStruct(obj) && obj[NexusWrappedSymbol] === NexusTypes.Scalar;
}
function isNexusUnionTypeDef(obj) {
  return isNexusStruct(obj) && obj[NexusWrappedSymbol] === NexusTypes.Union;
}
function isNexusInterfaceTypeDef(obj) {
  return isNexusStruct(obj) && obj[NexusWrappedSymbol] === NexusTypes.Interface;
}
function isNexusArgDef(obj) {
  return isNexusStruct(obj) && obj[NexusWrappedSymbol] === NexusTypes.Arg;
}
function isNexusNamedOuputTypeDef(obj) {
  return isNexusNamedTypeDef(obj) && !isNexusInputObjectTypeDef(obj);
}
function isNexusNamedInputTypeDef(obj) {
  return isNexusNamedTypeDef(obj) && !isNexusObjectTypeDef(obj) && !isNexusInterfaceTypeDef(obj);
}
function isNexusDynamicOutputProperty(obj) {
  return isNexusStruct(obj) && obj[NexusWrappedSymbol] === NexusTypes.DynamicOutputProperty;
}
function isNexusDynamicOutputMethod(obj) {
  return isNexusStruct(obj) && obj[NexusWrappedSymbol] === NexusTypes.DynamicOutputMethod;
}
function isNexusDynamicInputMethod(obj) {
  return isNexusStruct(obj) && obj[NexusWrappedSymbol] === NexusTypes.DynamicInput;
}
function isNexusPrintedGenTyping(obj) {
  return isNexusStruct(obj) && obj[NexusWrappedSymbol] === NexusTypes.PrintedGenTyping;
}
function isNexusPrintedGenTypingImport(obj) {
  return isNexusStruct(obj) && obj[NexusWrappedSymbol] === NexusTypes.PrintedGenTypingImport;
}
function isNexusPlugin(obj) {
  return isNexusStruct(obj) && obj[NexusWrappedSymbol] === NexusTypes.Plugin;
}
function unwrapGraphQLDef(typeDef) {
  const wrapping6 = [];
  let namedType = typeDef;
  while (isWrappingType(namedType)) {
    if (isListType(namedType)) {
      wrapping6.unshift("List");
    } else if (isNonNullType(namedType)) {
      wrapping6.unshift("NonNull");
    } else {
      throw new Unreachable(namedType);
    }
    namedType = namedType.ofType;
  }
  return { namedType, wrapping: wrapping6 };
}
function unwrapNexusDef(typeDef) {
  const wrapping6 = [];
  let namedType = typeDef;
  while (isNexusWrappingType(namedType) || isWrappingType(namedType) || isNexusMetaType(namedType)) {
    if (isNexusMetaType(namedType)) {
      namedType = resolveNexusMetaType(namedType);
    } else if (isWrappingType(namedType)) {
      if (isListType(namedType)) {
        wrapping6.unshift("List");
      } else if (isNonNullType(namedType)) {
        wrapping6.unshift("NonNull");
      } else {
        throw new Unreachable(namedType);
      }
      namedType = namedType.ofType;
    } else {
      if (isNexusNonNullTypeDef(namedType)) {
        wrapping6.unshift("NonNull");
      }
      if (isNexusNullTypeDef(namedType)) {
        wrapping6.unshift("Null");
      }
      if (isNexusListTypeDef(namedType)) {
        wrapping6.unshift("List");
      }
      namedType = namedType.ofNexusType;
    }
  }
  return { namedType, wrapping: wrapping6 };
}
function rewrapAsGraphQLType(baseType, wrapping6) {
  let finalType = baseType;
  wrapping6.forEach((wrap2) => {
    if (wrap2 === "List") {
      finalType = new GraphQLList(finalType);
    } else if (wrap2 === "NonNull") {
      if (!isNonNullType(finalType)) {
        finalType = new GraphQLNonNull(finalType);
      }
    } else {
      throw new Unreachable(wrap2);
    }
  });
  return finalType;
}
function normalizeArgWrapping(argVal) {
  if (isNexusArgDef(argVal)) {
    return argVal;
  }
  if (isNexusWrappingType(argVal)) {
    let { namedType, wrapping: wrapping6 } = unwrapNexusDef(argVal);
    if (isNexusArgDef(namedType)) {
      const config = namedType.value;
      return arg(Object.assign(Object.assign({}, config), { type: applyNexusWrapping(config.type, wrapping6) }));
    }
    return arg({ type: applyNexusWrapping(namedType, wrapping6) });
  }
  return arg({ type: argVal });
}
function applyNexusWrapping(toWrap, wrapping6) {
  let finalType = toWrap;
  wrapping6.forEach((wrap2) => {
    if (wrap2 === "List") {
      finalType = list(finalType);
    } else if (wrap2 === "NonNull") {
      finalType = nonNull(finalType);
    } else if (wrap2 === "Null") {
      finalType = nullable(finalType);
    } else {
      throw new Unreachable(wrap2);
    }
  });
  return finalType;
}
function finalizeWrapping(nonNullDefault, typeWrapping, chainWrapping) {
  let finalChain = [];
  const allWrapping = typeWrapping.concat(chainWrapping !== null && chainWrapping !== undefined ? chainWrapping : []);
  if (nonNullDefault && (!allWrapping[0] || allWrapping[0] === "List")) {
    allWrapping.unshift("NonNull");
  }
  for (let i = 0;i < allWrapping.length; i++) {
    const current = allWrapping[i];
    const next = allWrapping[i + 1];
    if (current === "Null") {
      continue;
    } else if (current === "NonNull") {
      finalChain.push("NonNull");
    } else if (current === "List") {
      finalChain.push("List");
      if (nonNullDefault && (next === "List" || !next)) {
        finalChain.push("NonNull");
      }
    }
  }
  return finalChain;
}
var NamedTypeDefs = new Set([
  NexusTypes.Enum,
  NexusTypes.Object,
  NexusTypes.Scalar,
  NexusTypes.Union,
  NexusTypes.Interface,
  NexusTypes.InputObject
]);

// node_modules/nexus/dist-esm/extensions.js
function hasNexusExtension(val) {
  return Boolean(val);
}

class NexusFieldExtension {
  constructor(config) {
    const { resolve } = config, rest = __rest(config, ["resolve"]);
    this.config = rest;
    this.hasDefinedResolver = Boolean(resolve && resolve !== defaultFieldResolver);
  }
  modify(modifications) {
    return new NexusFieldExtension(Object.assign(Object.assign({}, this.config), modifications));
  }
}

class NexusInputObjectTypeExtension {
  constructor(config) {
    const { definition: definition28 } = config, rest = __rest(config, ["definition"]);
    this.config = rest;
  }
}

class NexusObjectTypeExtension {
  constructor(config) {
    const { definition: definition28 } = config, rest = __rest(config, ["definition"]);
    this.config = rest;
  }
}

class NexusInterfaceTypeExtension {
  constructor(config) {
    const { definition: definition28 } = config, rest = __rest(config, ["definition"]);
    this.config = rest;
  }
}

class NexusSchemaExtension {
  constructor(config) {
    this.config = config;
  }
}

// node_modules/nexus/dist-esm/plugin.js
function completeValue(valOrPromise, onSuccess, onError) {
  if (isPromiseLike(valOrPromise)) {
    return valOrPromise.then(onSuccess, onError);
  }
  const result = onSuccess(valOrPromise);
  if (isPromiseLike(result)) {
    return result.then((o) => o);
  }
  return result;
}
function composeMiddlewareFns(middlewareFns, resolver) {
  let lastResolver = resolver;
  for (const middleware of middlewareFns.reverse()) {
    const currentNext = middleware;
    const previousNext = lastResolver;
    lastResolver = (root, args2, ctx, info) => {
      return currentNext(root, args2, ctx, info, previousNext);
    };
  }
  return lastResolver;
}
function plugin(config) {
  validatePluginConfig(config);
  return new NexusPlugin(config);
}
var validatePluginConfig = function(pluginConfig) {
  const validRequiredProps = ["name"];
  const optionalPropFns = [
    "onInstall",
    "onCreateFieldResolver",
    "onCreateFieldSubscribe",
    "onBeforeBuild",
    "onMissingType",
    "onAfterBuild",
    "onObjectDefinition",
    "onAddOutputField",
    "onAddInputField",
    "onAddArg",
    "onInputObjectDefinition"
  ];
  const validOptionalProps = [
    "description",
    "fieldDefTypes",
    "inputFieldDefTypes",
    "objectTypeDefTypes",
    "inputObjectTypeDefTypes",
    "argTypeDefTypes",
    ...optionalPropFns
  ];
  const validProps = [...validRequiredProps, ...validOptionalProps];
  const givenProps = Object.keys(pluginConfig);
  const printProps = (props) => {
    return [...props].join(", ");
  };
  const [missingRequiredProps, ,] = venn(validRequiredProps, givenProps);
  if (missingRequiredProps.size > 0) {
    throw new Error(`Plugin "${pluginConfig.name}" is missing required properties: ${printProps(missingRequiredProps)}`);
  }
  const nameType = typeof pluginConfig.name;
  if (nameType !== "string") {
    throw new Error(`Plugin "${pluginConfig.name}" is giving an invalid value for property name: expected "string" type, got ${nameType} type`);
  }
  if (pluginConfig.name === "") {
    throw new Error(`Plugin "${pluginConfig.name}" is giving an invalid value for property name: empty string`);
  }
  const [, , invalidGivenProps] = venn(validProps, givenProps);
  if (invalidGivenProps.size > 0) {
    console.error(new Error(`Plugin "${pluginConfig.name}" is giving unexpected properties: ${printProps(invalidGivenProps)}`));
  }
  optionalPropFns.forEach((fnName) => {
    const fnType = typeof pluginConfig[fnName];
    if (fnType !== "function" && fnType !== "undefined") {
      console.error(new Error(`Plugin "${pluginConfig.name}" is giving an invalid value for ${fnName} hook: expected "function" type, got ${fnType} type`));
    }
  });
};

class NexusPlugin {
  constructor(config) {
    this.config = config;
  }
}
withNexusSymbol(NexusPlugin, NexusTypes.Plugin);
plugin.completeValue = completeValue;

// node_modules/nexus/dist-esm/dynamicMethod.js
function dynamicOutputMethod(config) {
  return new DynamicOutputMethodDef(config.name, config);
}
class DynamicInputMethodDef {
  constructor(name, config) {
    this.name = name;
    this.config = config;
  }
  get value() {
    return this.config;
  }
}
withNexusSymbol(DynamicInputMethodDef, NexusTypes.DynamicInput);

class DynamicOutputMethodDef {
  constructor(name, config) {
    this.name = name;
    this.config = config;
  }
  get value() {
    return this.config;
  }
}
withNexusSymbol(DynamicOutputMethodDef, NexusTypes.DynamicOutputMethod);

// node_modules/nexus/dist-esm/plugins/connectionPlugin.js
var base64Encode = function(str) {
  return Buffer.from(str, "utf8").toString("base64");
};
var base64Decode = function(str) {
  return Buffer.from(str, "base64").toString("utf8");
};
var nonConnectionFieldProps = function(fieldConfig) {
  const { additionalArgs, cursorFromNode, disableBackwardPagination, disableForwardPagination, extendConnection, extendEdge, inheritAdditionalArgs, nodes, pageInfoFromNodes, resolve, type, validateArgs, strictArgs, nullable: nullable4 } = fieldConfig, rest = __rest(fieldConfig, ["additionalArgs", "cursorFromNode", "disableBackwardPagination", "disableForwardPagination", "extendConnection", "extendEdge", "inheritAdditionalArgs", "nodes", "pageInfoFromNodes", "resolve", "type", "validateArgs", "strictArgs", "nullable"]);
  return rest;
};
function makeResolveFn(pluginConfig, fieldConfig) {
  const mergedConfig = Object.assign(Object.assign({}, pluginConfig), fieldConfig);
  return (root, args3, ctx, info) => {
    const { nodes: nodesResolve } = fieldConfig;
    const { decodeCursor = base64Decode, encodeCursor = base64Encode } = pluginConfig;
    const { pageInfoFromNodes = defaultPageInfoFromNodes, cursorFromNode = defaultCursorFromNode } = mergedConfig;
    if (!nodesResolve) {
      return null;
    }
    const formattedArgs = Object.assign({}, args3);
    if (args3.before) {
      formattedArgs.before = decodeCursor(args3.before).replace(CURSOR_PREFIX, "");
    }
    if (args3.after) {
      formattedArgs.after = decodeCursor(args3.after).replace(CURSOR_PREFIX, "");
    }
    if (args3.last && !args3.before && cursorFromNode === defaultCursorFromNode) {
      throw new Error(`Cannot paginate backward without a "before" cursor by default.`);
    }
    let cachedNodes;
    let cachedEdges;
    let hasPromise = false;
    const resolveAllNodes = () => {
      var _a;
      if (cachedNodes !== undefined) {
        return cachedNodes;
      }
      cachedNodes = completeValue((_a = nodesResolve(root, formattedArgs, ctx, info)) !== null && _a !== undefined ? _a : null, (allNodes) => {
        return allNodes ? Array.from(allNodes) : allNodes;
      });
      return cachedNodes;
    };
    const resolveEdgesAndNodes = () => {
      if (cachedEdges !== undefined) {
        return cachedEdges;
      }
      cachedEdges = completeValue(resolveAllNodes(), (allNodes) => {
        if (!allNodes) {
          const arrPath = JSON.stringify(pathToArray2(info.path));
          console.warn(`You resolved null/undefined from nodes() at path ${arrPath}, this is likely an error. Return an empty array to suppress this warning.`);
          return { edges: [], nodes: [] };
        }
        const resolvedEdgeList = [];
        const resolvedNodeList = [];
        iterateNodes(allNodes, args3, (maybeNode, i) => {
          if (isPromiseLike(maybeNode)) {
            hasPromise = true;
            resolvedNodeList.push(maybeNode);
            resolvedEdgeList.push(maybeNode.then((node) => {
              return completeValue(cursorFromNode(maybeNode, formattedArgs, ctx, info, {
                index: i,
                nodes: allNodes
              }), (rawCursor) => wrapEdge(pluginConfig, fieldConfig, formattedArgs, {
                cursor: encodeCursor(rawCursor),
                node
              }));
            }));
          } else {
            resolvedNodeList.push(maybeNode);
            resolvedEdgeList.push(wrapEdge(pluginConfig, fieldConfig, formattedArgs, {
              node: maybeNode,
              cursor: completeValue(cursorFromNode(maybeNode, formattedArgs, ctx, info, {
                index: i,
                nodes: allNodes
              }), (rawCursor) => encodeCursor(rawCursor))
            }));
          }
        });
        if (hasPromise) {
          return Promise.all([Promise.all(resolvedEdgeList), Promise.all(resolvedNodeList)]).then(([edges, nodes]) => ({ edges, nodes }));
        }
        return {
          nodes: resolvedNodeList,
          edges: resolvedEdgeList
        };
      });
      return cachedEdges;
    };
    const resolvePageInfo = () => {
      return completeValue(resolveAllNodes(), (allNodes) => completeValue(resolveEdgesAndNodes(), ({ edges }) => completeValue(allNodes ? pageInfoFromNodes(allNodes, args3, ctx, info) : {
        hasNextPage: false,
        hasPreviousPage: false
      }, (basePageInfo) => {
        var _a, _b, _c;
        return Object.assign(Object.assign({}, basePageInfo), { startCursor: ((_a = edges === null || edges === undefined ? undefined : edges[0]) === null || _a === undefined ? undefined : _a.cursor) ? edges[0].cursor : null, endCursor: (_c = (_b = edges === null || edges === undefined ? undefined : edges[edges.length - 1]) === null || _b === undefined ? undefined : _b.cursor) !== null && _c !== undefined ? _c : null });
      })));
    };
    const connectionResult = withSource(root, formattedArgs, {
      get nodes() {
        return completeValue(resolveEdgesAndNodes(), (o) => o.nodes);
      },
      get edges() {
        return completeValue(resolveEdgesAndNodes(), (o) => o.edges);
      },
      get pageInfo() {
        return resolvePageInfo();
      }
    });
    if (pluginConfig.extendConnection) {
      Object.keys(pluginConfig.extendConnection).forEach((connectionField) => {
        var _a;
        const resolve = (_a = fieldConfig[connectionField]) !== null && _a !== undefined ? _a : defaultFieldResolver;
        Object.defineProperty(connectionResult, connectionField, {
          value: (args4, ctx2, info2) => {
            return resolve(root, Object.assign(Object.assign({}, formattedArgs), args4), ctx2, info2);
          }
        });
      });
    }
    return connectionResult;
  };
}
var wrapEdge = function(pluginConfig, fieldConfig, formattedArgs, edgeParentType) {
  const edge = withArgs(formattedArgs, edgeParentType);
  if (pluginConfig.extendEdge) {
    Object.keys(pluginConfig.extendEdge).forEach((edgeField) => {
      var _a, _b;
      const resolve = (_b = (_a = fieldConfig.edgeFields) === null || _a === undefined ? undefined : _a[edgeField]) !== null && _b !== undefined ? _b : defaultFieldResolver;
      Object.defineProperty(edge, edgeField, {
        value: (args3, ctx, info) => {
          return resolve(edge, Object.assign(Object.assign({}, formattedArgs), args3), ctx, info);
        }
      });
    });
  }
  return edge;
};
var withArgs = function(args3, connectionParentType) {
  Object.defineProperty(connectionParentType, "__connectionArgs", {
    value: args3,
    enumerable: false
  });
  return connectionParentType;
};
var withSource = function(source2, args3, connectionParentType) {
  Object.defineProperty(connectionParentType, "__connectionSource", {
    value: source2,
    enumerable: false
  });
  return withArgs(args3, connectionParentType);
};
var mergeArgs = function(obj, fieldArgs) {
  return Object.assign(Object.assign({}, obj.__connectionArgs), fieldArgs);
};
var provideArgs = function(block2, fn) {
  const fieldDef = block2.field;
  block2.field = function(...args3) {
    let config = args3.length === 2 ? Object.assign({ name: args3[0] }, args3[1]) : args3[0];
    const { resolve = defaultFieldResolver } = config;
    fieldDef.call(this, Object.assign(Object.assign({}, config), { resolve(root, args4, ctx, info) {
      return resolve(root, mergeArgs(root, args4), ctx, info);
    } }));
  };
  fn();
  block2.field = fieldDef;
};
var provideSourceAndArgs = function(block2, fn) {
  const fieldDef = block2.field;
  block2.field = function(...args3) {
    let config = args3.length === 2 ? Object.assign({ name: args3[0] }, args3[1]) : args3[0];
    const { resolve = defaultFieldResolver } = config;
    fieldDef.call(this, Object.assign(Object.assign({}, config), { resolve(root, args4, ctx, info) {
      return resolve(root.__connectionSource, mergeArgs(root, args4), ctx, info);
    } }));
  };
  fn();
  block2.field = fieldDef;
};
var iterateNodes = function(nodes, args3, cb) {
  if (typeof args3.first === "number") {
    const len = Math.min(args3.first, nodes.length);
    for (let i = 0;i < len; i++) {
      cb(nodes[i], i);
    }
  } else if (typeof args3.last === "number") {
    const len = Math.min(args3.last, nodes.length);
    for (let i = 0;i < len; i++) {
      cb(nodes[i], i);
    }
  } else {
    for (let i = 0;i < nodes.length; i++) {
      cb(nodes[i], i);
    }
  }
};
var defaultPageInfoFromNodes = function(nodes, args3) {
  return {
    hasNextPage: defaultHasNextPage(nodes, args3),
    hasPreviousPage: defaultHasPreviousPage(nodes, args3)
  };
};
var defaultHasNextPage = function(nodes, args3) {
  if (typeof args3.first === "number") {
    return nodes.length > args3.first;
  }
  if (typeof args3.last === "number") {
    if (args3.before && args3.before !== "0") {
      return true;
    }
    return false;
  }
  throw new Error("Unreachable");
};
var defaultHasPreviousPage = function(nodes, args3) {
  if (typeof args3.first === "number") {
    if (args3.after && args3.after !== "0") {
      return true;
    }
    return false;
  }
  if (typeof args3.last === "number") {
    return nodes.length >= args3.last;
  }
  throw new Error("Unreachable");
};
var defaultCursorFromNode = function(node, args3, ctx, info, { index, nodes }) {
  let cursorIndex = index;
  if (typeof args3.first === "number") {
    if (args3.after) {
      const offset = parseInt(args3.after, 10);
      cursorIndex = offset + index + 1;
    }
  }
  if (typeof args3.last === "number") {
    if (args3.before) {
      const offset = parseInt(args3.before, 10);
      const len = Math.min(nodes.length, args3.last);
      cursorIndex = offset - len + index;
    } else {
      throw new Error("Unreachable");
    }
  }
  return `${CURSOR_PREFIX}${cursorIndex}`;
};
var defaultValidateArgs = function(args3 = {}, info) {
  if (!(args3.first || args3.first === 0) && !(args3.last || args3.last === 0)) {
    throw new Error(`The ${info.parentType}.${info.fieldName} connection field requires a "first" or "last" argument`);
  }
  if (args3.first && args3.last) {
    throw new Error(`The ${info.parentType}.${info.fieldName} connection field requires a "first" or "last" argument, not both`);
  }
  if (args3.first && args3.before) {
    throw new Error(`The ${info.parentType}.${info.fieldName} connection field does not allow a "before" argument with "first"`);
  }
  if (args3.last && args3.after) {
    throw new Error(`The ${info.parentType}.${info.fieldName} connection field does not allow a "last" argument with "after"`);
  }
};
var ForwardPaginateArgs = {
  first: nullable(intArg({ description: "Returns the first n elements from the list." })),
  after: nullable(stringArg({ description: "Returns the elements in the list that come after the specified cursor" }))
};
var ForwardOnlyStrictArgs = Object.assign(Object.assign({}, ForwardPaginateArgs), { first: nonNull(intArg({ description: "Returns the first n elements from the list." })) });
var BackwardPaginateArgs = {
  last: nullable(intArg({ description: "Returns the last n elements from the list." })),
  before: nullable(stringArg({ description: "Returns the elements in the list that come before the specified cursor" }))
};
var BackwardOnlyStrictArgs = Object.assign(Object.assign({}, BackwardPaginateArgs), { last: nonNull(intArg({ description: "Returns the last n elements from the list." })) });
var connectionPlugin = (connectionPluginConfig) => {
  var _a;
  const pluginConfig = Object.assign({}, connectionPluginConfig);
  return plugin({
    name: "ConnectionPlugin",
    fieldDefTypes: [
      printedGenTypingImport({
        module: (_a = connectionPluginConfig === null || connectionPluginConfig === undefined ? undefined : connectionPluginConfig.nexusSchemaImportId) !== null && _a !== undefined ? _a : getOwnPackage().name,
        bindings: ["core", "connectionPluginCore"]
      })
    ],
    onInstall(b) {
      let dynamicConfig = [];
      const { additionalArgs = {}, extendConnection: pluginExtendConnection, extendEdge: pluginExtendEdge, includeNodesField = false, nexusFieldName = "connectionField" } = pluginConfig;
      if (pluginExtendConnection) {
        eachObj(pluginExtendConnection, (val, key) => {
          dynamicConfig.push(`${key}${val.requireResolver === false ? "?:" : ":"} connectionPluginCore.ConnectionFieldResolver<TypeName, FieldName, "${key}">`);
        });
      }
      if (pluginExtendEdge) {
        const edgeFields = mapObj(pluginExtendEdge, (val, key) => `${key}${val.requireResolver === false ? "?:" : ":"} connectionPluginCore.EdgeFieldResolver<TypeName, FieldName, "${key}">`);
        dynamicConfig.push(`edgeFields: { ${edgeFields.join(", ")} }`);
      }
      let printedDynamicConfig = "";
      if (dynamicConfig.length > 0) {
        printedDynamicConfig = ` & { ${dynamicConfig.join(", ")} }`;
      }
      b.addType(dynamicOutputMethod({
        name: nexusFieldName,
        typeDescription: `
            Adds a Relay-style connection to the type, with numerous options for configuration

            @see https://nexusjs.org/docs/plugins/connection
          `,
        typeDefinition: `<FieldName extends string>(
      fieldName: FieldName,
      config: connectionPluginCore.ConnectionFieldConfig<TypeName, FieldName>${printedDynamicConfig}
    ): void`,
        factory({ typeName: parentTypeName, typeDef: t, args: factoryArgs, stage, builder, wrapping: wrapping7 }) {
          var _a2, _b;
          const [fieldName, fieldConfig] = factoryArgs;
          const targetType = fieldConfig.type;
          if (wrapping7 === null || wrapping7 === undefined ? undefined : wrapping7.includes("List")) {
            throw new Error(`Cannot chain .list with connectionField (on ${parentTypeName}.${fieldName})`);
          }
          const { targetTypeName, connectionName, edgeName } = getTypeNames(fieldName, parentTypeName, fieldConfig, pluginConfig);
          if (stage === "build") {
            assertCorrectConfig(parentTypeName, fieldName, pluginConfig, fieldConfig);
          }
          if (!b.hasType(connectionName)) {
            b.addType(objectType({
              name: connectionName,
              definition(t2) {
                t2.list.field("edges", {
                  type: edgeName,
                  description: `https://facebook.github.io/relay/graphql/connections.htm#sec-Edge-Types`
                });
                t2.nonNull.field("pageInfo", {
                  type: "PageInfo",
                  description: `https://facebook.github.io/relay/graphql/connections.htm#sec-undefined.PageInfo`
                });
                if (includeNodesField) {
                  t2.list.field("nodes", {
                    type: targetType,
                    description: `Flattened list of ${targetTypeName} type`
                  });
                }
                if (pluginExtendConnection) {
                  eachObj(pluginExtendConnection, (extensionFieldConfig, extensionFieldName) => {
                    t2.field(extensionFieldName, extensionFieldConfig);
                  });
                }
                provideSourceAndArgs(t2, () => {
                  if (fieldConfig.extendConnection instanceof Function) {
                    fieldConfig.extendConnection(t2);
                  }
                });
              },
              nonNullDefaults: (_a2 = fieldConfig.nonNullDefaults) !== null && _a2 !== undefined ? _a2 : pluginConfig.nonNullDefaults
            }));
          }
          if (!b.hasType(edgeName)) {
            b.addType(objectType({
              name: edgeName,
              definition(t2) {
                t2.field("cursor", {
                  type: cursorType !== null && cursorType !== undefined ? cursorType : nonNull("String"),
                  description: "https://facebook.github.io/relay/graphql/connections.htm#sec-Cursor"
                });
                t2.field("node", {
                  type: targetType,
                  description: "https://facebook.github.io/relay/graphql/connections.htm#sec-Node"
                });
                if (pluginExtendEdge) {
                  eachObj(pluginExtendEdge, (val, key) => {
                    t2.field(key, val);
                  });
                }
                provideArgs(t2, () => {
                  if (fieldConfig.extendEdge instanceof Function) {
                    fieldConfig.extendEdge(t2);
                  }
                });
              },
              nonNullDefaults: (_b = fieldConfig.nonNullDefaults) !== null && _b !== undefined ? _b : pluginConfig.nonNullDefaults
            }));
          }
          if (!b.hasType("PageInfo")) {
            b.addType(objectType({
              name: "PageInfo",
              description: "PageInfo cursor, as defined in https://facebook.github.io/relay/graphql/connections.htm#sec-undefined.PageInfo",
              definition(t2) {
                t2.nonNull.field("hasNextPage", {
                  type: "Boolean",
                  description: `Used to indicate whether more edges exist following the set defined by the clients arguments.`
                });
                t2.nonNull.field("hasPreviousPage", {
                  type: "Boolean",
                  description: `Used to indicate whether more edges exist prior to the set defined by the clients arguments.`
                });
                t2.nullable.field("startCursor", {
                  type: "String",
                  description: `The cursor corresponding to the first nodes in edges. Null if the connection is empty.`
                });
                t2.nullable.field("endCursor", {
                  type: "String",
                  description: `The cursor corresponding to the last nodes in edges. Null if the connection is empty.`
                });
              }
            }));
          }
          const { disableBackwardPagination, disableForwardPagination, validateArgs = defaultValidateArgs, strictArgs = true, cursorType } = Object.assign(Object.assign({}, pluginConfig), fieldConfig);
          let specArgs = {};
          if (disableForwardPagination !== true && disableBackwardPagination !== true) {
            specArgs = Object.assign(Object.assign({}, ForwardPaginateArgs), BackwardPaginateArgs);
          } else if (disableForwardPagination !== true) {
            specArgs = strictArgs ? Object.assign({}, ForwardOnlyStrictArgs) : Object.assign({}, ForwardPaginateArgs);
          } else if (disableBackwardPagination !== true) {
            specArgs = strictArgs ? Object.assign({}, BackwardOnlyStrictArgs) : Object.assign({}, BackwardPaginateArgs);
          }
          let fieldAdditionalArgs = {};
          if (fieldConfig.additionalArgs) {
            if (additionalArgs && fieldConfig.inheritAdditionalArgs) {
              fieldAdditionalArgs = Object.assign(Object.assign({}, additionalArgs), fieldConfig.additionalArgs);
            } else {
              fieldAdditionalArgs = Object.assign({}, fieldConfig.additionalArgs);
            }
          } else if (additionalArgs) {
            fieldAdditionalArgs = Object.assign({}, additionalArgs);
          }
          const fieldArgs = Object.assign(Object.assign({}, fieldAdditionalArgs), specArgs);
          let resolveFn;
          if (fieldConfig.resolve) {
            if (includeNodesField) {
              resolveFn = (root, args3, ctx, info) => {
                return completeValue(fieldConfig.resolve(root, args3, ctx, info), (val) => {
                  if (val && val.nodes === undefined) {
                    return withArgs(args3, Object.assign({ get nodes() {
                      return completeValue(val.edges, (edges) => edges.map((edge) => edge.node));
                    } }, val));
                  }
                  return withArgs(args3, Object.assign({}, val));
                });
              };
            } else {
              resolveFn = fieldConfig.resolve;
            }
          } else {
            resolveFn = makeResolveFn(pluginConfig, fieldConfig);
          }
          let wrappedConnectionName = connectionName;
          if (wrapping7) {
            if (typeof fieldConfig.nullable === "boolean") {
              throw new Error("[connectionPlugin]: You cannot chain .null/.nonNull and also set the nullable in the connectionField definition.");
            }
            wrappedConnectionName = applyNexusWrapping(connectionName, wrapping7);
          } else {
            if (fieldConfig.nullable === true) {
              wrappedConnectionName = nullable(wrappedConnectionName);
            } else if (fieldConfig.nullable === false) {
              wrappedConnectionName = nonNull(wrappedConnectionName);
            }
          }
          t.field(fieldName, Object.assign(Object.assign({}, nonConnectionFieldProps(fieldConfig)), { args: fieldArgs, type: wrappedConnectionName, resolve(root, args3, ctx, info) {
            validateArgs(args3, info, root, ctx);
            return resolveFn(root, args3, ctx, info);
          } }));
        }
      }));
    }
  });
};
var CURSOR_PREFIX = "cursor:";
var getTypeNames = (fieldName, parentTypeName, fieldConfig, pluginConfig) => {
  const targetTypeName = typeof fieldConfig.type === "string" ? fieldConfig.type : fieldConfig.type.name;
  let connectionName;
  if (fieldConfig.getConnectionName) {
    connectionName = fieldConfig.getConnectionName(fieldName, parentTypeName);
  } else if (pluginConfig.getConnectionName) {
    connectionName = pluginConfig.getConnectionName(fieldName, parentTypeName);
  } else if (isConnectionFieldExtended(fieldConfig)) {
    connectionName = `${parentTypeName}${upperFirst(fieldName)}_Connection`;
  } else {
    connectionName = `${pluginConfig.typePrefix || ""}${targetTypeName}Connection`;
  }
  let edgeName;
  if (fieldConfig.getEdgeName) {
    edgeName = fieldConfig.getEdgeName(fieldName, parentTypeName);
  } else if (pluginConfig.getEdgeName) {
    edgeName = pluginConfig.getEdgeName(fieldName, parentTypeName);
  } else if (isEdgeFieldExtended(fieldConfig)) {
    edgeName = `${parentTypeName}${upperFirst(fieldName)}_Edge`;
  } else {
    edgeName = `${pluginConfig.typePrefix || ""}${targetTypeName}Edge`;
  }
  return {
    edgeName,
    targetTypeName,
    connectionName
  };
};
var isConnectionFieldExtended = (fieldConfig) => {
  if (fieldConfig.extendConnection || isEdgeFieldExtended(fieldConfig)) {
    return true;
  }
  return false;
};
var isEdgeFieldExtended = (fieldConfig) => {
  if (fieldConfig.extendEdge || fieldConfig.cursorType) {
    return true;
  }
  return false;
};
var upperFirst = (fieldName) => {
  return fieldName.slice(0, 1).toUpperCase().concat(fieldName.slice(1));
};
var assertCorrectConfig = (typeName, fieldName, pluginConfig, fieldConfig) => {
  if (typeof fieldConfig.nodes !== "function" && typeof fieldConfig.resolve !== "function") {
    console.error(new Error(`Nexus Connection Plugin: Missing nodes or resolve property for ${typeName}.${fieldName}`));
  }
  eachObj(pluginConfig.extendConnection || {}, (val, key) => {
    if (typeof fieldConfig[key] !== "function" && val.requireResolver !== false) {
      console.error(new Error(`Nexus Connection Plugin: Missing ${key} resolver property for ${typeName}.${fieldName}. Set requireResolver to "false" on the field config if you do not need a resolver.`));
    }
  });
  eachObj(pluginConfig.extendEdge || {}, (val, key) => {
    var _a;
    if (typeof ((_a = fieldConfig.edgeFields) === null || _a === undefined ? undefined : _a[key]) !== "function" && val.requireResolver !== false) {
      console.error(new Error(`Nexus Connection Plugin: Missing edgeFields.${key} resolver property for ${typeName}.${fieldName}. Set requireResolver to "false" on the edge field config if you do not need a resolver.`));
    }
  });
};
connectionPlugin.defaultCursorFromNode = defaultCursorFromNode;
connectionPlugin.defaultValidateArgs = defaultValidateArgs;
connectionPlugin.defaultHasPreviousPage = defaultHasPreviousPage;
connectionPlugin.defaultHasNextPage = defaultHasNextPage;
connectionPlugin.base64Encode = base64Encode;
connectionPlugin.base64Decode = base64Decode;
connectionPlugin.CURSOR_PREFIX = CURSOR_PREFIX;
// node_modules/nexus/dist-esm/plugins/fieldAuthorizePlugin.js
var FieldauthorizeResolverImport = printedGenTypingImport({
  module: "nexus/dist/plugins/fieldAuthorizePlugin",
  bindings: ["FieldAuthorizeResolver"]
});
var fieldDefTypes = printedGenTyping({
  optional: true,
  name: "authorize",
  description: `
    Authorization for an individual field. Returning "true"
    or "Promise<true>" means the field can be accessed.
    Returning "false" or "Promise<false>" will respond
    with a "Not Authorized" error for the field. 
    Returning or throwing an error will also prevent the 
    resolver from executing.
  `,
  type: "FieldAuthorizeResolver<TypeName, FieldName>",
  imports: [FieldauthorizeResolverImport]
});
var defaultFormatError = ({ error }) => {
  const err = new Error("Not authorized");
  err.originalError = error;
  return err;
};
var fieldAuthorizePlugin = (authConfig = {}) => {
  const { formatError: formatError2 = defaultFormatError } = authConfig;
  const ensureError = (root, args3, ctx, info) => (error) => {
    const finalErr = formatError2({ error, root, args: args3, ctx, info });
    if (finalErr instanceof Error) {
      throw finalErr;
    }
    console.error(`Non-Error value ${finalErr} returned from custom formatError in authorize plugin`);
    throw new Error("Not authorized");
  };
  let hasWarned = false;
  return plugin({
    name: "NexusAuthorize",
    description: "The authorize plugin provides field-level authorization for a schema.",
    fieldDefTypes,
    onCreateFieldResolver(config) {
      var _a, _b, _c;
      const authorize = (_b = (_a = config.fieldConfig.extensions) === null || _a === undefined ? undefined : _a.nexus) === null || _b === undefined ? undefined : _b.config.authorize;
      if (authorize == null) {
        return;
      }
      if (typeof authorize !== "function") {
        console.error(new Error(`The authorize property provided to ${config.fieldConfig.name} with type ${config.fieldConfig.type} should be a function, saw ${typeof authorize}`));
        return;
      }
      if (!((_c = config.schemaConfig.plugins) === null || _c === undefined ? undefined : _c.find((p) => p.config.name === "NexusAuthorize"))) {
        if (!hasWarned) {
          console.warn('The GraphQL Nexus "authorize" feature has been moved to a plugin, add [fieldAuthorizePlugin()] to your makeSchema plugin config to remove this warning.');
          hasWarned = true;
        }
      }
      return function(root, args3, ctx, info, next) {
        let toComplete;
        try {
          toComplete = authorize(root, args3, ctx, info);
        } catch (e) {
          toComplete = Promise.reject(e);
        }
        return plugin.completeValue(toComplete, (authResult) => {
          if (authResult === true) {
            return next(root, args3, ctx, info);
          }
          const finalFormatError = ensureError(root, args3, ctx, info);
          if (authResult instanceof Error) {
            finalFormatError(authResult);
          }
          if (authResult === false) {
            finalFormatError(new Error("Not authorized"));
          }
          const { fieldName, parentType: { name: parentTypeName } } = info;
          finalFormatError(new Error(`Nexus authorize for ${parentTypeName}.${fieldName} Expected a boolean or Error, saw ${authResult}`));
        }, (err) => {
          ensureError(root, args3, ctx, info)(err);
        });
      };
    }
  });
};
// node_modules/iterall/index.mjs
var ArrayLikeIterator = function(obj) {
  this._o = obj;
  this._i = 0;
};
var AsyncFromSyncIterator = function(iterator) {
  this._i = iterator;
};
var unwrapAsyncFromSync = function(iterator, fn, value) {
  var step;
  return new Promise(function(resolve) {
    step = iterator[fn](value);
    resolve(step.value);
  }).then(function(value2) {
    return { value: value2, done: step.done };
  });
};
var SYMBOL = typeof Symbol === "function" ? Symbol : undefined;
var SYMBOL_ITERATOR = SYMBOL && SYMBOL.iterator;
var $$iterator = SYMBOL_ITERATOR || "@@iterator";
ArrayLikeIterator.prototype[$$iterator] = function() {
  return this;
};
ArrayLikeIterator.prototype.next = function() {
  if (this._o === undefined || this._i >= this._o.length) {
    this._o = undefined;
    return { value: undefined, done: true };
  }
  return { value: this._o[this._i++], done: false };
};
var SYMBOL_ASYNC_ITERATOR = SYMBOL && SYMBOL.asyncIterator;
var $$asyncIterator = SYMBOL_ASYNC_ITERATOR || "@@asyncIterator";
AsyncFromSyncIterator.prototype[$$asyncIterator] = function() {
  return this;
};
AsyncFromSyncIterator.prototype.next = function(value) {
  return unwrapAsyncFromSync(this._i, "next", value);
};
AsyncFromSyncIterator.prototype.return = function(value) {
  return this._i.return ? unwrapAsyncFromSync(this._i, "return", value) : Promise.resolve({ value, done: true });
};
AsyncFromSyncIterator.prototype.throw = function(value) {
  return this._i.throw ? unwrapAsyncFromSync(this._i, "throw", value) : Promise.reject(value);
};

// node_modules/nexus/dist-esm/plugins/nullabilityGuardPlugin.js
var fieldDefTypes2 = printedGenTyping({
  name: "skipNullGuard",
  optional: true,
  type: "boolean",
  description: `
    The nullability guard can be helpful, but is also a potentially expensive operation for lists.
    We need to iterate the entire list to check for null items to guard against. Set this to true
    to skip the null guard on a specific field if you know there's no potential for unsafe types.
  `
});
// node_modules/nexus/dist-esm/plugins/queryComplexityPlugin.js
var QueryComplexityImport = printedGenTypingImport({
  module: "nexus/dist/plugins/queryComplexityPlugin",
  bindings: ["QueryComplexity"]
});
var fieldDefTypes3 = printedGenTyping({
  optional: true,
  name: "complexity",
  description: `
    The complexity for an individual field. Return a number
    or a function that returns a number to specify the
    complexity for this field.
  `,
  type: "QueryComplexity<TypeName, FieldName>",
  imports: [QueryComplexityImport]
});
// node_modules/nexus/dist-esm/plugins/declarativeWrappingPlugin.js
var DeclarativeWrapping = [
  printedGenTyping({
    name: "nullable",
    type: "boolean",
    optional: true,
    description: `Whether the type can be null
@default (depends on whether nullability is configured in type or schema)
@see declarativeWrappingPlugin
`
  }),
  printedGenTyping({
    name: "list",
    type: "true | boolean[]",
    optional: true,
    description: `Whether the type is list of values, or just a single value.

If list is true, we assume the type is a list. If list is an array,
we'll assume that it's a list with the depth. The boolean indicates whether
the type is required (non-null), where true = nonNull, false = nullable.

@see declarativeWrappingPlugin
`
  }),
  printedGenTyping({
    name: "required",
    type: "boolean",
    optional: true,
    description: `Whether the type should be non null, \`required: true\` = \`nullable: false\`
@default (depends on whether nullability is configured in type or schema)

@see declarativeWrappingPlugin
`
  })
];
var declarativeWrappingPlugin = (config = {}) => {
  let hasWarned = false;
  return plugin({
    name: "declarativeWrapping",
    fieldDefTypes: config.disable ? undefined : DeclarativeWrapping,
    argTypeDefTypes: config.disable ? undefined : DeclarativeWrapping,
    inputFieldDefTypes: config.disable ? undefined : DeclarativeWrapping,
    description: "Provides a declarative nullable/list API, available by default pre-0.19",
    onAddOutputField(field) {
      return Object.assign(Object.assign({}, field), { type: maybeWrapType(field, config) });
    },
    onAddInputField(field) {
      return Object.assign(Object.assign({}, field), { type: maybeWrapType(field, config) });
    },
    onAddArg(arg2) {
      return Object.assign(Object.assign({}, arg2), { type: maybeWrapType(arg2, config) });
    }
  });
  function maybeWrapType(field, config2) {
    if (field.list == null && field.nullable == null && field.required == null) {
      return field.type;
    }
    const used = [];
    if (field.list != null) {
      used.push("list");
    }
    if (field.nullable != null) {
      used.push("nullable");
    }
    if (field.required != null) {
      used.push("required");
    }
    if (config2.disable || config2.shouldWarn) {
      const d = field;
      let location4 = d.configFor === "arg" ? `'${d.parentType}.${d.fieldName}' field's '${d.argName}' argument` : `'${d.parentType}.${d.type}' field`;
      if (config2.disable) {
        throw new Error(messages.removedDeclarativeWrapping(location4, used));
      } else {
        if (hasWarned) {
          console.warn(messages.removedDeclarativeWrappingShort(location4, used));
        } else {
          console.warn(messages.removedDeclarativeWrapping(location4, used));
        }
      }
    }
    if (isNexusWrappingType(field.type) && (field.list != null || field.nullable != null || field.required != null)) {
      let errorStr = field.configFor === "arg" ? `the arg '${field.argName}' of the field '${field.parentType}.${field.fieldName}'.` : `the field '${field.parentType}.${field.name}'.`;
      let usedProp = field.list != null ? "list" : field.nullable != null ? "nullable" : "required";
      throw new Error(`[declarativeWrappingPlugin] It looks like you used \`${usedProp}\` and wrapped the type of ` + errorStr + " You should only do one or the other");
    }
    let type = field.type;
    if (field.list === true) {
      if (field.nullable === false || field.required === true) {
        type = nonNull(type);
      }
      type = list(type);
    } else if (Array.isArray(field.list)) {
      for (const isNonNull of field.list) {
        if (isNonNull === true) {
          type = list(nonNull(type));
        } else {
          type = list(nullable(type));
        }
      }
    }
    if (field.required != null && field.nullable != null) {
      let errorSuffix = field.configFor === "arg" ? ` on ${field.parentType}.${field.fieldName} arg ${field.argName}` : ` on ${field.parentType}.${field.name}`;
      throw new Error(`Cannot set both required & nullable wrapping modifiers on ${errorSuffix}`);
    }
    if (field.nullable === true || field.required === false) {
      type = nullable(type);
    } else if (field.nullable === false || field.required === true) {
      type = nonNull(type);
    }
    return type;
  }
};
// node_modules/nexus/dist-esm/definitions/enumType.js
function enumType(config) {
  return new NexusEnumTypeDef(config.name, config);
}

class NexusEnumTypeDef {
  constructor(name, config) {
    this.name = name;
    this.config = config;
    assertValidName(name);
  }
  get value() {
    return this.config;
  }
  asArg(cfg) {
    return arg(Object.assign(Object.assign({}, cfg), { type: this }));
  }
}
withNexusSymbol(NexusEnumTypeDef, NexusTypes.Enum);

// node_modules/nexus/dist-esm/definitions/inputObjectType.js
function inputObjectType(config) {
  return new NexusInputObjectTypeDef(config.name, config);
}

class NexusInputObjectTypeDef {
  constructor(name, config) {
    this.name = name;
    this.config = config;
    assertValidName(name);
  }
  get value() {
    return this.config;
  }
  asArg(cfg) {
    return arg(Object.assign(Object.assign({}, cfg), { type: this }));
  }
}
withNexusSymbol(NexusInputObjectTypeDef, NexusTypes.InputObject);

// node_modules/nexus/dist-esm/definitions/scalarType.js
function scalarType(options) {
  return new NexusScalarTypeDef(options.name, options);
}
class NexusScalarTypeDef {
  constructor(name, config) {
    this.name = name;
    this.config = config;
    assertValidName(name);
  }
  get value() {
    return this.config;
  }
}
withNexusSymbol(NexusScalarTypeDef, NexusTypes.Scalar);

// node_modules/nexus/dist-esm/rebuildType.js
function rebuildNamedType(type, config) {
  if (isObjectType(type)) {
    return rebuildObjectType(type, config);
  } else if (isInputObjectType(type)) {
    return rebuildInputObjectType(type, config);
  } else if (isInterfaceType(type)) {
    return rebuildInterfaceType(type, config);
  } else if (isUnionType(type)) {
    return rebuildUnionType(type, config);
  } else if (isScalarType(type)) {
    return rebuildScalarType(type, config);
  } else if (isEnumType(type)) {
    return rebuildEnumType(type, config);
  }
  throw new Unreachable(type);
}
function rebuildInputObjectType(type, config) {
  const { name, fields, description, extensions } = type.toConfig();
  return inputObjectType({
    name,
    description,
    definition: (t) => {
      rebuildInputDefinition(name, t, fields, config);
    },
    extensions,
    nonNullDefaults: {
      output: false,
      input: false
    }
  });
}
function rebuildUnionType(type, config) {
  const { name, types, description, resolveType, extensions } = type.toConfig();
  return unionType({
    name,
    description,
    resolveType: resolveType !== null && resolveType !== undefined ? resolveType : defaultTypeResolver,
    definition(t) {
      t.members(...types.map((o) => {
        var _a;
        (_a = config.captureLeafType) === null || _a === undefined || _a.call(config, o);
        return o.name;
      }));
    },
    extensions
  });
}
function rebuildScalarType(type, config) {
  return scalarType(Object.assign(Object.assign({}, type.toConfig()), { sourceType: config.sourceType, asNexusMethod: config.asNexusMethod }));
}
function rebuildEnumType(type, { sourceType, asNexusMethod }) {
  const _a = type.toConfig(), { name, values: values2 } = _a, config = __rest(_a, ["name", "values"]);
  return enumType(Object.assign(Object.assign({ name }, config), {
    members: Object.entries(values2).map(([valueName, config2]) => {
      return Object.assign({ name: valueName, deprecation: config2.deprecationReason }, config2);
    }),
    sourceType,
    asNexusMethod
  }));
}
function rebuildInterfaceType(type, config) {
  const { name, fields, description, interfaces, extensions, resolveType } = graphql15InterfaceConfig(type.toConfig());
  return interfaceType({
    name,
    description,
    resolveType: resolveType !== null && resolveType !== undefined ? resolveType : defaultTypeResolver,
    definition: (t) => {
      rebuildOutputDefinition(name, t, fields, interfaces, config);
    },
    nonNullDefaults: {
      output: false,
      input: false
    },
    extensions,
    sourceType: config.sourceType,
    asNexusMethod: config.asNexusMethod
  });
}
function rebuildObjectType(type, config) {
  const { name, fields, interfaces, description, extensions } = type.toConfig();
  return objectType({
    name,
    description,
    definition: (t) => {
      rebuildOutputDefinition(name, t, fields, interfaces, config);
    },
    nonNullDefaults: {
      output: false,
      input: false
    },
    extensions,
    sourceType: config.sourceType,
    asNexusMethod: config.asNexusMethod
  });
}
function rebuildOutputDefinition(typeName, t, fields, interfaces, config) {
  var _a, _b, _c, _d;
  t.implements(...interfaces.map((i) => {
    var _a2;
    (_a2 = config.captureLeafType) === null || _a2 === undefined || _a2.call(config, i);
    return i.name;
  }));
  for (const [fieldName, fieldConfig] of Object.entries(fields)) {
    if (((_a = config.skipFields) === null || _a === undefined ? undefined : _a[typeName]) && ((_b = config.skipFields) === null || _b === undefined ? undefined : _b[typeName].includes(fieldName))) {
      continue;
    }
    const { namedType, wrapping: wrapping9 } = unwrapGraphQLDef(fieldConfig.type);
    (_c = config.captureLeafType) === null || _c === undefined || _c.call(config, namedType);
    t.field(fieldName, {
      type: applyNexusWrapping(namedType.name, wrapping9),
      description: fieldConfig.description,
      deprecation: fieldConfig.deprecationReason,
      extensions: fieldConfig.extensions,
      args: rebuildArgs(typeName, fieldName, (_d = fieldConfig.args) !== null && _d !== undefined ? _d : {}, config),
      resolve: fieldConfig.resolve
    });
  }
}
function rebuildInputDefinition(typeName, t, fields, config) {
  var _a, _b, _c;
  for (const [fieldName, fieldConfig] of Object.entries(fields)) {
    if (((_a = config.skipFields) === null || _a === undefined ? undefined : _a[typeName]) && ((_b = config.skipFields) === null || _b === undefined ? undefined : _b[typeName].includes(fieldName))) {
      continue;
    }
    const { namedType, wrapping: wrapping9 } = unwrapGraphQLDef(fieldConfig.type);
    (_c = config.captureLeafType) === null || _c === undefined || _c.call(config, namedType);
    t.field(fieldName, {
      type: applyNexusWrapping(namedType.name, wrapping9),
      description: fieldConfig.description,
      default: fieldConfig.defaultValue,
      extensions: fieldConfig.extensions
    });
  }
}
function rebuildArgs(typeName, fieldName, argMap, config) {
  var _a, _b, _c;
  if (!argMap) {
    return null;
  }
  const rebuiltArgs = {};
  for (const [argName, argConfig] of Object.entries(argMap)) {
    if ((_b = (_a = config.skipArgs) === null || _a === undefined ? undefined : _a[typeName]) === null || _b === undefined ? undefined : _b[fieldName]) {
      continue;
    }
    const { namedType, wrapping: wrapping9 } = unwrapGraphQLDef(argConfig.type);
    (_c = config.captureLeafType) === null || _c === undefined || _c.call(config, namedType);
    rebuiltArgs[argName] = arg({
      type: applyNexusWrapping(namedType.name, wrapping9),
      default: argConfig.defaultValue,
      description: argConfig.description,
      extensions: argConfig.extensions
    });
  }
  return rebuiltArgs;
}

// node_modules/nexus/dist-esm/builder.js
var extendError = function(name) {
  return new Error(`${name} was already defined and imported as a type, check the docs for extending types`);
};
function makeSchemaInternal(config) {
  const builder = new SchemaBuilder(config);
  builder.addTypes(config.types);
  if (config.schemaRoots) {
    builder.addTypes(config.schemaRoots);
  }
  const { finalConfig, typeMap, missingTypes, schemaExtension, onAfterBuildFns } = builder.getFinalTypeMap();
  function getRootType(rootType, defaultType) {
    var _a, _b;
    const rootTypeVal = (_b = (_a = config.schemaRoots) === null || _a === undefined ? undefined : _a[rootType]) !== null && _b !== undefined ? _b : defaultType;
    let returnVal = null;
    if (typeof rootTypeVal === "string") {
      returnVal = typeMap[rootTypeVal];
    } else if (rootTypeVal) {
      if (isNexusObjectTypeDef(rootTypeVal)) {
        returnVal = typeMap[rootTypeVal.name];
      } else if (isObjectType(rootTypeVal)) {
        returnVal = typeMap[rootTypeVal.name];
      }
    }
    if (returnVal && !isObjectType(returnVal)) {
      throw new Error(`Expected ${rootType} to be a objectType, saw ${returnVal.constructor.name}`);
    }
    return returnVal;
  }
  const schema3 = new GraphQLSchema({
    query: getRootType("query", "Query"),
    mutation: getRootType("mutation", "Mutation"),
    subscription: getRootType("subscription", "Subscription"),
    types: objValues(typeMap),
    extensions: Object.assign(Object.assign({}, config.extensions), { nexus: schemaExtension })
  });
  onAfterBuildFns.forEach((fn) => fn(schema3));
  return { schema: schema3, missingTypes, finalConfig };
}
function setConfigDefaults(config) {
  var _a, _b, _c, _d, _e;
  const defaults = {
    features: {
      abstractTypeRuntimeChecks: true,
      abstractTypeStrategies: {
        isTypeOf: false,
        resolveType: true,
        __typename: false
      }
    },
    nonNullDefaults: {
      input: false,
      output: false
    },
    plugins: [fieldAuthorizePlugin()]
  };
  if (!config.features) {
    config.features = defaults.features;
  } else {
    if (!config.features.abstractTypeStrategies) {
      config.features.abstractTypeStrategies = defaults.features.abstractTypeStrategies;
    } else {
      config.features.abstractTypeStrategies.__typename = (_a = config.features.abstractTypeStrategies.__typename) !== null && _a !== undefined ? _a : false;
      config.features.abstractTypeStrategies.isTypeOf = (_b = config.features.abstractTypeStrategies.isTypeOf) !== null && _b !== undefined ? _b : false;
      config.features.abstractTypeStrategies.resolveType = (_c = config.features.abstractTypeStrategies.resolveType) !== null && _c !== undefined ? _c : false;
    }
    if (config.features.abstractTypeStrategies.__typename === true) {
      config.features.abstractTypeRuntimeChecks = false;
    }
    if (config.features.abstractTypeRuntimeChecks === undefined) {
      config.features.abstractTypeRuntimeChecks = defaults.features.abstractTypeRuntimeChecks;
    }
  }
  config.plugins = (_d = config.plugins) !== null && _d !== undefined ? _d : [];
  config.nonNullDefaults = Object.assign(Object.assign({}, defaults.nonNullDefaults), (_e = config.nonNullDefaults) !== null && _e !== undefined ? _e : {});
  return config;
}
var SCALARS = {
  String: GraphQLString,
  Int: GraphQLInt,
  Float: GraphQLFloat,
  ID: GraphQLID,
  Boolean: GraphQLBoolean
};

class SchemaBuilder {
  constructor(config) {
    this.nexusMetaObjects = new Set;
    this.buildingTypes = new Set;
    this.finalTypeMap = {};
    this.definedTypeMap = {};
    this.pendingTypeMap = {};
    this.typeExtendMap = {};
    this.inputTypeExtendMap = {};
    this.graphqlNamedTypeMap = {};
    this.graphqlMergeSchemaMap = {};
    this.dynamicInputFields = {};
    this.dynamicOutputFields = {};
    this.dynamicOutputProperties = {};
    this.plugins = [];
    this.typesToWalk = [];
    this.sourceTypings = {};
    this.missingTypes = {};
    this.onMissingTypeFns = [];
    this.onBeforeBuildFns = [];
    this.onCreateResolverFns = [];
    this.onCreateSubscribeFns = [];
    this.onAfterBuildFns = [];
    this.onObjectDefinitionFns = [];
    this.onInputObjectDefinitionFns = [];
    this.onAddArgFns = [];
    this.onAddOutputFieldFns = [];
    this.onAddInputFieldFns = [];
    this.setConfigOption = (key, value) => {
      this.config = Object.assign(Object.assign({}, this.config), { [key]: value });
    };
    this.hasConfigOption = (key) => {
      return this.config.hasOwnProperty(key);
    };
    this.getConfigOption = (key) => {
      return this.config[key];
    };
    this.hasType = (typeName) => {
      return Boolean(this.pendingTypeMap[typeName] || this.finalTypeMap[typeName] || this.graphqlNamedTypeMap[typeName] || this.graphqlMergeSchemaMap[typeName]);
    };
    this.addType = (typeDef) => {
      var _a, _b, _c;
      if (isNexusDynamicInputMethod(typeDef)) {
        this.dynamicInputFields[typeDef.name] = typeDef;
        return;
      }
      if (isNexusDynamicOutputMethod(typeDef)) {
        this.dynamicOutputFields[typeDef.name] = typeDef;
        return;
      }
      if (isNexusDynamicOutputProperty(typeDef)) {
        this.dynamicOutputProperties[typeDef.name] = typeDef;
        return;
      }
      if (isNexusMeta(typeDef)) {
        this.addToNexusMeta(typeDef);
        return;
      }
      if ((_a = typeDef.name) === null || _a === undefined ? undefined : _a.startsWith("__")) {
        return;
      }
      if (isNexusExtendTypeDef(typeDef)) {
        const typeExtensions = this.typeExtendMap[typeDef.name] = this.typeExtendMap[typeDef.name] || [];
        typeExtensions.push(typeDef.value);
        this.typesToWalk.push({ type: "object", value: typeDef.value });
        return;
      }
      if (isNexusExtendInputTypeDef(typeDef)) {
        const typeExtensions = this.inputTypeExtendMap[typeDef.name] = this.inputTypeExtendMap[typeDef.name] || [];
        typeExtensions.push(typeDef.value);
        this.typesToWalk.push({ type: "input", value: typeDef.value });
        return;
      }
      const existingType = this.pendingTypeMap[typeDef.name];
      if (existingType) {
        if (existingType !== typeDef) {
          throw extendError(typeDef.name);
        }
        return;
      }
      if (isNexusNamedTypeDef(typeDef)) {
        if (isNexusNamedOuputTypeDef(typeDef) && typeDef.value.asNexusMethod) {
          this.dynamicOutputFields[typeDef.value.asNexusMethod] = typeDef.name;
        }
        if (isNexusNamedInputTypeDef(typeDef) && typeDef.value.asNexusMethod) {
          this.dynamicInputFields[typeDef.value.asNexusMethod] = typeDef.name;
        }
        if (isNexusScalarTypeDef(typeDef) && typeDef.value.sourceType) {
          this.sourceTypings[typeDef.name] = typeDef.value.sourceType;
        }
      }
      if (isNamedType(typeDef)) {
        if (this.graphqlNamedTypeMap[typeDef.name]) {
          return;
        }
        if ((_b = typeDef.extensions) === null || _b === undefined ? undefined : _b.nexus) {
          const { asNexusMethod, sourceType } = Object(typeDef.extensions.nexus);
          if (asNexusMethod) {
            if (isInputType(typeDef)) {
              this.dynamicInputFields[asNexusMethod] = typeDef.name;
            }
            if (isOutputType(typeDef)) {
              this.dynamicOutputFields[asNexusMethod] = typeDef.name;
            }
          }
          if (sourceType) {
            this.sourceTypings[typeDef.name] = sourceType;
          }
        }
        this.graphqlNamedTypeMap[typeDef.name] = this.handleNativeType(typeDef, {
          captureLeafType: (t) => {
            if (!this.graphqlNamedTypeMap[t.name] && t.name !== typeDef.name) {
              this.addType(t);
            }
          }
        });
        if ((_c = typeDef.extensions) === null || _c === undefined ? undefined : _c.nexus) {
          this.addType(this.graphqlNamedTypeMap[typeDef.name]);
        }
        return;
      }
      this.pendingTypeMap[typeDef.name] = typeDef;
      if (isNexusInputObjectTypeDef(typeDef)) {
        this.typesToWalk.push({ type: "input", value: typeDef.value });
      }
      if (isNexusObjectTypeDef(typeDef)) {
        this.typesToWalk.push({ type: "object", value: typeDef.value });
      }
      if (isNexusInterfaceTypeDef(typeDef)) {
        this.typesToWalk.push({ type: "interface", value: typeDef.value });
      }
    };
    this.config = setConfigDefaults(config);
    this.plugins = this.config.plugins.length > 0 ? this.config.plugins : [fieldAuthorizePlugin()];
    if (!this.plugins.find((f) => f.config.name === "declarativeWrapping")) {
      this.plugins.push(declarativeWrappingPlugin({ disable: true }));
    }
    this.builderLens = Object.freeze({
      hasType: this.hasType,
      addType: this.addType,
      setConfigOption: this.setConfigOption,
      hasConfigOption: this.hasConfigOption,
      getConfigOption: this.getConfigOption
    });
    if (config.mergeSchema) {
      this.graphqlMergeSchemaMap = this.handleMergeSchema(config.mergeSchema);
    }
  }
  get schemaExtension() {
    if (!this._schemaExtension) {
      throw new Error("Cannot reference schemaExtension before it is created");
    }
    return this._schemaExtension;
  }
  addTypes(types) {
    var _a, _b;
    if (!types) {
      return;
    }
    if (isSchema(types)) {
      if (((_a = this.config.mergeSchema) === null || _a === undefined ? undefined : _a.schema) === types) {
        return;
      } else if (!this.config.mergeSchema) {
        if (Object.keys(this.graphqlMergeSchemaMap).length) {
          console.error(new Error(`It looks like you're trying to merge multiple GraphQL schemas.\n Please open a GitHub ticket with more info about your use case.`));
        }
        this.graphqlMergeSchemaMap = this.handleMergeSchema({ schema: types });
      } else {
        this.addTypes(types.getTypeMap());
      }
      return;
    }
    if (isNexusPlugin(types)) {
      if (!((_b = this.plugins) === null || _b === undefined ? undefined : _b.includes(types))) {
        throw new Error(`Nexus plugin ${types.config.name} was seen in the "types" config, but should instead be provided to the "plugins" array.`);
      }
      return;
    }
    if (isNexusNamedTypeDef(types) || isNexusExtendTypeDef(types) || isNexusExtendInputTypeDef(types) || isNamedType(types) || isNexusDynamicInputMethod(types) || isNexusDynamicOutputMethod(types) || isNexusDynamicOutputProperty(types) || isNexusMeta(types)) {
      this.addType(types);
    } else if (Array.isArray(types)) {
      types.forEach((typeDef) => this.addTypes(typeDef));
    } else if (isObject(types)) {
      Object.keys(types).forEach((key) => this.addTypes(types[key]));
    }
  }
  addToNexusMeta(type) {
    if (this.nexusMetaObjects.has(type)) {
      return;
    }
    this.nexusMetaObjects.add(type);
    if (isNexusMetaBuild(type)) {
      const types = type[NEXUS_BUILD]();
      this.addTypes(types);
    }
    if (isNexusMetaType(type)) {
      this.addType(resolveNexusMetaType(type));
    }
  }
  walkTypes() {
    let obj;
    while (obj = this.typesToWalk.shift()) {
      switch (obj.type) {
        case "input":
          this.walkInputType(obj.value);
          break;
        case "interface":
          this.walkInterfaceType(obj.value);
          break;
        case "object":
          this.walkOutputType(obj.value);
          break;
        default:
          casesHandled(obj);
      }
    }
  }
  beforeWalkTypes() {
    this.plugins.forEach((obj, i) => {
      if (!isNexusPlugin(obj)) {
        throw new Error(`Expected a plugin in plugins[${i}], saw ${obj}`);
      }
      const { config: pluginConfig } = obj;
      if (pluginConfig.onInstall) {
        const installResult = pluginConfig.onInstall(this.builderLens);
        if (Array.isArray(installResult === null || installResult === undefined ? undefined : installResult.types)) {
          throw new Error(`Nexus no longer supports a return value from onInstall, you should instead use the hasType/addType api (seen in plugin ${pluginConfig.name}). `);
        }
      }
      if (pluginConfig.onCreateFieldResolver) {
        this.onCreateResolverFns.push(pluginConfig.onCreateFieldResolver);
      }
      if (pluginConfig.onCreateFieldSubscribe) {
        this.onCreateSubscribeFns.push(pluginConfig.onCreateFieldSubscribe);
      }
      if (pluginConfig.onBeforeBuild) {
        this.onBeforeBuildFns.push(pluginConfig.onBeforeBuild);
      }
      if (pluginConfig.onMissingType) {
        this.onMissingTypeFns.push(pluginConfig.onMissingType);
      }
      if (pluginConfig.onAfterBuild) {
        this.onAfterBuildFns.push(pluginConfig.onAfterBuild);
      }
      if (pluginConfig.onObjectDefinition) {
        this.onObjectDefinitionFns.push(pluginConfig.onObjectDefinition);
      }
      if (pluginConfig.onAddOutputField) {
        this.onAddOutputFieldFns.push(pluginConfig.onAddOutputField);
      }
      if (pluginConfig.onAddInputField) {
        this.onAddInputFieldFns.push(pluginConfig.onAddInputField);
      }
      if (pluginConfig.onAddArg) {
        this.onAddArgFns.push(pluginConfig.onAddArg);
      }
      if (pluginConfig.onInputObjectDefinition) {
        this.onInputObjectDefinitionFns.push(pluginConfig.onInputObjectDefinition);
      }
    });
  }
  beforeBuildTypes() {
    this.onBeforeBuildFns.forEach((fn) => {
      fn(this.builderLens);
      if (this.typesToWalk.length > 0) {
        this.walkTypes();
      }
    });
  }
  checkForInterfaceCircularDependencies() {
    const interfaces = {};
    Object.keys(this.pendingTypeMap).map((key) => this.pendingTypeMap[key]).filter(isNexusInterfaceTypeDef).forEach((type) => {
      interfaces[type.name] = type.value;
    });
    const alreadyChecked = {};
    const walkType = (obj, path, visited) => {
      if (alreadyChecked[obj.name]) {
        return;
      }
      if (visited[obj.name]) {
        if (obj.name === path[path.length - 1]) {
          throw new Error(`GraphQL Nexus: Interface ${obj.name} can't implement itself`);
        } else {
          throw new Error(`GraphQL Nexus: Interface circular dependency detected ${[
            ...path.slice(path.lastIndexOf(obj.name)),
            obj.name
          ].join(" -> ")}`);
        }
      }
      const definitionBlock = new InterfaceDefinitionBlock({
        typeName: obj.name,
        addInterfaces: (i) => i.forEach((config) => {
          const name = typeof config === "string" ? config : config.value.name;
          walkType(interfaces[name], [...path, obj.name], Object.assign(Object.assign({}, visited), { [obj.name]: true }));
        }),
        addModification: () => {
        },
        addField: () => {
        },
        addDynamicOutputMembers: (block2, wrapping10) => this.addDynamicOutputMembers(block2, "walk", wrapping10),
        warn: () => {
        }
      });
      obj.definition(definitionBlock);
      alreadyChecked[obj.name] = true;
    };
    Object.keys(interfaces).forEach((name) => {
      walkType(interfaces[name], [], {});
    });
  }
  buildNexusTypes() {
    var _a;
    if (!this.pendingTypeMap.Query && !((_a = this.config.schemaRoots) === null || _a === undefined ? undefined : _a.query) && !this.typeExtendMap.Query) {
      this.pendingTypeMap.Query = null;
    }
    Object.keys(this.pendingTypeMap).forEach((key) => {
      if (this.typesToWalk.length > 0) {
        this.walkTypes();
      }
      if (this.finalTypeMap[key]) {
        return;
      }
      if (this.definedTypeMap[key]) {
        throw extendError(key);
      }
      this.finalTypeMap[key] = this.getOrBuildType(key);
      this.buildingTypes.clear();
    });
    Object.keys(this.typeExtendMap).forEach((key) => {
      if (this.typeExtendMap[key] !== null && !this.hasType(key)) {
        this.buildObjectType({
          name: key,
          definition() {
          }
        });
      }
    });
    Object.keys(this.inputTypeExtendMap).forEach((key) => {
      if (this.inputTypeExtendMap[key] !== null && !this.hasType(key)) {
        this.buildInputObjectType({
          name: key,
          definition() {
          }
        });
      }
    });
  }
  createSchemaExtension() {
    this._schemaExtension = new NexusSchemaExtension(Object.assign(Object.assign({}, this.config), { dynamicFields: {
      dynamicInputFields: this.dynamicInputFields,
      dynamicOutputFields: this.dynamicOutputFields,
      dynamicOutputProperties: this.dynamicOutputProperties
    }, sourceTypings: this.sourceTypings }));
  }
  getFinalTypeMap() {
    this.beforeWalkTypes();
    this.createSchemaExtension();
    this.walkTypes();
    this.beforeBuildTypes();
    this.checkForInterfaceCircularDependencies();
    this.buildNexusTypes();
    return {
      finalConfig: this.config,
      typeMap: this.finalTypeMap,
      schemaExtension: this.schemaExtension,
      missingTypes: this.missingTypes,
      onAfterBuildFns: this.onAfterBuildFns
    };
  }
  shouldMerge(typeName) {
    if (!this.config.mergeSchema) {
      return false;
    }
    const { mergeTypes = ["Query", "Mutation"] } = this.config.mergeSchema;
    return Boolean(mergeTypes === true || mergeTypes.includes(typeName));
  }
  buildInputObjectType(config) {
    const fields = [];
    const definitionBlock = new InputDefinitionBlock({
      typeName: config.name,
      addField: (field) => fields.push(this.addInputField(field)),
      addDynamicInputFields: (block2, wrapping10) => this.addDynamicInputFields(block2, wrapping10),
      warn: consoleWarn
    });
    const externalNamedType = this.graphqlMergeSchemaMap[config.name];
    if (this.shouldMerge(config.name) && isNexusInputObjectTypeDef(externalNamedType)) {
      externalNamedType.value.definition(definitionBlock);
    }
    config.definition(definitionBlock);
    this.onInputObjectDefinitionFns.forEach((fn) => {
      fn(definitionBlock, config);
    });
    const extensions2 = this.inputTypeExtendMap[config.name];
    if (extensions2) {
      extensions2.forEach((extension) => {
        extension.definition(definitionBlock);
      });
    }
    this.inputTypeExtendMap[config.name] = null;
    const inputObjectTypeConfig = {
      name: config.name,
      fields: () => this.buildInputObjectFields(fields, inputObjectTypeConfig),
      description: config.description,
      extensions: Object.assign(Object.assign({}, config.extensions), { nexus: new NexusInputObjectTypeExtension(config) })
    };
    return this.finalize(new GraphQLInputObjectType(inputObjectTypeConfig));
  }
  buildObjectType(config) {
    const fields = [];
    const interfaces = [];
    const modifications = {};
    const definitionBlock = new ObjectDefinitionBlock({
      typeName: config.name,
      addField: (fieldDef) => fields.push(this.addOutputField(fieldDef)),
      addInterfaces: (interfaceDefs) => interfaces.push(...interfaceDefs),
      addModification: (modification) => modifications[modification.field] = modification,
      addDynamicOutputMembers: (block2, wrapping10) => this.addDynamicOutputMembers(block2, "build", wrapping10),
      warn: consoleWarn
    });
    const externalNamedType = this.graphqlMergeSchemaMap[config.name];
    if (this.shouldMerge(config.name) && isNexusObjectTypeDef(externalNamedType)) {
      externalNamedType.value.definition(definitionBlock);
    }
    config.definition(definitionBlock);
    this.onObjectDefinitionFns.forEach((fn) => {
      fn(definitionBlock, config);
    });
    const extensions2 = this.typeExtendMap[config.name];
    if (extensions2) {
      extensions2.forEach((extension) => {
        extension.definition(definitionBlock);
      });
    }
    this.typeExtendMap[config.name] = null;
    if (config.sourceType) {
      this.sourceTypings[config.name] = config.sourceType;
    }
    const objectTypeConfig = {
      name: config.name,
      interfaces: () => this.buildInterfaceList(interfaces),
      description: config.description,
      fields: () => this.buildOutputFields(fields, objectTypeConfig, this.buildInterfaceFields(objectTypeConfig, interfaces, modifications)),
      isTypeOf: config.isTypeOf,
      extensions: Object.assign(Object.assign({}, config.extensions), { nexus: new NexusObjectTypeExtension(config) })
    };
    return this.finalize(new GraphQLObjectType(objectTypeConfig));
  }
  buildInterfaceType(config) {
    const { name, description } = config;
    let resolveType = config.resolveType;
    const fields = [];
    const interfaces = [];
    const modifications = {};
    const definitionBlock = new InterfaceDefinitionBlock({
      typeName: config.name,
      addField: (field) => fields.push(this.addOutputField(field)),
      addInterfaces: (interfaceDefs) => interfaces.push(...interfaceDefs),
      addModification: (modification) => modifications[modification.field] = modification,
      addDynamicOutputMembers: (block2, wrapping10) => this.addDynamicOutputMembers(block2, "build", wrapping10),
      warn: consoleWarn
    });
    const externalNamedType = this.graphqlMergeSchemaMap[config.name];
    if (this.shouldMerge(config.name) && isNexusInterfaceTypeDef(externalNamedType)) {
      externalNamedType.value.definition(definitionBlock);
    }
    config.definition(definitionBlock);
    if (config.sourceType) {
      this.sourceTypings[config.name] = config.sourceType;
    }
    const interfaceTypeConfig = {
      name,
      interfaces: () => this.buildInterfaceList(interfaces),
      resolveType,
      description,
      fields: () => this.buildOutputFields(fields, interfaceTypeConfig, this.buildInterfaceFields(interfaceTypeConfig, interfaces, modifications)),
      extensions: Object.assign(Object.assign({}, config.extensions), { nexus: new NexusInterfaceTypeExtension(config) })
    };
    return this.finalize(new GraphQLInterfaceType(interfaceTypeConfig));
  }
  addOutputField(field) {
    this.onAddOutputFieldFns.forEach((fn) => {
      const result = fn(field);
      if (result) {
        field = result;
      }
    });
    return field;
  }
  addInputField(field) {
    this.onAddInputFieldFns.forEach((fn) => {
      const result = fn(field);
      if (result) {
        field = result;
      }
    });
    return field;
  }
  buildEnumType(config) {
    var _a, _b;
    const { members } = config;
    const values2 = {};
    if (isArray(members)) {
      members.forEach((m) => {
        var _a2, _b2;
        if (typeof m === "string") {
          values2[m] = { value: m };
        } else {
          values2[m.name] = {
            value: typeof m.value === "undefined" ? m.name : m.value,
            deprecationReason: m.deprecation,
            description: m.description,
            extensions: Object.assign(Object.assign({}, m.extensions), { nexus: (_b2 = (_a2 = m.extensions) === null || _a2 === undefined ? undefined : _a2.nexus) !== null && _b2 !== undefined ? _b2 : {} })
          };
        }
      });
    } else {
      Object.keys(members).filter((key) => isNaN(+key)).forEach((key) => {
        assertValidName(key);
        values2[key] = {
          value: members[key]
        };
      });
    }
    if (!Object.keys(values2).length) {
      throw new Error(`GraphQL Nexus: Enum ${config.name} must have at least one member`);
    }
    if (config.sourceType) {
      this.sourceTypings[config.name] = config.sourceType;
    }
    return this.finalize(new GraphQLEnumType({
      name: config.name,
      values: values2,
      description: config.description,
      extensions: Object.assign(Object.assign({}, config.extensions), { nexus: (_b = (_a = config.extensions) === null || _a === undefined ? undefined : _a.nexus) !== null && _b !== undefined ? _b : {} })
    }));
  }
  buildUnionType(config) {
    var _a, _b;
    let members;
    let resolveType = config.resolveType;
    config.definition(new UnionDefinitionBlock({
      typeName: config.name,
      addUnionMembers: (unionMembers) => members = unionMembers
    }));
    if (config.sourceType) {
      this.sourceTypings[config.name] = config.sourceType;
    }
    return this.finalize(new GraphQLUnionType({
      name: config.name,
      resolveType,
      description: config.description,
      types: () => this.buildUnionMembers(config.name, members),
      extensions: Object.assign(Object.assign({}, config.extensions), { nexus: (_b = (_a = config.extensions) === null || _a === undefined ? undefined : _a.nexus) !== null && _b !== undefined ? _b : {} })
    }));
  }
  buildScalarType(config) {
    var _a, _b;
    if (config.sourceType) {
      this.sourceTypings[config.name] = config.sourceType;
    }
    return this.finalize(new GraphQLScalarType(Object.assign(Object.assign({}, config), { extensions: Object.assign(Object.assign({}, config.extensions), { nexus: (_b = (_a = config.extensions) === null || _a === undefined ? undefined : _a.nexus) !== null && _b !== undefined ? _b : {} }) })));
  }
  finalize(type) {
    this.finalTypeMap[type.name] = type;
    return type;
  }
  missingType(typeName, fromObject = false) {
    invariantGuard(typeName);
    if (this.onMissingTypeFns.length) {
      for (let i = 0;i < this.onMissingTypeFns.length; i++) {
        const fn = this.onMissingTypeFns[i];
        const replacementType = fn(typeName, this.builderLens);
        if (replacementType && replacementType.name) {
          this.addType(replacementType);
          return this.getOrBuildType(replacementType);
        }
      }
    }
    if (typeName === "Query") {
      return new GraphQLObjectType({
        name: "Query",
        fields: {
          ok: {
            type: new GraphQLNonNull(GraphQLBoolean),
            resolve: () => true
          }
        }
      });
    }
    if (!this.missingTypes[typeName]) {
      this.missingTypes[typeName] = { fromObject };
    }
    this.addType(UNKNOWN_TYPE_SCALAR);
    return this.getOrBuildType(UNKNOWN_TYPE_SCALAR);
  }
  buildUnionMembers(unionName, members) {
    const unionMembers = [];
    if (!members) {
      throw new Error(`Missing Union members for ${unionName}.` + `Make sure to call the t.members(...) method in the union blocks`);
    }
    members.forEach((member) => {
      unionMembers.push(this.getObjectType(member));
    });
    if (!unionMembers.length) {
      throw new Error(`GraphQL Nexus: Union ${unionName} must have at least one member type`);
    }
    return unionMembers;
  }
  buildInterfaceList(interfaces) {
    const list4 = [];
    interfaces.forEach((i) => {
      const type = this.getInterface(i);
      list4.push(type, ...graphql15InterfaceType(type).getInterfaces());
    });
    return Array.from(new Set(list4));
  }
  buildInterfaceFields(forTypeConfig, interfaces, modifications) {
    const interfaceFieldsMap = {};
    interfaces.forEach((i) => {
      const config = this.getInterface(i).toConfig();
      Object.keys(config.fields).forEach((field) => {
        var _a, _b, _c, _d, _e;
        const interfaceField = config.fields[field];
        interfaceFieldsMap[field] = interfaceField;
        if (modifications[field]) {
          const _f = modifications[field], { type, field: _field, args: args6, extensions: extensions2 } = _f, rest = __rest(_f, ["type", "field", "args", "extensions"]);
          const extensionConfig = hasNexusExtension(extensions2 === null || extensions2 === undefined ? undefined : extensions2.nexus) ? (_b = (_a = extensions2 === null || extensions2 === undefined ? undefined : extensions2.nexus) === null || _a === undefined ? undefined : _a.config) !== null && _b !== undefined ? _b : {} : {};
          interfaceFieldsMap[field] = Object.assign(Object.assign(Object.assign({}, interfaceFieldsMap[field]), rest), { extensions: Object.assign(Object.assign(Object.assign({}, interfaceField.extensions), extensions2), { nexus: hasNexusExtension((_c = interfaceField.extensions) === null || _c === undefined ? undefined : _c.nexus) ? (_e = (_d = interfaceField.extensions) === null || _d === undefined ? undefined : _d.nexus) === null || _e === undefined ? undefined : _e.modify(extensionConfig) : new NexusFieldExtension(extensionConfig) }) });
          if (typeof type !== "undefined") {
            let interfaceReplacement;
            if (isNexusWrappingType(type)) {
              const { wrapping: wrapping10, namedType } = unwrapNexusDef(type);
              interfaceReplacement = rewrapAsGraphQLType(this.getOrBuildType(namedType), wrapping10);
            } else {
              const { wrapping: wrapping10 } = unwrapGraphQLDef(config.fields[field].type);
              interfaceReplacement = rewrapAsGraphQLType(this.getOutputType(type), wrapping10);
            }
            interfaceFieldsMap[field].type = interfaceReplacement;
          }
          if (typeof args6 !== "undefined") {
            interfaceFieldsMap[field].args = Object.assign(Object.assign({}, this.buildArgs(args6 !== null && args6 !== undefined ? args6 : {}, forTypeConfig, field)), interfaceFieldsMap[field].args);
          }
        }
      });
    });
    return interfaceFieldsMap;
  }
  buildOutputFields(fields, typeConfig, intoObject) {
    fields.forEach((field) => {
      intoObject[field.name] = this.buildOutputField(field, typeConfig);
    });
    return intoObject;
  }
  buildInputObjectFields(fields, typeConfig) {
    const fieldMap = {};
    fields.forEach((field) => {
      fieldMap[field.name] = this.buildInputObjectField(field, typeConfig);
    });
    return fieldMap;
  }
  getNonNullDefault(nonNullDefaultConfig, kind) {
    var _a, _b;
    const { nonNullDefaults = {} } = nonNullDefaultConfig !== null && nonNullDefaultConfig !== undefined ? nonNullDefaultConfig : {};
    return (_b = (_a = nonNullDefaults[kind]) !== null && _a !== undefined ? _a : this.config.nonNullDefaults[kind]) !== null && _b !== undefined ? _b : false;
  }
  buildOutputField(fieldConfig, typeConfig) {
    var _a, _b;
    if (!fieldConfig.type) {
      throw new Error(`Missing required "type" field for ${typeConfig.name}.${fieldConfig.name}`);
    }
    const fieldExtension = new NexusFieldExtension(fieldConfig);
    const nonNullDefault = this.getNonNullDefault((_b = (_a = typeConfig.extensions) === null || _a === undefined ? undefined : _a.nexus) === null || _b === undefined ? undefined : _b.config, "output");
    const { namedType, wrapping: wrapping10 } = unwrapNexusDef(fieldConfig.type);
    const finalWrap = finalizeWrapping(nonNullDefault, wrapping10, fieldConfig.wrapping);
    const builderFieldConfig = {
      name: fieldConfig.name,
      type: rewrapAsGraphQLType(this.getOutputType(namedType), finalWrap),
      args: this.buildArgs(fieldConfig.args || {}, typeConfig, fieldConfig.name),
      description: fieldConfig.description,
      deprecationReason: fieldConfig.deprecation,
      extensions: Object.assign(Object.assign({}, fieldConfig.extensions), { nexus: fieldExtension })
    };
    return Object.assign({ resolve: this.makeFinalResolver({
      builder: this.builderLens,
      fieldConfig: builderFieldConfig,
      parentTypeConfig: typeConfig,
      schemaConfig: this.config,
      schemaExtension: this.schemaExtension
    }, fieldConfig.resolve), subscribe: fieldConfig.subscribe }, builderFieldConfig);
  }
  makeFinalResolver(info, resolver) {
    const resolveFn = resolver || defaultFieldResolver;
    if (this.onCreateResolverFns.length) {
      const toCompose = this.onCreateResolverFns.map((fn) => fn(info)).filter((f) => f);
      if (toCompose.length) {
        return composeMiddlewareFns(toCompose, resolveFn);
      }
    }
    return resolveFn;
  }
  buildInputObjectField(fieldConfig, typeConfig) {
    var _a, _b, _c, _d;
    const nonNullDefault = this.getNonNullDefault((_b = (_a = typeConfig.extensions) === null || _a === undefined ? undefined : _a.nexus) === null || _b === undefined ? undefined : _b.config, "input");
    const { namedType, wrapping: wrapping10 } = unwrapNexusDef(fieldConfig.type);
    const finalWrap = finalizeWrapping(nonNullDefault, wrapping10, fieldConfig.wrapping);
    return {
      type: rewrapAsGraphQLType(this.getInputType(namedType), finalWrap),
      defaultValue: fieldConfig.default,
      description: fieldConfig.description,
      extensions: Object.assign(Object.assign({}, fieldConfig.extensions), { nexus: (_d = (_c = fieldConfig.extensions) === null || _c === undefined ? undefined : _c.nexus) !== null && _d !== undefined ? _d : {} })
    };
  }
  buildArgs(args6, typeConfig, fieldName) {
    var _a, _b, _c, _d;
    const allArgs = {};
    for (const [argName, arg2] of Object.entries(args6)) {
      const nonNullDefault = this.getNonNullDefault((_b = (_a = typeConfig.extensions) === null || _a === undefined ? undefined : _a.nexus) === null || _b === undefined ? undefined : _b.config, "input");
      let finalArgDef = Object.assign(Object.assign({}, normalizeArgWrapping(arg2).value), {
        fieldName,
        argName,
        parentType: typeConfig.name,
        configFor: "arg"
      });
      for (const onArgDef of this.onAddArgFns) {
        const result = onArgDef(finalArgDef);
        if (result != null) {
          finalArgDef = result;
        }
      }
      const { namedType, wrapping: wrapping10 } = unwrapNexusDef(finalArgDef.type);
      const finalWrap = finalizeWrapping(nonNullDefault, wrapping10);
      allArgs[argName] = {
        type: rewrapAsGraphQLType(this.getInputType(namedType), finalWrap),
        description: finalArgDef.description,
        defaultValue: finalArgDef.default,
        extensions: Object.assign(Object.assign({}, finalArgDef.extensions), { nexus: (_d = (_c = finalArgDef.extensions) === null || _c === undefined ? undefined : _c.nexus) !== null && _d !== undefined ? _d : {} })
      };
    }
    return allArgs;
  }
  getInterface(name) {
    const type = this.getOrBuildType(name);
    if (!isInterfaceType(type)) {
      throw new Error(`Expected ${name} to be an interfaceType, saw ${type.constructor.name}(${type.name})`);
    }
    return type;
  }
  getInputType(possibleInputType) {
    const nexusNamedType = getNexusNamedType(possibleInputType);
    const graphqlType = this.getOrBuildType(nexusNamedType);
    if (!isInputObjectType(graphqlType) && !isLeafType(graphqlType)) {
      throw new Error(`Expected ${nexusNamedType} to be a possible input type, saw ${graphqlType.constructor.name}(${graphqlType.name})`);
    }
    return graphqlType;
  }
  getOutputType(possibleOutputType) {
    const graphqlType = this.getOrBuildType(possibleOutputType);
    if (!isOutputType(graphqlType)) {
      throw new Error(`Expected ${possibleOutputType} to be a valid output type, saw ${graphqlType.constructor.name}`);
    }
    return graphqlType;
  }
  getObjectType(name) {
    if (isNexusNamedTypeDef(name)) {
      return this.getObjectType(name.name);
    }
    const type = this.getOrBuildType(name);
    if (!isObjectType(type)) {
      throw new Error(`Expected ${name} to be a objectType, saw ${type.constructor.name}`);
    }
    return type;
  }
  getOrBuildType(type, fromObject = false) {
    var _a, _b;
    invariantGuard(type);
    if (isNamedType(type)) {
      return type;
    }
    if (isNexusNamedTypeDef(type)) {
      return this.getOrBuildType(type.name, true);
    }
    if (SCALARS[type]) {
      return SCALARS[type];
    }
    if (this.finalTypeMap[type]) {
      return this.finalTypeMap[type];
    }
    if (this.buildingTypes.has(type)) {
      throw new Error(`GraphQL Nexus: Circular dependency detected, while building types ${Array.from(this.buildingTypes)}`);
    }
    const pendingType = (_b = (_a = this.pendingTypeMap[type]) !== null && _a !== undefined ? _a : this.graphqlNamedTypeMap[type]) !== null && _b !== undefined ? _b : this.graphqlMergeSchemaMap[type];
    if (isNexusNamedTypeDef(pendingType)) {
      this.buildingTypes.add(pendingType.name);
      if (isNexusObjectTypeDef(pendingType)) {
        return this.buildObjectType(pendingType.value);
      } else if (isNexusInterfaceTypeDef(pendingType)) {
        return this.buildInterfaceType(pendingType.value);
      } else if (isNexusEnumTypeDef(pendingType)) {
        return this.buildEnumType(pendingType.value);
      } else if (isNexusScalarTypeDef(pendingType)) {
        return this.buildScalarType(pendingType.value);
      } else if (isNexusInputObjectTypeDef(pendingType)) {
        return this.buildInputObjectType(pendingType.value);
      } else if (isNexusUnionTypeDef(pendingType)) {
        return this.buildUnionType(pendingType.value);
      } else {
        console.warn("Unknown kind of type def to build. It will be ignored. The type def was: %j", type);
      }
    }
    return this.missingType(type, fromObject);
  }
  walkInputType(obj) {
    const definitionBlock = new InputDefinitionBlock({
      typeName: obj.name,
      addField: (f) => this.maybeTraverseInputFieldType(f),
      addDynamicInputFields: (block2, wrapping10) => this.addDynamicInputFields(block2, wrapping10),
      warn: () => {
      }
    });
    obj.definition(definitionBlock);
    return obj;
  }
  addDynamicInputFields(block2, wrapping10) {
    eachObj(this.dynamicInputFields, (val, methodName) => {
      if (typeof val === "string") {
        return this.addDynamicField(methodName, val, block2);
      }
      block2[methodName] = (...args6) => {
        return val.value.factory({
          args: args6,
          typeDef: block2,
          builder: this.builderLens,
          typeName: block2.typeName,
          wrapping: wrapping10
        });
      };
    });
  }
  addDynamicOutputMembers(block2, stage, wrapping10) {
    eachObj(this.dynamicOutputFields, (val, methodName) => {
      if (typeof val === "string") {
        return this.addDynamicField(methodName, val, block2);
      }
      block2[methodName] = (...args6) => {
        return val.value.factory({
          args: args6,
          typeDef: block2,
          builder: this.builderLens,
          typeName: block2.typeName,
          stage,
          wrapping: wrapping10
        });
      };
    });
    eachObj(this.dynamicOutputProperties, (val, propertyName) => {
      Object.defineProperty(block2, propertyName, {
        get() {
          return val.value.factory({
            typeDef: block2,
            builder: this.builderLens,
            typeName: block2.typeName,
            stage
          });
        },
        enumerable: true
      });
    });
  }
  addDynamicField(methodName, typeName, block2) {
    block2[methodName] = (fieldName, opts) => {
      let fieldConfig = {
        type: typeName
      };
      if (typeof opts === "function") {
        throw new Error(messages.removedFunctionShorthand(block2.typeName, fieldName));
      } else {
        fieldConfig = Object.assign(Object.assign({}, fieldConfig), opts);
      }
      block2.field(fieldName, fieldConfig);
    };
  }
  walkOutputType(obj) {
    const definitionBlock = new ObjectDefinitionBlock({
      typeName: obj.name,
      addInterfaces: (i) => {
        i.forEach((j) => {
          if (typeof j !== "string") {
            this.addType(j);
          }
        });
      },
      addField: (f) => this.maybeTraverseOutputFieldType(f),
      addDynamicOutputMembers: (block2, wrapping10) => this.addDynamicOutputMembers(block2, "walk", wrapping10),
      addModification: (o) => this.maybeTraverseModification(o),
      warn: () => {
      }
    });
    obj.definition(definitionBlock);
    return obj;
  }
  walkInterfaceType(obj) {
    const definitionBlock = new InterfaceDefinitionBlock({
      typeName: obj.name,
      addModification: (o) => this.maybeTraverseModification(o),
      addInterfaces: (i) => {
        i.forEach((j) => {
          if (typeof j !== "string") {
            this.addType(j);
          }
        });
      },
      addField: (f) => this.maybeTraverseOutputFieldType(f),
      addDynamicOutputMembers: (block2, wrapping10) => this.addDynamicOutputMembers(block2, "walk", wrapping10),
      warn: () => {
      }
    });
    obj.definition(definitionBlock);
    return obj;
  }
  maybeTraverseModification(mod) {
    const { type, args: args6 } = mod;
    if (type) {
      const namedFieldType = getNexusNamedType(mod.type);
      if (typeof namedFieldType !== "string") {
        this.addType(namedFieldType);
      }
    }
    if (args6) {
      this.traverseArgs(args6);
    }
  }
  maybeTraverseOutputFieldType(type) {
    const { args: args6, type: fieldType } = type;
    const namedFieldType = getNexusNamedType(fieldType);
    if (typeof namedFieldType !== "string") {
      this.addType(namedFieldType);
    }
    if (args6) {
      this.traverseArgs(args6);
    }
  }
  traverseArgs(args6) {
    eachObj(args6, (val) => {
      const namedArgType = getArgNamedType(val);
      if (typeof namedArgType !== "string") {
        this.addType(namedArgType);
      }
    });
  }
  maybeTraverseInputFieldType(type) {
    const { type: fieldType } = type;
    const namedFieldType = getNexusNamedType(fieldType);
    if (typeof namedFieldType !== "string") {
      this.addType(namedFieldType);
    }
  }
  handleMergeSchema(config) {
    var _a;
    const { types } = config.schema.toConfig();
    const mergedTypes = {};
    for (const type of types) {
      if (type.name.startsWith("__")) {
        continue;
      }
      if ((_a = config.skipTypes) === null || _a === undefined ? undefined : _a.includes(type.name)) {
        continue;
      }
      mergedTypes[type.name] = this.handleNativeType(type, config);
    }
    return mergedTypes;
  }
  handleNativeType(type, config) {
    var _a;
    var _b, _c;
    while (isWrappingType(type)) {
      type = type.ofType;
    }
    (_a = (_b = this.pendingTypeMap)[_c = type.name]) !== null && _a !== undefined || (_b[_c] = null);
    return rebuildNamedType(type, config);
  }
}
// node_modules/nexus/dist-esm/typegenMetadata.js
import * as path3 from "path";

// node_modules/nexus/dist-esm/lang.js
var SDL_HEADER = `### This file was generated by Nexus Schema
### Do not make changes to this file directly
`;
var TYPEGEN_HEADER = `/**
 * This file was generated by Nexus Schema
 * Do not make changes to this file directly
 */
`;

// node_modules/nexus/dist-esm/typegenAutoConfig.js
import * as path from "path";
function typegenAutoConfig(options, contextType) {
  return (schema3, outputPath) => __awaiter(this, undefined, undefined, function* () {
    const { headers, skipTypes = ["Query", "Mutation", "Subscription"], mapping: _sourceTypeMap, debug } = options;
    const typeMap = schema3.getTypeMap();
    const typesToIgnore = new Set;
    const typesToIgnoreRegex = [];
    const allImportsMap = {};
    const importsMap = {};
    const sourceTypeMap = Object.assign(Object.assign({}, SCALAR_TYPES), _sourceTypeMap);
    const forceImports = new Set(objValues(sourceTypeMap).concat(typeof contextType === "string" ? contextType || "" : "").map((t) => {
      const match = t.match(/^(\w+)\./);
      return match ? match[1] : null;
    }).filter((f) => f));
    skipTypes.forEach((skip) => {
      if (typeof skip === "string") {
        typesToIgnore.add(skip);
      } else if (skip instanceof RegExp) {
        typesToIgnoreRegex.push(skip);
      } else {
        throw new Error("Invalid type for options.skipTypes, expected string or RegExp");
      }
    });
    const typeSources = yield Promise.all(options.modules.map((source2) => __awaiter(this, undefined, undefined, function* () {
      const fs2 = import.meta.require("fs");
      const util = import.meta.require("util");
      const readFile = util.promisify(fs2.readFile);
      const { module: pathOrModule, glob = true, onlyTypes, alias, typeMatch } = source2;
      if (path.isAbsolute(pathOrModule) && path.extname(pathOrModule) !== ".ts") {
        return console.warn(`Nexus Schema Typegen: Expected module ${pathOrModule} to be an absolute path to a TypeScript module, skipping.`);
      }
      let resolvedPath;
      let fileContents;
      try {
        resolvedPath = require.resolve(pathOrModule, {
          paths: [process.cwd()]
        });
        if (path.extname(resolvedPath) !== ".ts") {
          resolvedPath = findTypingForFile(resolvedPath, pathOrModule);
        }
        fileContents = yield readFile(resolvedPath, "utf-8");
      } catch (e) {
        if (e instanceof Error && e.message.indexOf("Cannot find module") !== -1) {
          console.error(`GraphQL Nexus: Unable to find file or module ${pathOrModule}, skipping`);
        } else {
          console.error(e.message);
        }
        return null;
      }
      const importPath = (path.isAbsolute(pathOrModule) ? relativePathTo(resolvedPath, outputPath) : pathOrModule).replace(typeScriptFileExtension, "");
      if (allImportsMap[alias] && allImportsMap[alias] !== importPath) {
        return console.warn(`Nexus Schema Typegen: Cannot have multiple type sources ${importsMap[alias]} and ${pathOrModule} with the same alias ${alias}, skipping`);
      }
      allImportsMap[alias] = importPath;
      if (forceImports.has(alias)) {
        importsMap[alias] = [importPath, glob];
        forceImports.delete(alias);
      }
      return {
        alias,
        glob,
        importPath,
        fileContents,
        onlyTypes,
        typeMatch: typeMatch || defaultTypeMatcher
      };
    })));
    const builtinScalars = new Set(Object.keys(SCALAR_TYPES));
    Object.keys(typeMap).forEach((typeName) => {
      if (typeName.startsWith("__")) {
        return;
      }
      if (typesToIgnore.has(typeName)) {
        return;
      }
      if (typesToIgnoreRegex.some((r) => r.test(typeName))) {
        return;
      }
      if (sourceTypeMap[typeName]) {
        return;
      }
      if (builtinScalars.has(typeName)) {
        return;
      }
      const type = schema3.getType(typeName);
      if (isOutputType(type)) {
        for (let i = 0;i < typeSources.length; i++) {
          const typeSource = typeSources[i];
          if (!typeSource) {
            continue;
          }
          if (typeSource.onlyTypes) {
            if (!typeSource.onlyTypes.some((t) => {
              return t instanceof RegExp ? t.test(typeName) : t === typeName;
            })) {
              continue;
            }
          }
          const { fileContents, importPath, glob, alias, typeMatch } = typeSource;
          const typeRegex = typeMatch(type, defaultTypeMatcher(type)[0]);
          const matched = firstMatch(fileContents, Array.isArray(typeRegex) ? typeRegex : [typeRegex]);
          if (matched) {
            if (debug) {
              log(`Matched type - ${typeName} in "${importPath}" - ${alias}.${matched[1]}`);
            }
            importsMap[alias] = [importPath, glob];
            sourceTypeMap[typeName] = `${alias}.${matched[1]}`;
          } else {
            if (debug) {
              log(`No match for ${typeName} in "${importPath}" using ${typeRegex}`);
            }
          }
        }
      }
    });
    if (forceImports.size > 0) {
      console.error(`Missing required typegen import: ${Array.from(forceImports)}`);
    }
    const imports = [];
    Object.keys(importsMap).sort().forEach((alias) => {
      const [importPath, glob] = importsMap[alias];
      const safeImportPath = importPath.replace(/\\+/g, "/");
      imports.push(`import type ${glob ? "* as " : ""}${alias} from "${safeImportPath}"`);
    });
    const typegenInfo = {
      headers: headers || [TYPEGEN_HEADER],
      sourceTypeMap,
      imports,
      contextTypeImport: contextType,
      nexusSchemaImportId: getOwnPackage().name
    };
    return typegenInfo;
  });
}
var findTypingForFile = function(absolutePath, pathOrModule) {
  try {
    const typeDefPath = absolutePath.replace(path.extname(absolutePath), ".d.ts");
    require.resolve(typeDefPath);
    return typeDefPath;
  } catch (e) {
    console.error(e);
  }
  throw new Error(`Unable to find typings associated with ${pathOrModule}, skipping`);
};
var SCALAR_TYPES = {
  Int: "number",
  String: "string",
  ID: "string",
  Float: "number",
  Boolean: "boolean"
};
var firstMatch = (fileContents, typeRegex) => {
  for (let i = 0;i < typeRegex.length; i++) {
    const regex = typeRegex[i];
    const match = regex.exec(fileContents);
    if (match) {
      return match;
    }
  }
  return null;
};
var defaultTypeMatcher = (type) => {
  return [new RegExp(`(?:interface|type|class|enum)\\s+(${type.name})\\W`, "g")];
};

// node_modules/nexus/dist-esm/typegenFormatPrettier.js
import * as path2 from "path";
function typegenFormatPrettier(prettierConfig) {
  return function formatTypegen(content, type) {
    return __awaiter(this, undefined, undefined, function* () {
      let prettier;
      try {
        prettier = (()=>{ throw new Error(`Cannot require module "prettier"`);})();
      } catch (_a) {
        console.warn("It looks like you provided a `prettierConfig` option to GraphQL Nexus, but you do not have prettier installed as a dependency in your project. Please add it as a peerDependency of nexus to use this feature. Skipping formatting.");
        return content;
      }
      let prettierConfigResolved;
      if (typeof prettierConfig === "string") {
        if (!path2.isAbsolute(prettierConfig)) {
          console.error(new Error(`Expected prettierrc path to be absolute, saw ${prettierConfig}. Skipping formatting.`));
          return content;
        }
        prettierConfigResolved = yield prettier.resolveConfig("ignore_this", {
          config: prettierConfig
        });
      } else {
        prettierConfigResolved = prettierConfig;
      }
      return prettier.format(content, Object.assign(Object.assign({}, prettierConfigResolved), { parser: type === "types" ? "typescript" : "graphql" }));
    });
  };
}

// node_modules/nexus/dist-esm/typegenPrinter.js
var padLeft = function(str, padding) {
  return str.split("\n").map((s) => `${padding}${s}`).join("\n");
};
var renderObject = function(object) {
  return [
    "{",
    mapObj(object, (val, key) => {
      return `    ${key}: ${val}`;
    }).join("\n"),
    "  }"
  ].join("\n");
};
var SpecifiedScalars = {
  ID: "string",
  String: "string",
  Float: "number",
  Int: "number",
  Boolean: "boolean"
};

class TypegenPrinter {
  constructor(schema3, typegenInfo) {
    this.schema = schema3;
    this.typegenInfo = typegenInfo;
    this.printObj = (space, source2) => (val, key) => {
      return [`${space}${key}: { // ${source2}`].concat(mapObj(val, (v2, k2) => {
        return `${space}  ${k2}${v2[0]} ${v2[1]}`;
      })).concat(`${space}}`).join("\n");
    };
    this.groupedTypes = groupTypes(schema3);
    this.printImports = {};
    this.hasDiscriminatedTypes = false;
  }
  print() {
    const body = [this.printCommon(), this.printPlugins()].join("\n\n");
    return [this.printHeaders(), body].join("\n\n");
  }
  printConfigured() {
    if (this.typegenInfo.globalsPath) {
      const plugins2 = this.printPlugins();
      const globalTypes = [this.printHeadersGlobal(), this.printDynamicImport(true), plugins2].join("\n\n");
      this.printImports = {};
      const common = this.printCommon();
      const tsTypes = [this.printHeadersCommon(), common].join("\n\n");
      return {
        tsTypes,
        globalTypes
      };
    }
    return {
      tsTypes: this.print(),
      globalTypes: null
    };
  }
  printCommon() {
    return [
      this.printInputTypeMap(),
      this.printEnumTypeMap(),
      this.printScalarTypeMap(),
      this.printObjectTypeMap(),
      this.printInterfaceTypeMap(),
      this.printUnionTypeMap(),
      this.printRootTypeDef(),
      this.printAllTypesMap(),
      this.printFieldTypesMap(),
      this.printFieldTypeNamesMap(),
      this.printArgTypeMap(),
      this.printAbstractTypeMembers(),
      this.printInheritedFieldMap(),
      this.printTypeNames("object", "NexusGenObjectNames", "NexusGenObjects"),
      this.printTypeNames("input", "NexusGenInputNames", "NexusGenInputs"),
      this.printTypeNames("enum", "NexusGenEnumNames", "NexusGenEnums"),
      this.printTypeNames("interface", "NexusGenInterfaceNames", "NexusGenInterfaces"),
      this.printTypeNames("scalar", "NexusGenScalarNames", "NexusGenScalars"),
      this.printTypeNames("union", "NexusGenUnionNames", "NexusGenUnions"),
      this.printIsTypeOfObjectTypeNames("NexusGenObjectsUsingAbstractStrategyIsTypeOf"),
      this.printResolveTypeAbstractTypes("NexusGenAbstractsUsingStrategyResolveType"),
      this.printFeaturesConfig("NexusGenFeaturesConfig"),
      this.printGenTypeMap()
    ].join("\n\n");
  }
  printHeaders() {
    return [this.printHeadersCommon(), this.printHeadersGlobal()].join("\n");
  }
  printHeadersCommon() {
    return [
      this.typegenInfo.headers.join("\n"),
      this.typegenInfo.imports.join("\n"),
      this.printDynamicImport()
    ].join("\n");
  }
  printHeadersGlobal() {
    var _a, _b;
    const headers = [
      this.printDynamicInputFieldDefinitions(),
      this.printDynamicOutputFieldDefinitions(),
      this.printDynamicOutputPropertyDefinitions(),
      GLOBAL_DECLARATION
    ];
    if (this.typegenInfo.globalsPath) {
      headers.unshift(`import type { NexusGenTypes } from '${relativePathTo(this.typegenInfo.typegenPath, (_a = this.typegenInfo.globalsPath) !== null && _a !== undefined ? _a : "")}'`);
      headers.unshift(...(_b = this.typegenInfo.globalsHeaders) !== null && _b !== undefined ? _b : []);
      headers.unshift(TYPEGEN_HEADER);
    }
    return headers.join("\n");
  }
  printGenTypeMap() {
    return [`export interface NexusGenTypes {`].concat([
      `  context: ${this.printContext()};`,
      `  inputTypes: NexusGenInputs;`,
      `  rootTypes: NexusGenRootTypes;`,
      `  inputTypeShapes: NexusGenInputs & NexusGenEnums & NexusGenScalars;`,
      `  argTypes: NexusGenArgTypes;`,
      `  fieldTypes: NexusGenFieldTypes;`,
      `  fieldTypeNames: NexusGenFieldTypeNames;`,
      `  allTypes: NexusGenAllTypes;`,
      `  typeInterfaces: NexusGenTypeInterfaces;`,
      `  objectNames: NexusGenObjectNames;`,
      `  inputNames: NexusGenInputNames;`,
      `  enumNames: NexusGenEnumNames;`,
      `  interfaceNames: NexusGenInterfaceNames;`,
      `  scalarNames: NexusGenScalarNames;`,
      `  unionNames: NexusGenUnionNames;`,
      `  allInputTypes: NexusGenTypes['inputNames'] | NexusGenTypes['enumNames'] | NexusGenTypes['scalarNames'];`,
      `  allOutputTypes: NexusGenTypes['objectNames'] | NexusGenTypes['enumNames'] | NexusGenTypes['unionNames'] | NexusGenTypes['interfaceNames'] | NexusGenTypes['scalarNames'];`,
      `  allNamedTypes: NexusGenTypes['allInputTypes'] | NexusGenTypes['allOutputTypes']`,
      `  abstractTypes: NexusGenTypes['interfaceNames'] | NexusGenTypes['unionNames'];`,
      `  abstractTypeMembers: NexusGenAbstractTypeMembers;`,
      `  objectsUsingAbstractStrategyIsTypeOf: NexusGenObjectsUsingAbstractStrategyIsTypeOf;`,
      `  abstractsUsingStrategyResolveType: NexusGenAbstractsUsingStrategyResolveType;`,
      `  features: NexusGenFeaturesConfig;`
    ]).concat("}").join("\n");
  }
  printDynamicImport(forGlobal = false) {
    var _a;
    const { sourceTypings } = this.schema.extensions.nexus.config;
    const { contextTypeImport } = this.typegenInfo;
    const imports = [];
    const importMap = {};
    const outputPath = this.typegenInfo.typegenPath;
    const nexusSchemaImportId = (_a = this.typegenInfo.nexusSchemaImportId) !== null && _a !== undefined ? _a : getOwnPackage().name;
    if (!this.printImports[nexusSchemaImportId]) {
      this.maybeAddCoreImport(forGlobal);
    }
    if (!forGlobal) {
      if (contextTypeImport) {
        const importPath = resolveImportPath(contextTypeImport, "context", outputPath);
        importMap[importPath] = importMap[importPath] || new Set;
        importMap[importPath].add(contextTypeImport.alias ? `${contextTypeImport.export} as ${contextTypeImport.alias}` : contextTypeImport.export);
      }
      eachObj(sourceTypings, (rootType, typeName) => {
        if (typeof rootType !== "string") {
          const importPath = resolveImportPath(rootType, typeName, outputPath);
          importMap[importPath] = importMap[importPath] || new Set;
          importMap[importPath].add(rootType.alias ? `${rootType.export} as ${rootType.alias}` : rootType.export);
        }
      });
      eachObj(importMap, (val, key) => {
        imports.push(`import type { ${Array.from(val).join(", ")} } from ${JSON.stringify(key)}`);
      });
    }
    eachObj(this.printImports, (val, key) => {
      const { default: def } = val, rest = __rest(val, ["default"]);
      const idents = [];
      if (def) {
        idents.push(def);
      }
      let bindings = [];
      eachObj(rest, (alias, binding) => {
        bindings.push(alias !== true ? `${binding} as ${alias}` : `${binding}`);
      });
      if (bindings.length) {
        idents.push(`{ ${bindings.join(", ")} }`);
      }
      imports.push(`import type ${idents.join(", ")} from ${JSON.stringify(key)}`);
    });
    return imports.join("\n");
  }
  maybeAddCoreImport(forGlobal = false) {
    var _a;
    const nexusSchemaImportId = (_a = this.typegenInfo.nexusSchemaImportId) !== null && _a !== undefined ? _a : getOwnPackage().name;
    const { dynamicFields: { dynamicInputFields, dynamicOutputFields } } = this.schema.extensions.nexus.config;
    let shouldAdd = false;
    const hasDynamicFields = [dynamicInputFields, dynamicOutputFields].some((o) => Object.keys(o).length > 0);
    if (!this.typegenInfo.globalsPath) {
      shouldAdd = hasDynamicFields || this.hasDiscriminatedTypes;
    } else {
      shouldAdd = forGlobal ? hasDynamicFields : this.hasDiscriminatedTypes;
    }
    if (shouldAdd) {
      this.printImports[nexusSchemaImportId] = {
        core: true
      };
    }
  }
  printDynamicInputFieldDefinitions() {
    const { dynamicInputFields } = this.schema.extensions.nexus.config.dynamicFields;
    if (!Object.keys(dynamicInputFields).length) {
      return [];
    }
    return [`declare global {`, `  interface NexusGenCustomInputMethods<TypeName extends string> {`].concat(mapObj(dynamicInputFields, (val, key) => {
      if (typeof val === "string") {
        const baseType = this.schema.getType(val);
        return this.prependDoc(`    ${key}<FieldName extends string>(fieldName: FieldName, opts?: core.CommonInputFieldConfig<TypeName, FieldName>): void // ${JSON.stringify(val)};`, baseType === null || baseType === undefined ? undefined : baseType.description);
      }
      return this.prependDoc(`    ${key}${val.value.typeDefinition || `(...args: any): void`}`, val.value.typeDescription);
    })).concat([`  }`, `}`]).join("\n");
  }
  printDynamicOutputFieldDefinitions() {
    const { dynamicOutputFields } = this.schema.extensions.nexus.config.dynamicFields;
    if (!Object.keys(dynamicOutputFields).length) {
      return [];
    }
    return [`declare global {`, `  interface NexusGenCustomOutputMethods<TypeName extends string> {`].concat(mapObj(dynamicOutputFields, (val, key) => {
      if (typeof val === "string") {
        const baseType = this.schema.getType(val);
        return this.prependDoc(`    ${key}<FieldName extends string>(fieldName: FieldName, ...opts: core.ScalarOutSpread<TypeName, FieldName>): void // ${JSON.stringify(val)};`, baseType === null || baseType === undefined ? undefined : baseType.description);
      }
      return this.prependDoc(`    ${key}${val.value.typeDefinition || `(...args: any): void`}`, val.value.typeDescription);
    })).concat([`  }`, `}`]).join("\n");
  }
  prependDoc(typeDef, typeDescription) {
    let outStr = "";
    if (typeDescription) {
      let parts = typeDescription.split("\n").map((f) => f.trimLeft());
      if (parts[0] === "") {
        parts = parts.slice(1);
      }
      if (parts[parts.length - 1] === "") {
        parts = parts.slice(0, -1);
      }
      outStr = ["    /**", ...parts.map((p) => `     *${p ? ` ${p}` : ""}`), "     */"].join("\n") + "\n";
    }
    return `${outStr}${typeDef}`;
  }
  printDynamicOutputPropertyDefinitions() {
    const { dynamicOutputProperties } = this.schema.extensions.nexus.config.dynamicFields;
    if (!Object.keys(dynamicOutputProperties).length) {
      return [];
    }
    return [`declare global {`, `  interface NexusGenCustomOutputProperties<TypeName extends string> {`].concat(mapObj(dynamicOutputProperties, (val, key) => {
      return this.prependDoc(`    ${key}${val.value.typeDefinition || `: any`}`, val.value.typeDescription);
    })).concat([`  }`, `}`]).join("\n");
  }
  printInheritedFieldMap() {
    const hasInterfaces = [];
    const withInterfaces = hasInterfaces.concat(this.groupedTypes.object, this.groupedTypes.interface.map(graphql15InterfaceType)).map((o) => {
      if (o.getInterfaces().length) {
        return [o.name, o.getInterfaces().map((i) => i.name)];
      }
      return null;
    }).filter((f) => f);
    return ["export interface NexusGenTypeInterfaces {"].concat(withInterfaces.map(([name, interfaces]) => {
      return `  ${name}: ${interfaces.map((i) => JSON.stringify(i)).join(" | ")}`;
    })).concat("}").join("\n");
  }
  printContext() {
    var _a, _b;
    return ((_a = this.typegenInfo.contextTypeImport) === null || _a === undefined ? undefined : _a.alias) || ((_b = this.typegenInfo.contextTypeImport) === null || _b === undefined ? undefined : _b.export) || "any";
  }
  printAbstractTypeMembers() {
    return this.printTypeInterface("NexusGenAbstractTypeMembers", this.buildAbstractTypeMembers());
  }
  buildAbstractTypeMembers() {
    const sourceMap = {};
    const abstractTypes = [];
    abstractTypes.concat(this.groupedTypes.union).concat(this.groupedTypes.interface).forEach((type) => {
      if (isInterfaceType(type)) {
        const possibleNames = this.schema.getPossibleTypes(type).map((t) => t.name);
        if (possibleNames.length > 0) {
          sourceMap[type.name] = possibleNames.map((val) => JSON.stringify(val)).join(" | ");
        }
      } else {
        sourceMap[type.name] = type.getTypes().map((t) => JSON.stringify(t.name)).join(" | ");
      }
    });
    return sourceMap;
  }
  printTypeNames(name, exportName, source2) {
    const obj = this.groupedTypes[name];
    const typeDef = obj.length === 0 ? "never" : `keyof ${source2}`;
    return `export type ${exportName} = ${typeDef};`;
  }
  printIsTypeOfObjectTypeNames(exportName) {
    const objectTypes = this.groupedTypes.object.filter((o) => o.isTypeOf !== undefined);
    const typeDef = objectTypes.length === 0 ? "never" : objectTypes.map((o) => JSON.stringify(o.name)).sort().join(" | ");
    return `export type ${exportName} = ${typeDef};`;
  }
  printResolveTypeAbstractTypes(exportName) {
    const abstractTypes = [...this.groupedTypes.interface, ...this.groupedTypes.union].filter((o) => o.resolveType !== undefined);
    const typeDef = abstractTypes.length === 0 ? "never" : abstractTypes.map((o) => JSON.stringify(o.name)).sort().join(" | ");
    return `export type ${exportName} = ${typeDef};`;
  }
  printFeaturesConfig(exportName) {
    var _a, _b;
    const abstractTypes = (_b = (_a = this.schema.extensions.nexus.config.features) === null || _a === undefined ? undefined : _a.abstractTypeStrategies) !== null && _b !== undefined ? _b : {};
    const unionProps = renderObject(mapValues(abstractTypes, (val) => val !== null && val !== undefined ? val : false));
    return [`export type ${exportName} = {`].concat(`  abstractTypeStrategies: ${unionProps}`).concat("}").join("\n");
  }
  buildEnumTypeMap() {
    const enumMap = {};
    this.groupedTypes.enum.forEach((e) => {
      const sourceType = this.resolveSourceType(e.name);
      if (sourceType) {
        enumMap[e.name] = sourceType;
      } else {
        const values2 = e.getValues().map((val) => JSON.stringify(val.value));
        enumMap[e.name] = values2.join(" | ");
      }
    });
    return enumMap;
  }
  buildInputTypeMap() {
    const inputObjMap = {};
    this.groupedTypes.input.forEach((input) => {
      eachObj(input.getFields(), (field) => {
        inputObjMap[input.name] = inputObjMap[input.name] || {};
        inputObjMap[input.name][field.name] = this.normalizeArg(field);
      });
    });
    return inputObjMap;
  }
  buildScalarTypeMap() {
    const scalarMap = {};
    this.groupedTypes.scalar.forEach((e) => {
      var _a;
      if (isSpecifiedScalarType(e)) {
        scalarMap[e.name] = (_a = this.resolveSourceType(e.name)) !== null && _a !== undefined ? _a : SpecifiedScalars[e.name];
        return;
      }
      const sourceType = this.resolveSourceType(e.name);
      if (sourceType) {
        scalarMap[e.name] = sourceType;
      } else {
        scalarMap[e.name] = "any";
      }
    });
    return scalarMap;
  }
  printInputTypeMap() {
    const inputTypeMap = this.buildInputTypeMap();
    if (this.typegenInfo.declareInputs) {
      const declaredInputs = mapObj(inputTypeMap, (fields, inputName) => this.printNamedObj(inputName, fields));
      return [...declaredInputs, this.printNamedMap("NexusGenInputs", inputTypeMap)].join("\n\n");
    }
    return this.printTypeFieldInterface("NexusGenInputs", inputTypeMap, "input type");
  }
  printEnumTypeMap() {
    const enumTypeMap = this.buildEnumTypeMap();
    if (this.typegenInfo.declareInputs) {
      return [
        ...mapObj(enumTypeMap, (val, name) => `export type ${name} = ${val}`),
        this.printNamedMap("NexusGenEnums", enumTypeMap)
      ].join("\n\n");
    }
    return this.printTypeInterface("NexusGenEnums", enumTypeMap);
  }
  printScalarTypeMap() {
    return this.printTypeInterface("NexusGenScalars", this.buildScalarTypeMap());
  }
  shouldDiscriminateType(abstractType, objectType5) {
    var _a, _b;
    if (!((_b = (_a = this.schema.extensions.nexus.config.features) === null || _a === undefined ? undefined : _a.abstractTypeStrategies) === null || _b === undefined ? undefined : _b.__typename)) {
      return false;
    }
    if (abstractType.resolveType !== undefined) {
      return "optional";
    }
    if (objectType5.isTypeOf !== undefined) {
      return "optional";
    }
    return "required";
  }
  maybeDiscriminate(abstractType, objectType5) {
    const requiredOrOptional = this.shouldDiscriminateType(abstractType, objectType5);
    if (requiredOrOptional === false) {
      return `NexusGenRootTypes['${objectType5.name}']`;
    }
    this.hasDiscriminatedTypes = true;
    return `core.Discriminate<'${objectType5.name}', '${requiredOrOptional}'>`;
  }
  buildRootTypeMap(hasFields) {
    const rootTypeMap = {};
    hasFields.forEach((type) => {
      const rootTyping = this.resolveSourceType(type.name);
      if (rootTyping) {
        rootTypeMap[type.name] = rootTyping;
        return;
      }
      if (isUnionType(type)) {
        rootTypeMap[type.name] = type.getTypes().map((t) => this.maybeDiscriminate(type, t)).join(" | ");
      } else if (isInterfaceType(type)) {
        const possibleRoots = this.schema.getPossibleTypes(type).map((t) => this.maybeDiscriminate(type, t));
        if (possibleRoots.length > 0) {
          rootTypeMap[type.name] = possibleRoots.join(" | ");
        } else {
          rootTypeMap[type.name] = "any";
        }
      } else if (type.name === "Query" || type.name === "Mutation") {
        rootTypeMap[type.name] = "{}";
      } else {
        eachObj(type.getFields(), (field) => {
          const obj = rootTypeMap[type.name] = rootTypeMap[type.name] || {};
          if (!this.hasResolver(field, type)) {
            if (typeof obj !== "string") {
              obj[field.name] = [
                this.argSeparator(field.type, false),
                this.printOutputType(field.type)
              ];
            }
          }
        });
      }
    });
    return rootTypeMap;
  }
  resolveSourceType(typeName) {
    const rootTyping = this.schema.extensions.nexus.config.sourceTypings[typeName];
    if (rootTyping) {
      return typeof rootTyping === "string" ? rootTyping : rootTyping.export;
    }
    return this.typegenInfo.sourceTypeMap[typeName];
  }
  hasResolver(field, _type) {
    if (field.extensions && hasNexusExtension(field.extensions.nexus)) {
      return field.extensions.nexus.hasDefinedResolver;
    }
    return Boolean(field.resolve);
  }
  printObjectTypeMap() {
    return this.printRootTypeFieldInterface("NexusGenObjects", this.buildRootTypeMap(this.groupedTypes.object));
  }
  printInterfaceTypeMap() {
    return this.printRootTypeFieldInterface("NexusGenInterfaces", this.buildRootTypeMap(this.groupedTypes.interface));
  }
  printUnionTypeMap() {
    return this.printRootTypeFieldInterface("NexusGenUnions", this.buildRootTypeMap(this.groupedTypes.union));
  }
  printRootTypeDef() {
    const toJoin = [];
    if (this.groupedTypes.interface.length) {
      toJoin.push("NexusGenInterfaces");
    }
    if (this.groupedTypes.object.length) {
      toJoin.push("NexusGenObjects");
    }
    if (this.groupedTypes.union.length) {
      toJoin.push("NexusGenUnions");
    }
    return `export type NexusGenRootTypes = ${toJoin.join(" & ")}`;
  }
  printAllTypesMap() {
    const toJoin = ["NexusGenRootTypes"];
    if (this.groupedTypes.scalar.length) {
      toJoin.push("NexusGenScalars");
    }
    if (this.groupedTypes.enum.length) {
      toJoin.push("NexusGenEnums");
    }
    return `export type NexusGenAllTypes = ${toJoin.join(" & ")}`;
  }
  buildArgTypeMap() {
    const argTypeMap = {};
    const hasFields = [];
    hasFields.concat(this.groupedTypes.object).concat(this.groupedTypes.interface).forEach((type) => {
      eachObj(type.getFields(), (field) => {
        if (field.args.length > 0) {
          argTypeMap[type.name] = argTypeMap[type.name] || {};
          argTypeMap[type.name][field.name] = field.args.reduce((obj, arg2) => {
            obj[arg2.name] = this.normalizeArg(arg2);
            return obj;
          }, {});
        }
      });
    });
    return argTypeMap;
  }
  printArgTypeMap() {
    const argTypeMap = this.buildArgTypeMap();
    if (this.typegenInfo.declareInputs) {
      const declaredArgs = [];
      eachObj(argTypeMap, (fields, typeName) => {
        eachObj(fields, (args6, fieldName) => {
          declaredArgs.push(this.printNamedObj(this.getArgsName(typeName, fieldName), args6));
        });
      });
      return [...declaredArgs, this.printArgTypeFieldInterface(argTypeMap)].join("\n\n");
    }
    return this.printArgTypeFieldInterface(argTypeMap);
  }
  getArgsName(typeName, fieldName) {
    return `${typeName}${fieldName.slice(0, 1).toUpperCase().concat(fieldName.slice(1))}Args`;
  }
  printNamedObj(name, obj) {
    return [
      `export interface ${name} {`,
      ...mapObj(obj, (val, key) => `  ${key}${val[0]} ${val[1]}`),
      `}`
    ].join("\n");
  }
  printNamedMap(name, obj) {
    return [`export interface ${name} {`, ...mapObj(obj, (val, key) => `  ${key}: ${key}`), `}`].join("\n");
  }
  buildReturnTypeMap() {
    const returnTypeMap = {};
    const hasFields = [];
    hasFields.concat(this.groupedTypes.object).concat(this.groupedTypes.interface).forEach((type) => {
      eachObj(type.getFields(), (field) => {
        returnTypeMap[type.name] = returnTypeMap[type.name] || {};
        returnTypeMap[type.name][field.name] = [":", this.printOutputType(field.type)];
      });
    });
    return returnTypeMap;
  }
  buildReturnTypeNamesMap() {
    const returnTypeMap = {};
    const hasFields = [];
    hasFields.concat(this.groupedTypes.object).concat(this.groupedTypes.interface).forEach((type) => {
      eachObj(type.getFields(), (field) => {
        returnTypeMap[type.name] = returnTypeMap[type.name] || {};
        returnTypeMap[type.name][field.name] = [":", `'${getNamedType(field.type).name}'`];
      });
    });
    return returnTypeMap;
  }
  printOutputType(type) {
    const returnType = this.typeToArr(type);
    function combine(item) {
      if (item.length === 1) {
        if (Array.isArray(item[0])) {
          const toPrint = combine(item[0]);
          return toPrint.indexOf("null") === -1 ? `${toPrint}[]` : `Array<${toPrint}>`;
        }
        return item[0];
      }
      if (Array.isArray(item[1])) {
        const toPrint = combine(item[1]);
        return toPrint.indexOf("null") === -1 ? `${toPrint}[] | null` : `Array<${toPrint}> | null`;
      }
      return `${item[1]} | null`;
    }
    return `${combine(returnType)}; // ${type}`;
  }
  typeToArr(type) {
    const typing = [];
    if (isNonNullType(type)) {
      type = type.ofType;
    } else {
      typing.push(null);
    }
    if (isListType(type)) {
      typing.push(this.typeToArr(type.ofType));
    } else if (isScalarType(type)) {
      typing.push(this.printScalar(type));
    } else if (isEnumType(type)) {
      if (this.typegenInfo.declareInputs) {
        typing.push(type.name);
      } else {
        typing.push(`NexusGenEnums['${type.name}']`);
      }
    } else if (isObjectType(type) || isInterfaceType(type) || isUnionType(type)) {
      typing.push(`NexusGenRootTypes['${type.name}']`);
    }
    return typing;
  }
  printFieldTypesMap() {
    return this.printTypeFieldInterface("NexusGenFieldTypes", this.buildReturnTypeMap(), "field return type");
  }
  printFieldTypeNamesMap() {
    return this.printTypeFieldInterface("NexusGenFieldTypeNames", this.buildReturnTypeNamesMap(), "field return type name");
  }
  normalizeArg(arg2) {
    return [this.argSeparator(arg2.type, Boolean(arg2.defaultValue)), this.argTypeRepresentation(arg2.type)];
  }
  argSeparator(type, hasDefaultValue) {
    if (hasDefaultValue || isNonNullType(type)) {
      return ":";
    }
    return "?:";
  }
  argTypeRepresentation(arg2) {
    const argType = this.argTypeArr(arg2);
    function combine(item) {
      if (item.length === 1) {
        if (Array.isArray(item[0])) {
          const toPrint = combine(item[0]);
          return toPrint.indexOf("null") === -1 ? `${toPrint}[]` : `Array<${toPrint}>`;
        }
        return item[0];
      }
      if (Array.isArray(item[1])) {
        const toPrint = combine(item[1]);
        return toPrint.indexOf("null") === -1 ? `${toPrint}[] | null` : `Array<${toPrint}> | null`;
      }
      return `${item[1]} | null`;
    }
    return `${combine(argType)}; // ${arg2}`;
  }
  argTypeArr(arg2) {
    const typing = [];
    if (isNonNullType(arg2)) {
      arg2 = arg2.ofType;
    } else {
      typing.push(null);
    }
    if (isListType(arg2)) {
      typing.push(this.argTypeArr(arg2.ofType));
    } else if (isScalarType(arg2)) {
      typing.push(this.printScalar(arg2));
    } else if (isEnumType(arg2)) {
      if (this.typegenInfo.declareInputs) {
        typing.push(arg2.name);
      } else {
        typing.push(`NexusGenEnums['${arg2.name}']`);
      }
    } else if (isInputObjectType(arg2)) {
      if (this.typegenInfo.declareInputs) {
        typing.push(arg2.name);
      } else {
        typing.push(`NexusGenInputs['${arg2.name}']`);
      }
    }
    return typing;
  }
  printTypeInterface(interfaceName, typeMapping) {
    return [`export interface ${interfaceName} {`].concat(mapObj(typeMapping, (val, key) => `  ${key}: ${val}`)).concat("}").join("\n");
  }
  printRootTypeFieldInterface(interfaceName, typeMapping) {
    return [`export interface ${interfaceName} {`].concat(mapObj(typeMapping, (val, key) => {
      if (typeof val === "string") {
        return `  ${key}: ${val};`;
      }
      if (Object.keys(val).length === 0) {
        return `  ${key}: {};`;
      }
      return this.printObj("  ", "root type")(val, key);
    })).concat("}").join("\n");
  }
  printTypeFieldInterface(interfaceName, typeMapping, source2) {
    return [`export interface ${interfaceName} {`].concat(mapObj(typeMapping, this.printObj("  ", source2))).concat("}").join("\n");
  }
  printArgTypeFieldInterface(typeMapping) {
    return [`export interface NexusGenArgTypes {`].concat(mapObj(typeMapping, (val, typeName) => {
      if (this.typegenInfo.declareInputs) {
        return [`  ${typeName}: {`].concat(mapObj(val, (_, fieldName) => `    ${fieldName}: ${this.getArgsName(typeName, fieldName)}`)).concat("  }").join("\n");
      }
      return [`  ${typeName}: {`].concat(mapObj(val, this.printObj("    ", "args"))).concat("  }").join("\n");
    })).concat("}").join("\n");
  }
  printScalar(type) {
    var _a;
    if (isSpecifiedScalarType(type)) {
      return (_a = this.resolveSourceType(type.name)) !== null && _a !== undefined ? _a : SpecifiedScalars[type.name];
    }
    return `NexusGenScalars['${type.name}']`;
  }
  printPlugins() {
    const pluginFieldExt = [
      `  interface NexusGenPluginFieldConfig<TypeName extends string, FieldName extends string> {`
    ];
    const pluginInputFieldExt = [
      `  interface NexusGenPluginInputFieldConfig<TypeName extends string, FieldName extends string> {`
    ];
    const pluginArgExt = [`  interface NexusGenPluginArgConfig {`];
    const pluginSchemaExt = [`  interface NexusGenPluginSchemaConfig {`];
    const pluginTypeExt = [`  interface NexusGenPluginTypeConfig<TypeName extends string> {`];
    const pluginInputTypeExt = [
      `  interface NexusGenPluginInputTypeConfig<TypeName extends string> {`
    ];
    const printInlineDefs = [];
    const plugins2 = this.schema.extensions.nexus.config.plugins || [];
    plugins2.forEach((plugin8) => {
      if (plugin8.config.fieldDefTypes) {
        pluginFieldExt.push(padLeft(this.printType(plugin8.config.fieldDefTypes), "    "));
      }
      if (plugin8.config.inputFieldDefTypes) {
        pluginInputFieldExt.push(padLeft(this.printType(plugin8.config.inputFieldDefTypes), "    "));
      }
      if (plugin8.config.objectTypeDefTypes) {
        pluginTypeExt.push(padLeft(this.printType(plugin8.config.objectTypeDefTypes), "    "));
      }
      if (plugin8.config.inputObjectTypeDefTypes) {
        pluginInputTypeExt.push(padLeft(this.printType(plugin8.config.inputObjectTypeDefTypes), "    "));
      }
      if (plugin8.config.argTypeDefTypes) {
        pluginArgExt.push(padLeft(this.printType(plugin8.config.argTypeDefTypes), "    "));
      }
    });
    return [
      printInlineDefs.join("\n"),
      [
        "declare global {",
        [
          pluginTypeExt.concat("  }").join("\n"),
          pluginInputTypeExt.concat("  }").join("\n"),
          pluginFieldExt.concat("  }").join("\n"),
          pluginInputFieldExt.concat("  }").join("\n"),
          pluginSchemaExt.concat("  }").join("\n"),
          pluginArgExt.concat("  }").join("\n")
        ].join("\n"),
        "}"
      ].join("\n")
    ].join("\n");
  }
  printType(strLike) {
    if (Array.isArray(strLike)) {
      return strLike.map((s) => this.printType(s)).join("\n");
    }
    if (isNexusPrintedGenTyping(strLike)) {
      strLike.imports.forEach((i) => {
        this.addImport(i);
      });
      return strLike.toString();
    }
    if (isNexusPrintedGenTypingImport(strLike)) {
      this.addImport(strLike);
      return "";
    }
    return strLike;
  }
  addImport(i) {
    if (!isNexusPrintedGenTypingImport(i)) {
      console.warn(`Expected printedGenTypingImport, saw ${i}`);
      return;
    }
    this.printImports[i.config.module] = this.printImports[i.config.module] || {};
    if (i.config.default) {
      this.printImports[i.config.module].default = i.config.default;
    }
    if (i.config.bindings) {
      i.config.bindings.forEach((binding) => {
        if (typeof binding === "string") {
          this.printImports[i.config.module][binding] = true;
        } else {
          this.printImports[i.config.module][binding[0]] = binding[1];
        }
      });
    }
  }
}
var GLOBAL_DECLARATION = `
declare global {
  interface NexusGen extends NexusGenTypes {}
}`;

// node_modules/nexus/dist-esm/typegenMetadata.js
class TypegenMetadata {
  constructor(config) {
    this.config = config;
  }
  generateArtifacts(schema3) {
    return __awaiter(this, undefined, undefined, function* () {
      const sortedSchema = this.sortSchema(schema3);
      const { typegen } = this.config.outputs;
      if (this.config.outputs.schema || typegen) {
        const { schemaTypes, tsTypes, globalTypes } = yield this.generateArtifactContents(sortedSchema, typegen);
        if (this.config.outputs.schema) {
          yield this.writeFile("schema", schemaTypes, this.config.outputs.schema);
        }
        if (typegen) {
          if (typeof typegen === "string") {
            yield this.writeFile("types", tsTypes, typegen);
          } else {
            yield this.writeFile("types", tsTypes, typegen.outputPath);
            if (typeof typegen.globalsPath === "string") {
              yield this.writeFile("types", globalTypes !== null && globalTypes !== undefined ? globalTypes : "", typegen.globalsPath);
            }
          }
        }
      }
    });
  }
  generateArtifactContents(schema3, typegen) {
    return __awaiter(this, undefined, undefined, function* () {
      const result = {
        schemaTypes: this.generateSchemaFile(schema3),
        tsTypes: "",
        globalTypes: null
      };
      if (!typegen) {
        return result;
      }
      if (typeof typegen === "string") {
        result.tsTypes = yield this.generateTypesFile(schema3, typegen);
      } else {
        const generateResult = yield this.generateConfiguredTypes(schema3, typegen);
        result.tsTypes = generateResult.tsTypes;
        result.globalTypes = generateResult.globalTypes;
      }
      return result;
    });
  }
  sortSchema(schema3) {
    let sortedSchema = schema3;
    if (typeof lexicographicSortSchema !== "undefined") {
      sortedSchema = lexicographicSortSchema(schema3);
    }
    return sortedSchema;
  }
  writeFile(type, output, filePath) {
    return __awaiter(this, undefined, undefined, function* () {
      if (typeof filePath !== "string" || !path3.isAbsolute(filePath)) {
        return Promise.reject(new Error(`Expected an absolute path to output the Nexus ${type}, saw ${filePath}`));
      }
      const fs2 = import.meta.require("fs");
      const util = import.meta.require("util");
      const [readFile, writeFile, removeFile, mkdir] = [
        util.promisify(fs2.readFile),
        util.promisify(fs2.writeFile),
        util.promisify(fs2.unlink),
        util.promisify(fs2.mkdir)
      ];
      let formatTypegen = null;
      if (typeof this.config.formatTypegen === "function") {
        formatTypegen = this.config.formatTypegen;
      } else if (this.config.prettierConfig) {
        formatTypegen = typegenFormatPrettier(this.config.prettierConfig);
      }
      const content = typeof formatTypegen === "function" ? yield formatTypegen(output, type) : output;
      const [toSave, existing] = yield Promise.all([content, readFile(filePath, "utf8").catch(() => "")]);
      if (toSave !== existing) {
        const dirPath = path3.dirname(filePath);
        try {
          yield mkdir(dirPath, { recursive: true });
        } catch (e) {
          if (e.code !== "EEXIST") {
            throw e;
          }
        }
        try {
          yield removeFile(filePath);
        } catch (e) {
          if (e.code !== "ENOENT" && e.code !== "ENOTDIR") {
            throw e;
          }
        }
        return writeFile(filePath, toSave);
      }
    });
  }
  generateSchemaFile(schema3) {
    let printedSchema = this.config.customPrintSchemaFn ? this.config.customPrintSchemaFn(schema3) : printSchema(schema3);
    return [SDL_HEADER, printedSchema].join("\n\n");
  }
  generateTypesFile(schema3, typegenPath) {
    return __awaiter(this, undefined, undefined, function* () {
      const typegenInfo = yield this.getTypegenInfo(schema3, typegenPath);
      return new TypegenPrinter(schema3, Object.assign(Object.assign({ declareInputs: false }, typegenInfo), { typegenPath })).print();
    });
  }
  generateConfiguredTypes(schema3, typegen) {
    return __awaiter(this, undefined, undefined, function* () {
      const { outputPath: typegenPath, globalsPath, globalsHeaders, declareInputs = false } = typegen;
      const typegenInfo = yield this.getTypegenInfo(schema3, typegenPath);
      return new TypegenPrinter(schema3, Object.assign(Object.assign({}, typegenInfo), {
        typegenPath,
        globalsPath,
        globalsHeaders,
        declareInputs
      })).printConfigured();
    });
  }
  getTypegenInfo(schema3, typegenPath) {
    var _a;
    return __awaiter(this, undefined, undefined, function* () {
      if ("typegenConfig" in this.config) {
        throw new Error("Error: typegenConfig was removed from the API. Please open an issue if you were using it.");
      }
      if (this.config.sourceTypes) {
        return typegenAutoConfig(this.config.sourceTypes, this.config.contextType)(schema3, typegenPath || ((_a = this.config.outputs.typegen) === null || _a === undefined ? undefined : _a.outputPath) || "");
      }
      return {
        nexusSchemaImportId: this.config.nexusSchemaImportId,
        headers: [TYPEGEN_HEADER],
        imports: [],
        contextTypeImport: this.config.contextType,
        sourceTypeMap: {}
      };
    });
  }
}

// node_modules/nexus/dist-esm/typegenUtils.js
import * as path4 from "path";
function resolveTypegenConfig(config) {
  const { outputs, shouldGenerateArtifacts = Boolean(true) } = config, rest = __rest(config, ["outputs", "shouldGenerateArtifacts"]);
  const defaultSDLFilePath = path4.join(process.cwd(), "schema.graphql");
  let typegenFilePath = null;
  let sdlFilePath = null;
  if (outputs === undefined) {
    if (isProductionStage()) {
      sdlFilePath = defaultSDLFilePath;
    }
  } else if (outputs === true) {
    sdlFilePath = defaultSDLFilePath;
  } else if (typeof outputs === "object") {
    if (outputs.schema === true) {
      sdlFilePath = defaultSDLFilePath;
    } else if (typeof outputs.schema === "string") {
      sdlFilePath = assertAbsolutePath(outputs.schema, "outputs.schema");
    } else if (outputs.schema === undefined && isProductionStage()) {
    }
    if (typeof outputs.typegen === "string") {
      typegenFilePath = {
        outputPath: assertAbsolutePath(outputs.typegen, "outputs.typegen")
      };
    } else if (typeof outputs.typegen === "object") {
      typegenFilePath = Object.assign(Object.assign({}, outputs.typegen), { outputPath: assertAbsolutePath(outputs.typegen.outputPath, "outputs.typegen.outputPath") });
      if (outputs.typegen.globalsPath) {
        typegenFilePath.globalsPath = assertAbsolutePath(outputs.typegen.globalsPath, "outputs.typegen.globalsPath");
      }
    }
  } else if (outputs !== false) {
    console.warn(`You should specify a configuration value for outputs in Nexus' makeSchema. Provide one to remove this warning.`);
  }
  return Object.assign(Object.assign({}, rest), { nexusSchemaImportId: getOwnPackage().name, outputs: {
    typegen: shouldGenerateArtifacts ? typegenFilePath : null,
    schema: shouldGenerateArtifacts ? sdlFilePath : null
  } });
}

// node_modules/nexus/dist-esm/makeSchema.js
function makeSchema(config) {
  const { schema: schema3, missingTypes, finalConfig } = makeSchemaInternal(config);
  const typegenConfig = resolveTypegenConfig(finalConfig);
  const sdl = typegenConfig.outputs.schema;
  const typegen = typegenConfig.outputs.typegen;
  if (sdl || typegen) {
    const typegenPromise = new TypegenMetadata(typegenConfig).generateArtifacts(schema3);
    if (config.shouldExitAfterGenerateArtifacts) {
      let typegenPath = "(not enabled)";
      if (typegenConfig.outputs.typegen) {
        typegenPath = typegenConfig.outputs.typegen.outputPath;
        if (typegenConfig.outputs.typegen.globalsPath) {
          typegenPath += ` / ${typegenConfig.outputs.typegen.globalsPath}`;
        }
      }
      typegenPromise.then(() => {
        console.log(`Generated Artifacts:
          TypeScript Types  ==> ${typegenPath}
          GraphQL Schema    ==> ${typegenConfig.outputs.schema || "(not enabled)"}`);
        process.exit(0);
      }).catch((e) => {
        console.error(e);
        process.exit(1);
      });
    } else {
      typegenPromise.catch((e) => {
        console.error(e);
      });
    }
  }
  assertNoMissingTypes(schema3, missingTypes);
  runAbstractTypeRuntimeChecks(schema3, finalConfig.features);
  return schema3;
}
function generateSchema(config) {
  return __awaiter(this, undefined, undefined, function* () {
    const { schema: schema3, missingTypes, finalConfig } = makeSchemaInternal(config);
    const typegenConfig = resolveTypegenConfig(finalConfig);
    yield new TypegenMetadata(typegenConfig).generateArtifacts(schema3);
    assertNoMissingTypes(schema3, missingTypes);
    runAbstractTypeRuntimeChecks(schema3, finalConfig.features);
    return schema3;
  });
}
generateSchema.withArtifacts = (config, typegen = null) => __awaiter(undefined, undefined, undefined, function* () {
  const { schema: schema3, missingTypes, finalConfig } = makeSchemaInternal(config);
  const typegenConfig = resolveTypegenConfig(finalConfig);
  const { schemaTypes, tsTypes, globalTypes } = yield new TypegenMetadata(typegenConfig).generateArtifactContents(schema3, typegen);
  assertNoMissingTypes(schema3, missingTypes);
  runAbstractTypeRuntimeChecks(schema3, finalConfig.features);
  return { schema: schema3, schemaTypes, tsTypes, globalTypes };
});
// node_modules/nexus/dist-esm/definitions/extendInputType.js
class NexusExtendInputTypeDef {
  constructor(name, config) {
    this.name = name;
    this.config = config;
    assertValidName(name);
  }
  get value() {
    return this.config;
  }
}
withNexusSymbol(NexusExtendInputTypeDef, NexusTypes.ExtendInputObject);
// node_modules/nexus/dist-esm/definitions/extendType.js
class NexusExtendTypeDef {
  constructor(name, config) {
    this.name = name;
    this.config = config;
    assertValidName(name);
  }
  get value() {
    return this.config;
  }
}
withNexusSymbol(NexusExtendTypeDef, NexusTypes.ExtendObject);
// node_modules/nexus/dist-esm/definitions/queryType.js
function queryType(config) {
  return objectType(Object.assign(Object.assign({}, config), { name: "Query" }));
}
// node_modules/nexus/dist-esm/definitions/subscriptionType.js
function subscriptionType(config) {
  return objectType(Object.assign(Object.assign({}, config), { name: "Subscription" }));
}
// node_modules/nexus/dist-esm/dynamicProperty.js
class DynamicOutputPropertyDef {
  constructor(name, config) {
    this.name = name;
    this.config = config;
  }
  get value() {
    return this.config;
  }
}
withNexusSymbol(DynamicOutputPropertyDef, NexusTypes.DynamicOutputProperty);
// src/schema/mod.ts
import {join as join5} from "path";

// src/constants.ts
import {join as join4} from "path";
var __dirname = "/home/Developer/hackernews_gql/src";
var SERVER_PORT = Number(process.env.PORT) || 8080;
var FIREBASE_PROJECT_ID = process.env.FIREBASE_PROJECT_ID ?? "hacker-news";
var FIREBASE_DATABASE_URL = process.env.FIREBASE_DATABASE_URL ?? "https://hacker-news.firebaseio.com";
var NEXUS_GENERATED_DIRECTORY = join4(__dirname, "..", "node_modules", "@types", "typegen-nexus");

// node_modules/@firebase/database/dist/node-esm/index.node.esm.js
var import_faye_websocket = __toESM(require_websocket(), 1);

// node_modules/@firebase/util/dist/node-esm/index.node.esm.js
var deepCopy = function(value) {
  return deepExtend(undefined, value);
};
var deepExtend = function(target, source2) {
  if (!(source2 instanceof Object)) {
    return source2;
  }
  switch (source2.constructor) {
    case Date:
      const dateValue = source2;
      return new Date(dateValue.getTime());
    case Object:
      if (target === undefined) {
        target = {};
      }
      break;
    case Array:
      target = [];
      break;
    default:
      return source2;
  }
  for (const prop in source2) {
    if (!source2.hasOwnProperty(prop) || !isValidKey(prop)) {
      continue;
    }
    target[prop] = deepExtend(target[prop], source2[prop]);
  }
  return target;
};
var isValidKey = function(key) {
  return key !== "__proto__";
};
var getGlobal = function() {
  if (typeof self !== "undefined") {
    return self;
  }
  if (typeof window !== "undefined") {
    return window;
  }
  if (typeof global !== "undefined") {
    return global;
  }
  throw new Error("Unable to locate global object.");
};
var createMockUserToken = function(token, projectId) {
  if (token.uid) {
    throw new Error('The "uid" field is no longer supported by mockUserToken. Please use "sub" instead for Firebase Auth User ID.');
  }
  const header = {
    alg: "none",
    type: "JWT"
  };
  const project = projectId || "demo-project";
  const iat = token.iat || 0;
  const sub = token.sub || token.user_id;
  if (!sub) {
    throw new Error("mockUserToken must contain 'sub' or 'user_id' field!");
  }
  const payload = Object.assign({
    iss: `https://securetoken.google.com/${project}`,
    aud: project,
    iat,
    exp: iat + 3600,
    auth_time: iat,
    sub,
    user_id: sub,
    firebase: {
      sign_in_provider: "custom",
      identities: {}
    }
  }, token);
  const signature = "";
  return [
    base64urlEncodeWithoutPadding(JSON.stringify(header)),
    base64urlEncodeWithoutPadding(JSON.stringify(payload)),
    signature
  ].join(".");
};
var getUA = function() {
  if (typeof navigator !== "undefined" && typeof navigator["userAgent"] === "string") {
    return navigator["userAgent"];
  } else {
    return "";
  }
};
var isMobileCordova = function() {
  return typeof window !== "undefined" && !!(window["cordova"] || window["phonegap"] || window["PhoneGap"]) && /ios|iphone|ipod|ipad|android|blackberry|iemobile/i.test(getUA());
};
var isReactNative = function() {
  return typeof navigator === "object" && navigator["product"] === "ReactNative";
};
var isNodeSdk = function() {
  return CONSTANTS.NODE_CLIENT === true || CONSTANTS.NODE_ADMIN === true;
};
var isIndexedDBAvailable = function() {
  try {
    return typeof indexedDB === "object";
  } catch (e) {
    return false;
  }
};
var validateIndexedDBOpenable = function() {
  return new Promise((resolve, reject) => {
    try {
      let preExist = true;
      const DB_CHECK_NAME = "validate-browser-context-for-indexeddb-analytics-module";
      const request = self.indexedDB.open(DB_CHECK_NAME);
      request.onsuccess = () => {
        request.result.close();
        if (!preExist) {
          self.indexedDB.deleteDatabase(DB_CHECK_NAME);
        }
        resolve(true);
      };
      request.onupgradeneeded = () => {
        preExist = false;
      };
      request.onerror = () => {
        var _a;
        reject(((_a = request.error) === null || _a === undefined ? undefined : _a.message) || "");
      };
    } catch (error) {
      reject(error);
    }
  });
};
var replaceTemplate = function(template, data) {
  return template.replace(PATTERN, (_, key) => {
    const value = data[key];
    return value != null ? String(value) : `<${key}?>`;
  });
};
var jsonEval = function(str) {
  return JSON.parse(str);
};
var stringify = function(data) {
  return JSON.stringify(data);
};
var contains = function(obj, key) {
  return Object.prototype.hasOwnProperty.call(obj, key);
};
var safeGet = function(obj, key) {
  if (Object.prototype.hasOwnProperty.call(obj, key)) {
    return obj[key];
  } else {
    return;
  }
};
var isEmpty = function(obj) {
  for (const key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) {
      return false;
    }
  }
  return true;
};
var map = function(obj, fn, contextObj) {
  const res = {};
  for (const key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) {
      res[key] = fn.call(contextObj, obj[key], key, obj);
    }
  }
  return res;
};
var deepEqual = function(a, b) {
  if (a === b) {
    return true;
  }
  const aKeys = Object.keys(a);
  const bKeys = Object.keys(b);
  for (const k of aKeys) {
    if (!bKeys.includes(k)) {
      return false;
    }
    const aProp = a[k];
    const bProp = b[k];
    if (isObject2(aProp) && isObject2(bProp)) {
      if (!deepEqual(aProp, bProp)) {
        return false;
      }
    } else if (aProp !== bProp) {
      return false;
    }
  }
  for (const k of bKeys) {
    if (!aKeys.includes(k)) {
      return false;
    }
  }
  return true;
};
var isObject2 = function(thing) {
  return thing !== null && typeof thing === "object";
};
var querystring = function(querystringParams) {
  const params = [];
  for (const [key, value] of Object.entries(querystringParams)) {
    if (Array.isArray(value)) {
      value.forEach((arrayVal) => {
        params.push(encodeURIComponent(key) + "=" + encodeURIComponent(arrayVal));
      });
    } else {
      params.push(encodeURIComponent(key) + "=" + encodeURIComponent(value));
    }
  }
  return params.length ? "&" + params.join("&") : "";
};
var errorPrefix = function(fnName, argName) {
  return `${fnName} failed: ${argName} argument `;
};
var getModularInstance = function(service) {
  if (service && service._delegate) {
    return service._delegate;
  } else {
    return service;
  }
};
var CONSTANTS = {
  NODE_CLIENT: false,
  NODE_ADMIN: false,
  SDK_VERSION: "${JSCORE_VERSION}"
};
var assert = function(assertion, message) {
  if (!assertion) {
    throw assertionError(message);
  }
};
var assertionError = function(message) {
  return new Error("Firebase Database (" + CONSTANTS.SDK_VERSION + ") INTERNAL ASSERT FAILED: " + message);
};
var stringToByteArray$1 = function(str) {
  const out = [];
  let p = 0;
  for (let i = 0;i < str.length; i++) {
    let c = str.charCodeAt(i);
    if (c < 128) {
      out[p++] = c;
    } else if (c < 2048) {
      out[p++] = c >> 6 | 192;
      out[p++] = c & 63 | 128;
    } else if ((c & 64512) === 55296 && i + 1 < str.length && (str.charCodeAt(i + 1) & 64512) === 56320) {
      c = 65536 + ((c & 1023) << 10) + (str.charCodeAt(++i) & 1023);
      out[p++] = c >> 18 | 240;
      out[p++] = c >> 12 & 63 | 128;
      out[p++] = c >> 6 & 63 | 128;
      out[p++] = c & 63 | 128;
    } else {
      out[p++] = c >> 12 | 224;
      out[p++] = c >> 6 & 63 | 128;
      out[p++] = c & 63 | 128;
    }
  }
  return out;
};
var byteArrayToString = function(bytes) {
  const out = [];
  let pos = 0, c = 0;
  while (pos < bytes.length) {
    const c1 = bytes[pos++];
    if (c1 < 128) {
      out[c++] = String.fromCharCode(c1);
    } else if (c1 > 191 && c1 < 224) {
      const c2 = bytes[pos++];
      out[c++] = String.fromCharCode((c1 & 31) << 6 | c2 & 63);
    } else if (c1 > 239 && c1 < 365) {
      const c2 = bytes[pos++];
      const c3 = bytes[pos++];
      const c4 = bytes[pos++];
      const u = ((c1 & 7) << 18 | (c2 & 63) << 12 | (c3 & 63) << 6 | c4 & 63) - 65536;
      out[c++] = String.fromCharCode(55296 + (u >> 10));
      out[c++] = String.fromCharCode(56320 + (u & 1023));
    } else {
      const c2 = bytes[pos++];
      const c3 = bytes[pos++];
      out[c++] = String.fromCharCode((c1 & 15) << 12 | (c2 & 63) << 6 | c3 & 63);
    }
  }
  return out.join("");
};
var base64 = {
  byteToCharMap_: null,
  charToByteMap_: null,
  byteToCharMapWebSafe_: null,
  charToByteMapWebSafe_: null,
  ENCODED_VALS_BASE: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789",
  get ENCODED_VALS() {
    return this.ENCODED_VALS_BASE + "+/=";
  },
  get ENCODED_VALS_WEBSAFE() {
    return this.ENCODED_VALS_BASE + "-_.";
  },
  HAS_NATIVE_SUPPORT: typeof atob === "function",
  encodeByteArray(input, webSafe) {
    if (!Array.isArray(input)) {
      throw Error("encodeByteArray takes an array as a parameter");
    }
    this.init_();
    const byteToCharMap = webSafe ? this.byteToCharMapWebSafe_ : this.byteToCharMap_;
    const output = [];
    for (let i = 0;i < input.length; i += 3) {
      const byte1 = input[i];
      const haveByte2 = i + 1 < input.length;
      const byte2 = haveByte2 ? input[i + 1] : 0;
      const haveByte3 = i + 2 < input.length;
      const byte3 = haveByte3 ? input[i + 2] : 0;
      const outByte1 = byte1 >> 2;
      const outByte2 = (byte1 & 3) << 4 | byte2 >> 4;
      let outByte3 = (byte2 & 15) << 2 | byte3 >> 6;
      let outByte4 = byte3 & 63;
      if (!haveByte3) {
        outByte4 = 64;
        if (!haveByte2) {
          outByte3 = 64;
        }
      }
      output.push(byteToCharMap[outByte1], byteToCharMap[outByte2], byteToCharMap[outByte3], byteToCharMap[outByte4]);
    }
    return output.join("");
  },
  encodeString(input, webSafe) {
    if (this.HAS_NATIVE_SUPPORT && !webSafe) {
      return btoa(input);
    }
    return this.encodeByteArray(stringToByteArray$1(input), webSafe);
  },
  decodeString(input, webSafe) {
    if (this.HAS_NATIVE_SUPPORT && !webSafe) {
      return atob(input);
    }
    return byteArrayToString(this.decodeStringToByteArray(input, webSafe));
  },
  decodeStringToByteArray(input, webSafe) {
    this.init_();
    const charToByteMap = webSafe ? this.charToByteMapWebSafe_ : this.charToByteMap_;
    const output = [];
    for (let i = 0;i < input.length; ) {
      const byte1 = charToByteMap[input.charAt(i++)];
      const haveByte2 = i < input.length;
      const byte2 = haveByte2 ? charToByteMap[input.charAt(i)] : 0;
      ++i;
      const haveByte3 = i < input.length;
      const byte3 = haveByte3 ? charToByteMap[input.charAt(i)] : 64;
      ++i;
      const haveByte4 = i < input.length;
      const byte4 = haveByte4 ? charToByteMap[input.charAt(i)] : 64;
      ++i;
      if (byte1 == null || byte2 == null || byte3 == null || byte4 == null) {
        throw new DecodeBase64StringError;
      }
      const outByte1 = byte1 << 2 | byte2 >> 4;
      output.push(outByte1);
      if (byte3 !== 64) {
        const outByte2 = byte2 << 4 & 240 | byte3 >> 2;
        output.push(outByte2);
        if (byte4 !== 64) {
          const outByte3 = byte3 << 6 & 192 | byte4;
          output.push(outByte3);
        }
      }
    }
    return output;
  },
  init_() {
    if (!this.byteToCharMap_) {
      this.byteToCharMap_ = {};
      this.charToByteMap_ = {};
      this.byteToCharMapWebSafe_ = {};
      this.charToByteMapWebSafe_ = {};
      for (let i = 0;i < this.ENCODED_VALS.length; i++) {
        this.byteToCharMap_[i] = this.ENCODED_VALS.charAt(i);
        this.charToByteMap_[this.byteToCharMap_[i]] = i;
        this.byteToCharMapWebSafe_[i] = this.ENCODED_VALS_WEBSAFE.charAt(i);
        this.charToByteMapWebSafe_[this.byteToCharMapWebSafe_[i]] = i;
        if (i >= this.ENCODED_VALS_BASE.length) {
          this.charToByteMap_[this.ENCODED_VALS_WEBSAFE.charAt(i)] = i;
          this.charToByteMapWebSafe_[this.ENCODED_VALS.charAt(i)] = i;
        }
      }
    }
  }
};

class DecodeBase64StringError extends Error {
  constructor() {
    super(...arguments);
    this.name = "DecodeBase64StringError";
  }
}
var base64Encode2 = function(str) {
  const utf8Bytes = stringToByteArray$1(str);
  return base64.encodeByteArray(utf8Bytes, true);
};
var base64urlEncodeWithoutPadding = function(str) {
  return base64Encode2(str).replace(/\./g, "");
};
var base64Decode2 = function(str) {
  try {
    return base64.decodeString(str, true);
  } catch (e) {
    console.error("base64Decode failed: ", e);
  }
  return null;
};
var getDefaultsFromGlobal = () => getGlobal().__FIREBASE_DEFAULTS__;
var getDefaultsFromEnvVariable = () => {
  if (typeof process === "undefined" || typeof process.env === "undefined") {
    return;
  }
  const defaultsJsonString = process.env.__FIREBASE_DEFAULTS__;
  if (defaultsJsonString) {
    return JSON.parse(defaultsJsonString);
  }
};
var getDefaultsFromCookie = () => {
  if (typeof document === "undefined") {
    return;
  }
  let match;
  try {
    match = document.cookie.match(/__FIREBASE_DEFAULTS__=([^;]+)/);
  } catch (e) {
    return;
  }
  const decoded = match && base64Decode2(match[1]);
  return decoded && JSON.parse(decoded);
};
var getDefaults = () => {
  try {
    return getDefaultsFromGlobal() || getDefaultsFromEnvVariable() || getDefaultsFromCookie();
  } catch (e) {
    console.info(`Unable to get __FIREBASE_DEFAULTS__ due to: ${e}`);
    return;
  }
};
var getDefaultEmulatorHost = (productName) => {
  var _a, _b;
  return (_b = (_a = getDefaults()) === null || _a === undefined ? undefined : _a.emulatorHosts) === null || _b === undefined ? undefined : _b[productName];
};
var getDefaultEmulatorHostnameAndPort = (productName) => {
  const host = getDefaultEmulatorHost(productName);
  if (!host) {
    return;
  }
  const separatorIndex = host.lastIndexOf(":");
  if (separatorIndex <= 0 || separatorIndex + 1 === host.length) {
    throw new Error(`Invalid host ${host} with no separate hostname and port!`);
  }
  const port = parseInt(host.substring(separatorIndex + 1), 10);
  if (host[0] === "[") {
    return [host.substring(1, separatorIndex - 1), port];
  } else {
    return [host.substring(0, separatorIndex), port];
  }
};
var getDefaultAppConfig = () => {
  var _a;
  return (_a = getDefaults()) === null || _a === undefined ? undefined : _a.config;
};
class Deferred {
  constructor() {
    this.reject = () => {
    };
    this.resolve = () => {
    };
    this.promise = new Promise((resolve, reject) => {
      this.resolve = resolve;
      this.reject = reject;
    });
  }
  wrapCallback(callback) {
    return (error, value) => {
      if (error) {
        this.reject(error);
      } else {
        this.resolve(value);
      }
      if (typeof callback === "function") {
        this.promise.catch(() => {
        });
        if (callback.length === 1) {
          callback(error);
        } else {
          callback(error, value);
        }
      }
    };
  }
}
var ERROR_NAME = "FirebaseError";

class FirebaseError extends Error {
  constructor(code, message, customData) {
    super(message);
    this.code = code;
    this.customData = customData;
    this.name = ERROR_NAME;
    Object.setPrototypeOf(this, FirebaseError.prototype);
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, ErrorFactory.prototype.create);
    }
  }
}

class ErrorFactory {
  constructor(service, serviceName, errors) {
    this.service = service;
    this.serviceName = serviceName;
    this.errors = errors;
  }
  create(code, ...data) {
    const customData = data[0] || {};
    const fullCode = `${this.service}/${code}`;
    const template = this.errors[code];
    const message = template ? replaceTemplate(template, customData) : "Error";
    const fullMessage = `${this.serviceName}: ${message} (${fullCode}).`;
    const error = new FirebaseError(fullCode, fullMessage, customData);
    return error;
  }
}
var PATTERN = /\{\$([^}]+)}/g;
var decode = function(token) {
  let header = {}, claims = {}, data = {}, signature = "";
  try {
    const parts = token.split(".");
    header = jsonEval(base64Decode2(parts[0]) || "");
    claims = jsonEval(base64Decode2(parts[1]) || "");
    signature = parts[2];
    data = claims["d"] || {};
    delete claims["d"];
  } catch (e) {
  }
  return {
    header,
    claims,
    data,
    signature
  };
};
var isValidFormat = function(token) {
  const decoded = decode(token), claims = decoded.claims;
  return !!claims && typeof claims === "object" && claims.hasOwnProperty("iat");
};
var isAdmin = function(token) {
  const claims = decode(token).claims;
  return typeof claims === "object" && claims["admin"] === true;
};

class Sha1 {
  constructor() {
    this.chain_ = [];
    this.buf_ = [];
    this.W_ = [];
    this.pad_ = [];
    this.inbuf_ = 0;
    this.total_ = 0;
    this.blockSize = 512 / 8;
    this.pad_[0] = 128;
    for (let i = 1;i < this.blockSize; ++i) {
      this.pad_[i] = 0;
    }
    this.reset();
  }
  reset() {
    this.chain_[0] = 1732584193;
    this.chain_[1] = 4023233417;
    this.chain_[2] = 2562383102;
    this.chain_[3] = 271733878;
    this.chain_[4] = 3285377520;
    this.inbuf_ = 0;
    this.total_ = 0;
  }
  compress_(buf, offset) {
    if (!offset) {
      offset = 0;
    }
    const W = this.W_;
    if (typeof buf === "string") {
      for (let i = 0;i < 16; i++) {
        W[i] = buf.charCodeAt(offset) << 24 | buf.charCodeAt(offset + 1) << 16 | buf.charCodeAt(offset + 2) << 8 | buf.charCodeAt(offset + 3);
        offset += 4;
      }
    } else {
      for (let i = 0;i < 16; i++) {
        W[i] = buf[offset] << 24 | buf[offset + 1] << 16 | buf[offset + 2] << 8 | buf[offset + 3];
        offset += 4;
      }
    }
    for (let i = 16;i < 80; i++) {
      const t = W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16];
      W[i] = (t << 1 | t >>> 31) & 4294967295;
    }
    let a = this.chain_[0];
    let b = this.chain_[1];
    let c = this.chain_[2];
    let d = this.chain_[3];
    let e = this.chain_[4];
    let f, k;
    for (let i = 0;i < 80; i++) {
      if (i < 40) {
        if (i < 20) {
          f = d ^ b & (c ^ d);
          k = 1518500249;
        } else {
          f = b ^ c ^ d;
          k = 1859775393;
        }
      } else {
        if (i < 60) {
          f = b & c | d & (b | c);
          k = 2400959708;
        } else {
          f = b ^ c ^ d;
          k = 3395469782;
        }
      }
      const t = (a << 5 | a >>> 27) + f + e + k + W[i] & 4294967295;
      e = d;
      d = c;
      c = (b << 30 | b >>> 2) & 4294967295;
      b = a;
      a = t;
    }
    this.chain_[0] = this.chain_[0] + a & 4294967295;
    this.chain_[1] = this.chain_[1] + b & 4294967295;
    this.chain_[2] = this.chain_[2] + c & 4294967295;
    this.chain_[3] = this.chain_[3] + d & 4294967295;
    this.chain_[4] = this.chain_[4] + e & 4294967295;
  }
  update(bytes, length) {
    if (bytes == null) {
      return;
    }
    if (length === undefined) {
      length = bytes.length;
    }
    const lengthMinusBlock = length - this.blockSize;
    let n = 0;
    const buf = this.buf_;
    let inbuf = this.inbuf_;
    while (n < length) {
      if (inbuf === 0) {
        while (n <= lengthMinusBlock) {
          this.compress_(bytes, n);
          n += this.blockSize;
        }
      }
      if (typeof bytes === "string") {
        while (n < length) {
          buf[inbuf] = bytes.charCodeAt(n);
          ++inbuf;
          ++n;
          if (inbuf === this.blockSize) {
            this.compress_(buf);
            inbuf = 0;
            break;
          }
        }
      } else {
        while (n < length) {
          buf[inbuf] = bytes[n];
          ++inbuf;
          ++n;
          if (inbuf === this.blockSize) {
            this.compress_(buf);
            inbuf = 0;
            break;
          }
        }
      }
    }
    this.inbuf_ = inbuf;
    this.total_ += length;
  }
  digest() {
    const digest = [];
    let totalBits = this.total_ * 8;
    if (this.inbuf_ < 56) {
      this.update(this.pad_, 56 - this.inbuf_);
    } else {
      this.update(this.pad_, this.blockSize - (this.inbuf_ - 56));
    }
    for (let i = this.blockSize - 1;i >= 56; i--) {
      this.buf_[i] = totalBits & 255;
      totalBits /= 256;
    }
    this.compress_(this.buf_);
    let n = 0;
    for (let i = 0;i < 5; i++) {
      for (let j = 24;j >= 0; j -= 8) {
        digest[n] = this.chain_[i] >> j & 255;
        ++n;
      }
    }
    return digest;
  }
}
var stringToByteArray = function(str) {
  const out = [];
  let p = 0;
  for (let i = 0;i < str.length; i++) {
    let c = str.charCodeAt(i);
    if (c >= 55296 && c <= 56319) {
      const high = c - 55296;
      i++;
      assert(i < str.length, "Surrogate pair missing trail surrogate.");
      const low = str.charCodeAt(i) - 56320;
      c = 65536 + (high << 10) + low;
    }
    if (c < 128) {
      out[p++] = c;
    } else if (c < 2048) {
      out[p++] = c >> 6 | 192;
      out[p++] = c & 63 | 128;
    } else if (c < 65536) {
      out[p++] = c >> 12 | 224;
      out[p++] = c >> 6 & 63 | 128;
      out[p++] = c & 63 | 128;
    } else {
      out[p++] = c >> 18 | 240;
      out[p++] = c >> 12 & 63 | 128;
      out[p++] = c >> 6 & 63 | 128;
      out[p++] = c & 63 | 128;
    }
  }
  return out;
};
var stringLength = function(str) {
  let p = 0;
  for (let i = 0;i < str.length; i++) {
    const c = str.charCodeAt(i);
    if (c < 128) {
      p++;
    } else if (c < 2048) {
      p += 2;
    } else if (c >= 55296 && c <= 56319) {
      p += 4;
      i++;
    } else {
      p += 3;
    }
  }
  return p;
};
var MAX_VALUE_MILLIS = 4 * 60 * 60 * 1000;
CONSTANTS.NODE_CLIENT = true;

// node_modules/@firebase/logger/dist/esm/index.esm2017.js
var instances = [];
var LogLevel;
(function(LogLevel2) {
  LogLevel2[LogLevel2["DEBUG"] = 0] = "DEBUG";
  LogLevel2[LogLevel2["VERBOSE"] = 1] = "VERBOSE";
  LogLevel2[LogLevel2["INFO"] = 2] = "INFO";
  LogLevel2[LogLevel2["WARN"] = 3] = "WARN";
  LogLevel2[LogLevel2["ERROR"] = 4] = "ERROR";
  LogLevel2[LogLevel2["SILENT"] = 5] = "SILENT";
})(LogLevel || (LogLevel = {}));
var levelStringToEnum = {
  debug: LogLevel.DEBUG,
  verbose: LogLevel.VERBOSE,
  info: LogLevel.INFO,
  warn: LogLevel.WARN,
  error: LogLevel.ERROR,
  silent: LogLevel.SILENT
};
var defaultLogLevel = LogLevel.INFO;
var ConsoleMethod = {
  [LogLevel.DEBUG]: "log",
  [LogLevel.VERBOSE]: "log",
  [LogLevel.INFO]: "info",
  [LogLevel.WARN]: "warn",
  [LogLevel.ERROR]: "error"
};
var defaultLogHandler = (instance, logType, ...args7) => {
  if (logType < instance.logLevel) {
    return;
  }
  const now = new Date().toISOString();
  const method = ConsoleMethod[logType];
  if (method) {
    console[method](`[${now}]  ${instance.name}:`, ...args7);
  } else {
    throw new Error(`Attempted to log a message with an invalid logType (value: ${logType})`);
  }
};

class Logger {
  constructor(name) {
    this.name = name;
    this._logLevel = defaultLogLevel;
    this._logHandler = defaultLogHandler;
    this._userLogHandler = null;
    instances.push(this);
  }
  get logLevel() {
    return this._logLevel;
  }
  set logLevel(val) {
    if (!(val in LogLevel)) {
      throw new TypeError(`Invalid value "${val}" assigned to \`logLevel\``);
    }
    this._logLevel = val;
  }
  setLogLevel(val) {
    this._logLevel = typeof val === "string" ? levelStringToEnum[val] : val;
  }
  get logHandler() {
    return this._logHandler;
  }
  set logHandler(val) {
    if (typeof val !== "function") {
      throw new TypeError("Value assigned to `logHandler` must be a function");
    }
    this._logHandler = val;
  }
  get userLogHandler() {
    return this._userLogHandler;
  }
  set userLogHandler(val) {
    this._userLogHandler = val;
  }
  debug(...args7) {
    this._userLogHandler && this._userLogHandler(this, LogLevel.DEBUG, ...args7);
    this._logHandler(this, LogLevel.DEBUG, ...args7);
  }
  log(...args7) {
    this._userLogHandler && this._userLogHandler(this, LogLevel.VERBOSE, ...args7);
    this._logHandler(this, LogLevel.VERBOSE, ...args7);
  }
  info(...args7) {
    this._userLogHandler && this._userLogHandler(this, LogLevel.INFO, ...args7);
    this._logHandler(this, LogLevel.INFO, ...args7);
  }
  warn(...args7) {
    this._userLogHandler && this._userLogHandler(this, LogLevel.WARN, ...args7);
    this._logHandler(this, LogLevel.WARN, ...args7);
  }
  error(...args7) {
    this._userLogHandler && this._userLogHandler(this, LogLevel.ERROR, ...args7);
    this._logHandler(this, LogLevel.ERROR, ...args7);
  }
}

// node_modules/@firebase/component/dist/esm/index.esm2017.js
var normalizeIdentifierForFactory = function(identifier) {
  return identifier === DEFAULT_ENTRY_NAME ? undefined : identifier;
};
var isComponentEager = function(component) {
  return component.instantiationMode === "EAGER";
};

class Component {
  constructor(name, instanceFactory, type) {
    this.name = name;
    this.instanceFactory = instanceFactory;
    this.type = type;
    this.multipleInstances = false;
    this.serviceProps = {};
    this.instantiationMode = "LAZY";
    this.onInstanceCreated = null;
  }
  setInstantiationMode(mode) {
    this.instantiationMode = mode;
    return this;
  }
  setMultipleInstances(multipleInstances) {
    this.multipleInstances = multipleInstances;
    return this;
  }
  setServiceProps(props) {
    this.serviceProps = props;
    return this;
  }
  setInstanceCreatedCallback(callback) {
    this.onInstanceCreated = callback;
    return this;
  }
}
var DEFAULT_ENTRY_NAME = "[DEFAULT]";

class Provider {
  constructor(name, container) {
    this.name = name;
    this.container = container;
    this.component = null;
    this.instances = new Map;
    this.instancesDeferred = new Map;
    this.instancesOptions = new Map;
    this.onInitCallbacks = new Map;
  }
  get(identifier) {
    const normalizedIdentifier = this.normalizeInstanceIdentifier(identifier);
    if (!this.instancesDeferred.has(normalizedIdentifier)) {
      const deferred = new Deferred;
      this.instancesDeferred.set(normalizedIdentifier, deferred);
      if (this.isInitialized(normalizedIdentifier) || this.shouldAutoInitialize()) {
        try {
          const instance = this.getOrInitializeService({
            instanceIdentifier: normalizedIdentifier
          });
          if (instance) {
            deferred.resolve(instance);
          }
        } catch (e) {
        }
      }
    }
    return this.instancesDeferred.get(normalizedIdentifier).promise;
  }
  getImmediate(options) {
    var _a;
    const normalizedIdentifier = this.normalizeInstanceIdentifier(options === null || options === undefined ? undefined : options.identifier);
    const optional = (_a = options === null || options === undefined ? undefined : options.optional) !== null && _a !== undefined ? _a : false;
    if (this.isInitialized(normalizedIdentifier) || this.shouldAutoInitialize()) {
      try {
        return this.getOrInitializeService({
          instanceIdentifier: normalizedIdentifier
        });
      } catch (e) {
        if (optional) {
          return null;
        } else {
          throw e;
        }
      }
    } else {
      if (optional) {
        return null;
      } else {
        throw Error(`Service ${this.name} is not available`);
      }
    }
  }
  getComponent() {
    return this.component;
  }
  setComponent(component) {
    if (component.name !== this.name) {
      throw Error(`Mismatching Component ${component.name} for Provider ${this.name}.`);
    }
    if (this.component) {
      throw Error(`Component for ${this.name} has already been provided`);
    }
    this.component = component;
    if (!this.shouldAutoInitialize()) {
      return;
    }
    if (isComponentEager(component)) {
      try {
        this.getOrInitializeService({ instanceIdentifier: DEFAULT_ENTRY_NAME });
      } catch (e) {
      }
    }
    for (const [instanceIdentifier, instanceDeferred] of this.instancesDeferred.entries()) {
      const normalizedIdentifier = this.normalizeInstanceIdentifier(instanceIdentifier);
      try {
        const instance = this.getOrInitializeService({
          instanceIdentifier: normalizedIdentifier
        });
        instanceDeferred.resolve(instance);
      } catch (e) {
      }
    }
  }
  clearInstance(identifier = DEFAULT_ENTRY_NAME) {
    this.instancesDeferred.delete(identifier);
    this.instancesOptions.delete(identifier);
    this.instances.delete(identifier);
  }
  async delete() {
    const services = Array.from(this.instances.values());
    await Promise.all([
      ...services.filter((service) => ("INTERNAL" in service)).map((service) => service.INTERNAL.delete()),
      ...services.filter((service) => ("_delete" in service)).map((service) => service._delete())
    ]);
  }
  isComponentSet() {
    return this.component != null;
  }
  isInitialized(identifier = DEFAULT_ENTRY_NAME) {
    return this.instances.has(identifier);
  }
  getOptions(identifier = DEFAULT_ENTRY_NAME) {
    return this.instancesOptions.get(identifier) || {};
  }
  initialize(opts = {}) {
    const { options = {} } = opts;
    const normalizedIdentifier = this.normalizeInstanceIdentifier(opts.instanceIdentifier);
    if (this.isInitialized(normalizedIdentifier)) {
      throw Error(`${this.name}(${normalizedIdentifier}) has already been initialized`);
    }
    if (!this.isComponentSet()) {
      throw Error(`Component ${this.name} has not been registered yet`);
    }
    const instance = this.getOrInitializeService({
      instanceIdentifier: normalizedIdentifier,
      options
    });
    for (const [instanceIdentifier, instanceDeferred] of this.instancesDeferred.entries()) {
      const normalizedDeferredIdentifier = this.normalizeInstanceIdentifier(instanceIdentifier);
      if (normalizedIdentifier === normalizedDeferredIdentifier) {
        instanceDeferred.resolve(instance);
      }
    }
    return instance;
  }
  onInit(callback, identifier) {
    var _a;
    const normalizedIdentifier = this.normalizeInstanceIdentifier(identifier);
    const existingCallbacks = (_a = this.onInitCallbacks.get(normalizedIdentifier)) !== null && _a !== undefined ? _a : new Set;
    existingCallbacks.add(callback);
    this.onInitCallbacks.set(normalizedIdentifier, existingCallbacks);
    const existingInstance = this.instances.get(normalizedIdentifier);
    if (existingInstance) {
      callback(existingInstance, normalizedIdentifier);
    }
    return () => {
      existingCallbacks.delete(callback);
    };
  }
  invokeOnInitCallbacks(instance, identifier) {
    const callbacks = this.onInitCallbacks.get(identifier);
    if (!callbacks) {
      return;
    }
    for (const callback of callbacks) {
      try {
        callback(instance, identifier);
      } catch (_a) {
      }
    }
  }
  getOrInitializeService({ instanceIdentifier, options = {} }) {
    let instance = this.instances.get(instanceIdentifier);
    if (!instance && this.component) {
      instance = this.component.instanceFactory(this.container, {
        instanceIdentifier: normalizeIdentifierForFactory(instanceIdentifier),
        options
      });
      this.instances.set(instanceIdentifier, instance);
      this.instancesOptions.set(instanceIdentifier, options);
      this.invokeOnInitCallbacks(instance, instanceIdentifier);
      if (this.component.onInstanceCreated) {
        try {
          this.component.onInstanceCreated(this.container, instanceIdentifier, instance);
        } catch (_a) {
        }
      }
    }
    return instance || null;
  }
  normalizeInstanceIdentifier(identifier = DEFAULT_ENTRY_NAME) {
    if (this.component) {
      return this.component.multipleInstances ? identifier : DEFAULT_ENTRY_NAME;
    } else {
      return identifier;
    }
  }
  shouldAutoInitialize() {
    return !!this.component && this.component.instantiationMode !== "EXPLICIT";
  }
}

class ComponentContainer {
  constructor(name) {
    this.name = name;
    this.providers = new Map;
  }
  addComponent(component) {
    const provider = this.getProvider(component.name);
    if (provider.isComponentSet()) {
      throw new Error(`Component ${component.name} has already been registered with ${this.name}`);
    }
    provider.setComponent(component);
  }
  addOrOverwriteComponent(component) {
    const provider = this.getProvider(component.name);
    if (provider.isComponentSet()) {
      this.providers.delete(component.name);
    }
    this.addComponent(component);
  }
  getProvider(name) {
    if (this.providers.has(name)) {
      return this.providers.get(name);
    }
    const provider = new Provider(name, this);
    this.providers.set(name, provider);
    return provider;
  }
  getProviders() {
    return Array.from(this.providers.values());
  }
}
// node_modules/idb/build/wrap-idb-value.js
var getIdbProxyableTypes = function() {
  return idbProxyableTypes || (idbProxyableTypes = [
    IDBDatabase,
    IDBObjectStore,
    IDBIndex,
    IDBCursor,
    IDBTransaction
  ]);
};
var getCursorAdvanceMethods = function() {
  return cursorAdvanceMethods || (cursorAdvanceMethods = [
    IDBCursor.prototype.advance,
    IDBCursor.prototype.continue,
    IDBCursor.prototype.continuePrimaryKey
  ]);
};
var promisifyRequest = function(request) {
  const promise = new Promise((resolve, reject) => {
    const unlisten = () => {
      request.removeEventListener("success", success);
      request.removeEventListener("error", error);
    };
    const success = () => {
      resolve(wrap2(request.result));
      unlisten();
    };
    const error = () => {
      reject(request.error);
      unlisten();
    };
    request.addEventListener("success", success);
    request.addEventListener("error", error);
  });
  promise.then((value) => {
    if (value instanceof IDBCursor) {
      cursorRequestMap.set(value, request);
    }
  }).catch(() => {
  });
  reverseTransformCache.set(promise, request);
  return promise;
};
var cacheDonePromiseForTransaction = function(tx) {
  if (transactionDoneMap.has(tx))
    return;
  const done = new Promise((resolve, reject) => {
    const unlisten = () => {
      tx.removeEventListener("complete", complete);
      tx.removeEventListener("error", error);
      tx.removeEventListener("abort", error);
    };
    const complete = () => {
      resolve();
      unlisten();
    };
    const error = () => {
      reject(tx.error || new DOMException("AbortError", "AbortError"));
      unlisten();
    };
    tx.addEventListener("complete", complete);
    tx.addEventListener("error", error);
    tx.addEventListener("abort", error);
  });
  transactionDoneMap.set(tx, done);
};
var replaceTraps = function(callback) {
  idbProxyTraps = callback(idbProxyTraps);
};
var wrapFunction = function(func) {
  if (func === IDBDatabase.prototype.transaction && !("objectStoreNames" in IDBTransaction.prototype)) {
    return function(storeNames, ...args7) {
      const tx = func.call(unwrap(this), storeNames, ...args7);
      transactionStoreNamesMap.set(tx, storeNames.sort ? storeNames.sort() : [storeNames]);
      return wrap2(tx);
    };
  }
  if (getCursorAdvanceMethods().includes(func)) {
    return function(...args7) {
      func.apply(unwrap(this), args7);
      return wrap2(cursorRequestMap.get(this));
    };
  }
  return function(...args7) {
    return wrap2(func.apply(unwrap(this), args7));
  };
};
var transformCachableValue = function(value) {
  if (typeof value === "function")
    return wrapFunction(value);
  if (value instanceof IDBTransaction)
    cacheDonePromiseForTransaction(value);
  if (instanceOfAny(value, getIdbProxyableTypes()))
    return new Proxy(value, idbProxyTraps);
  return value;
};
var wrap2 = function(value) {
  if (value instanceof IDBRequest)
    return promisifyRequest(value);
  if (transformCache.has(value))
    return transformCache.get(value);
  const newValue = transformCachableValue(value);
  if (newValue !== value) {
    transformCache.set(value, newValue);
    reverseTransformCache.set(newValue, value);
  }
  return newValue;
};
var instanceOfAny = (object, constructors) => constructors.some((c) => object instanceof c);
var idbProxyableTypes;
var cursorAdvanceMethods;
var cursorRequestMap = new WeakMap;
var transactionDoneMap = new WeakMap;
var transactionStoreNamesMap = new WeakMap;
var transformCache = new WeakMap;
var reverseTransformCache = new WeakMap;
var idbProxyTraps = {
  get(target, prop, receiver) {
    if (target instanceof IDBTransaction) {
      if (prop === "done")
        return transactionDoneMap.get(target);
      if (prop === "objectStoreNames") {
        return target.objectStoreNames || transactionStoreNamesMap.get(target);
      }
      if (prop === "store") {
        return receiver.objectStoreNames[1] ? undefined : receiver.objectStore(receiver.objectStoreNames[0]);
      }
    }
    return wrap2(target[prop]);
  },
  set(target, prop, value) {
    target[prop] = value;
    return true;
  },
  has(target, prop) {
    if (target instanceof IDBTransaction && (prop === "done" || prop === "store")) {
      return true;
    }
    return prop in target;
  }
};
var unwrap = (value) => reverseTransformCache.get(value);

// node_modules/idb/build/index.js
var openDB = function(name, version2, { blocked, upgrade, blocking, terminated } = {}) {
  const request = indexedDB.open(name, version2);
  const openPromise = wrap2(request);
  if (upgrade) {
    request.addEventListener("upgradeneeded", (event) => {
      upgrade(wrap2(request.result), event.oldVersion, event.newVersion, wrap2(request.transaction), event);
    });
  }
  if (blocked) {
    request.addEventListener("blocked", (event) => blocked(event.oldVersion, event.newVersion, event));
  }
  openPromise.then((db) => {
    if (terminated)
      db.addEventListener("close", () => terminated());
    if (blocking) {
      db.addEventListener("versionchange", (event) => blocking(event.oldVersion, event.newVersion, event));
    }
  }).catch(() => {
  });
  return openPromise;
};
var getMethod = function(target, prop) {
  if (!(target instanceof IDBDatabase && !(prop in target) && typeof prop === "string")) {
    return;
  }
  if (cachedMethods.get(prop))
    return cachedMethods.get(prop);
  const targetFuncName = prop.replace(/FromIndex$/, "");
  const useIndex = prop !== targetFuncName;
  const isWrite = writeMethods.includes(targetFuncName);
  if (!(targetFuncName in (useIndex ? IDBIndex : IDBObjectStore).prototype) || !(isWrite || readMethods.includes(targetFuncName))) {
    return;
  }
  const method = async function(storeName, ...args7) {
    const tx = this.transaction(storeName, isWrite ? "readwrite" : "readonly");
    let target2 = tx.store;
    if (useIndex)
      target2 = target2.index(args7.shift());
    return (await Promise.all([
      target2[targetFuncName](...args7),
      isWrite && tx.done
    ]))[0];
  };
  cachedMethods.set(prop, method);
  return method;
};
var readMethods = ["get", "getKey", "getAll", "getAllKeys", "count"];
var writeMethods = ["put", "add", "delete", "clear"];
var cachedMethods = new Map;
replaceTraps((oldTraps) => ({
  ...oldTraps,
  get: (target, prop, receiver) => getMethod(target, prop) || oldTraps.get(target, prop, receiver),
  has: (target, prop) => !!getMethod(target, prop) || oldTraps.has(target, prop)
}));

// node_modules/@firebase/app/dist/esm/index.esm2017.js
var isVersionServiceProvider = function(provider) {
  const component2 = provider.getComponent();
  return (component2 === null || component2 === undefined ? undefined : component2.type) === "VERSION";
};
var _addComponent = function(app, component2) {
  try {
    app.container.addComponent(component2);
  } catch (e) {
    logger2.debug(`Component ${component2.name} failed to register with FirebaseApp ${app.name}`, e);
  }
};
var _registerComponent = function(component2) {
  const componentName = component2.name;
  if (_components.has(componentName)) {
    logger2.debug(`There were multiple attempts to register component ${componentName}.`);
    return false;
  }
  _components.set(componentName, component2);
  for (const app of _apps.values()) {
    _addComponent(app, component2);
  }
  return true;
};
var _getProvider = function(app, name) {
  const heartbeatController = app.container.getProvider("heartbeat").getImmediate({ optional: true });
  if (heartbeatController) {
    heartbeatController.triggerHeartbeat();
  }
  return app.container.getProvider(name);
};
var initializeApp = function(_options, rawConfig = {}) {
  let options = _options;
  if (typeof rawConfig !== "object") {
    const name2 = rawConfig;
    rawConfig = { name: name2 };
  }
  const config = Object.assign({ name: DEFAULT_ENTRY_NAME2, automaticDataCollectionEnabled: false }, rawConfig);
  const name = config.name;
  if (typeof name !== "string" || !name) {
    throw ERROR_FACTORY.create("bad-app-name", {
      appName: String(name)
    });
  }
  options || (options = getDefaultAppConfig());
  if (!options) {
    throw ERROR_FACTORY.create("no-options");
  }
  const existingApp = _apps.get(name);
  if (existingApp) {
    if (deepEqual(options, existingApp.options) && deepEqual(config, existingApp.config)) {
      return existingApp;
    } else {
      throw ERROR_FACTORY.create("duplicate-app", { appName: name });
    }
  }
  const container = new ComponentContainer(name);
  for (const component2 of _components.values()) {
    container.addComponent(component2);
  }
  const newApp = new FirebaseAppImpl(options, config, container);
  _apps.set(name, newApp);
  return newApp;
};
var getApp = function(name = DEFAULT_ENTRY_NAME2) {
  const app = _apps.get(name);
  if (!app && name === DEFAULT_ENTRY_NAME2 && getDefaultAppConfig()) {
    return initializeApp();
  }
  if (!app) {
    throw ERROR_FACTORY.create("no-app", { appName: name });
  }
  return app;
};
var registerVersion = function(libraryKeyOrName, version2, variant) {
  var _a;
  let library = (_a = PLATFORM_LOG_STRING[libraryKeyOrName]) !== null && _a !== undefined ? _a : libraryKeyOrName;
  if (variant) {
    library += `-${variant}`;
  }
  const libraryMismatch = library.match(/\s|\//);
  const versionMismatch = version2.match(/\s|\//);
  if (libraryMismatch || versionMismatch) {
    const warning = [
      `Unable to register library "${library}" with version "${version2}":`
    ];
    if (libraryMismatch) {
      warning.push(`library name "${library}" contains illegal characters (whitespace or "/")`);
    }
    if (libraryMismatch && versionMismatch) {
      warning.push("and");
    }
    if (versionMismatch) {
      warning.push(`version name "${version2}" contains illegal characters (whitespace or "/")`);
    }
    logger2.warn(warning.join(" "));
    return;
  }
  _registerComponent(new Component(`${library}-version`, () => ({ library, version: version2 }), "VERSION"));
};
var getDbPromise = function() {
  if (!dbPromise) {
    dbPromise = openDB(DB_NAME, DB_VERSION, {
      upgrade: (db, oldVersion) => {
        switch (oldVersion) {
          case 0:
            db.createObjectStore(STORE_NAME);
        }
      }
    }).catch((e) => {
      throw ERROR_FACTORY.create("idb-open", {
        originalErrorMessage: e.message
      });
    });
  }
  return dbPromise;
};
async function readHeartbeatsFromIndexedDB(app) {
  try {
    const db = await getDbPromise();
    const result = await db.transaction(STORE_NAME).objectStore(STORE_NAME).get(computeKey(app));
    return result;
  } catch (e) {
    if (e instanceof FirebaseError) {
      logger2.warn(e.message);
    } else {
      const idbGetError = ERROR_FACTORY.create("idb-get", {
        originalErrorMessage: e === null || e === undefined ? undefined : e.message
      });
      logger2.warn(idbGetError.message);
    }
  }
}
async function writeHeartbeatsToIndexedDB(app, heartbeatObject) {
  try {
    const db = await getDbPromise();
    const tx = db.transaction(STORE_NAME, "readwrite");
    const objectStore = tx.objectStore(STORE_NAME);
    await objectStore.put(heartbeatObject, computeKey(app));
    await tx.done;
  } catch (e) {
    if (e instanceof FirebaseError) {
      logger2.warn(e.message);
    } else {
      const idbGetError = ERROR_FACTORY.create("idb-set", {
        originalErrorMessage: e === null || e === undefined ? undefined : e.message
      });
      logger2.warn(idbGetError.message);
    }
  }
}
var computeKey = function(app) {
  return `${app.name}!${app.options.appId}`;
};
var getUTCDateString = function() {
  const today = new Date;
  return today.toISOString().substring(0, 10);
};
var extractHeartbeatsForHeader = function(heartbeatsCache, maxSize = MAX_HEADER_BYTES) {
  const heartbeatsToSend = [];
  let unsentEntries = heartbeatsCache.slice();
  for (const singleDateHeartbeat of heartbeatsCache) {
    const heartbeatEntry = heartbeatsToSend.find((hb) => hb.agent === singleDateHeartbeat.agent);
    if (!heartbeatEntry) {
      heartbeatsToSend.push({
        agent: singleDateHeartbeat.agent,
        dates: [singleDateHeartbeat.date]
      });
      if (countBytes(heartbeatsToSend) > maxSize) {
        heartbeatsToSend.pop();
        break;
      }
    } else {
      heartbeatEntry.dates.push(singleDateHeartbeat.date);
      if (countBytes(heartbeatsToSend) > maxSize) {
        heartbeatEntry.dates.pop();
        break;
      }
    }
    unsentEntries = unsentEntries.slice(1);
  }
  return {
    heartbeatsToSend,
    unsentEntries
  };
};
var countBytes = function(heartbeatsCache) {
  return base64urlEncodeWithoutPadding(JSON.stringify({ version: 2, heartbeats: heartbeatsCache })).length;
};
var registerCoreComponents = function(variant) {
  _registerComponent(new Component("platform-logger", (container) => new PlatformLoggerServiceImpl(container), "PRIVATE"));
  _registerComponent(new Component("heartbeat", (container) => new HeartbeatServiceImpl(container), "PRIVATE"));
  registerVersion(name$o, version$1, variant);
  registerVersion(name$o, version$1, "esm2017");
  registerVersion("fire-js", "");
};

class PlatformLoggerServiceImpl {
  constructor(container) {
    this.container = container;
  }
  getPlatformInfoString() {
    const providers = this.container.getProviders();
    return providers.map((provider) => {
      if (isVersionServiceProvider(provider)) {
        const service = provider.getImmediate();
        return `${service.library}/${service.version}`;
      } else {
        return null;
      }
    }).filter((logString) => logString).join(" ");
  }
}
var name$o = "@firebase/app";
var version$1 = "0.9.13";
var logger2 = new Logger("@firebase/app");
var name$n = "@firebase/app-compat";
var name$m = "@firebase/analytics-compat";
var name$l = "@firebase/analytics";
var name$k = "@firebase/app-check-compat";
var name$j = "@firebase/app-check";
var name$i = "@firebase/auth";
var name$h = "@firebase/auth-compat";
var name$g = "@firebase/database";
var name$f = "@firebase/database-compat";
var name$e = "@firebase/functions";
var name$d = "@firebase/functions-compat";
var name$c = "@firebase/installations";
var name$b = "@firebase/installations-compat";
var name$a = "@firebase/messaging";
var name$9 = "@firebase/messaging-compat";
var name$8 = "@firebase/performance";
var name$7 = "@firebase/performance-compat";
var name$6 = "@firebase/remote-config";
var name$5 = "@firebase/remote-config-compat";
var name$4 = "@firebase/storage";
var name$3 = "@firebase/storage-compat";
var name$2 = "@firebase/firestore";
var name$1 = "@firebase/firestore-compat";
var name = "firebase";
var version2 = "9.23.0";
var DEFAULT_ENTRY_NAME2 = "[DEFAULT]";
var PLATFORM_LOG_STRING = {
  [name$o]: "fire-core",
  [name$n]: "fire-core-compat",
  [name$l]: "fire-analytics",
  [name$m]: "fire-analytics-compat",
  [name$j]: "fire-app-check",
  [name$k]: "fire-app-check-compat",
  [name$i]: "fire-auth",
  [name$h]: "fire-auth-compat",
  [name$g]: "fire-rtdb",
  [name$f]: "fire-rtdb-compat",
  [name$e]: "fire-fn",
  [name$d]: "fire-fn-compat",
  [name$c]: "fire-iid",
  [name$b]: "fire-iid-compat",
  [name$a]: "fire-fcm",
  [name$9]: "fire-fcm-compat",
  [name$8]: "fire-perf",
  [name$7]: "fire-perf-compat",
  [name$6]: "fire-rc",
  [name$5]: "fire-rc-compat",
  [name$4]: "fire-gcs",
  [name$3]: "fire-gcs-compat",
  [name$2]: "fire-fst",
  [name$1]: "fire-fst-compat",
  "fire-js": "fire-js",
  [name]: "fire-js-all"
};
var _apps = new Map;
var _components = new Map;
var ERRORS = {
  ["no-app"]: "No Firebase App '{$appName}' has been created - call initializeApp() first",
  ["bad-app-name"]: "Illegal App name: '{$appName}",
  ["duplicate-app"]: "Firebase App named '{$appName}' already exists with different options or config",
  ["app-deleted"]: "Firebase App named '{$appName}' already deleted",
  ["no-options"]: "Need to provide options, when not being deployed to hosting via source.",
  ["invalid-app-argument"]: "firebase.{$appName}() takes either no argument or a Firebase App instance.",
  ["invalid-log-argument"]: "First argument to `onLog` must be null or a function.",
  ["idb-open"]: "Error thrown when opening IndexedDB. Original error: {$originalErrorMessage}.",
  ["idb-get"]: "Error thrown when reading from IndexedDB. Original error: {$originalErrorMessage}.",
  ["idb-set"]: "Error thrown when writing to IndexedDB. Original error: {$originalErrorMessage}.",
  ["idb-delete"]: "Error thrown when deleting from IndexedDB. Original error: {$originalErrorMessage}."
};
var ERROR_FACTORY = new ErrorFactory("app", "Firebase", ERRORS);

class FirebaseAppImpl {
  constructor(options, config, container) {
    this._isDeleted = false;
    this._options = Object.assign({}, options);
    this._config = Object.assign({}, config);
    this._name = config.name;
    this._automaticDataCollectionEnabled = config.automaticDataCollectionEnabled;
    this._container = container;
    this.container.addComponent(new Component("app", () => this, "PUBLIC"));
  }
  get automaticDataCollectionEnabled() {
    this.checkDestroyed();
    return this._automaticDataCollectionEnabled;
  }
  set automaticDataCollectionEnabled(val) {
    this.checkDestroyed();
    this._automaticDataCollectionEnabled = val;
  }
  get name() {
    this.checkDestroyed();
    return this._name;
  }
  get options() {
    this.checkDestroyed();
    return this._options;
  }
  get config() {
    this.checkDestroyed();
    return this._config;
  }
  get container() {
    return this._container;
  }
  get isDeleted() {
    return this._isDeleted;
  }
  set isDeleted(val) {
    this._isDeleted = val;
  }
  checkDestroyed() {
    if (this.isDeleted) {
      throw ERROR_FACTORY.create("app-deleted", { appName: this._name });
    }
  }
}
var SDK_VERSION = version2;
var DB_NAME = "firebase-heartbeat-database";
var DB_VERSION = 1;
var STORE_NAME = "firebase-heartbeat-store";
var dbPromise = null;
var MAX_HEADER_BYTES = 1024;
var STORED_HEARTBEAT_RETENTION_MAX_MILLIS = 30 * 24 * 60 * 60 * 1000;

class HeartbeatServiceImpl {
  constructor(container) {
    this.container = container;
    this._heartbeatsCache = null;
    const app = this.container.getProvider("app").getImmediate();
    this._storage = new HeartbeatStorageImpl(app);
    this._heartbeatsCachePromise = this._storage.read().then((result) => {
      this._heartbeatsCache = result;
      return result;
    });
  }
  async triggerHeartbeat() {
    const platformLogger = this.container.getProvider("platform-logger").getImmediate();
    const agent = platformLogger.getPlatformInfoString();
    const date = getUTCDateString();
    if (this._heartbeatsCache === null) {
      this._heartbeatsCache = await this._heartbeatsCachePromise;
    }
    if (this._heartbeatsCache.lastSentHeartbeatDate === date || this._heartbeatsCache.heartbeats.some((singleDateHeartbeat) => singleDateHeartbeat.date === date)) {
      return;
    } else {
      this._heartbeatsCache.heartbeats.push({ date, agent });
    }
    this._heartbeatsCache.heartbeats = this._heartbeatsCache.heartbeats.filter((singleDateHeartbeat) => {
      const hbTimestamp = new Date(singleDateHeartbeat.date).valueOf();
      const now = Date.now();
      return now - hbTimestamp <= STORED_HEARTBEAT_RETENTION_MAX_MILLIS;
    });
    return this._storage.overwrite(this._heartbeatsCache);
  }
  async getHeartbeatsHeader() {
    if (this._heartbeatsCache === null) {
      await this._heartbeatsCachePromise;
    }
    if (this._heartbeatsCache === null || this._heartbeatsCache.heartbeats.length === 0) {
      return "";
    }
    const date = getUTCDateString();
    const { heartbeatsToSend, unsentEntries } = extractHeartbeatsForHeader(this._heartbeatsCache.heartbeats);
    const headerString = base64urlEncodeWithoutPadding(JSON.stringify({ version: 2, heartbeats: heartbeatsToSend }));
    this._heartbeatsCache.lastSentHeartbeatDate = date;
    if (unsentEntries.length > 0) {
      this._heartbeatsCache.heartbeats = unsentEntries;
      await this._storage.overwrite(this._heartbeatsCache);
    } else {
      this._heartbeatsCache.heartbeats = [];
      this._storage.overwrite(this._heartbeatsCache);
    }
    return headerString;
  }
}

class HeartbeatStorageImpl {
  constructor(app) {
    this.app = app;
    this._canUseIndexedDBPromise = this.runIndexedDBEnvironmentCheck();
  }
  async runIndexedDBEnvironmentCheck() {
    if (!isIndexedDBAvailable()) {
      return false;
    } else {
      return validateIndexedDBOpenable().then(() => true).catch(() => false);
    }
  }
  async read() {
    const canUseIndexedDB = await this._canUseIndexedDBPromise;
    if (!canUseIndexedDB) {
      return { heartbeats: [] };
    } else {
      const idbHeartbeatObject = await readHeartbeatsFromIndexedDB(this.app);
      return idbHeartbeatObject || { heartbeats: [] };
    }
  }
  async overwrite(heartbeatsObject) {
    var _a;
    const canUseIndexedDB = await this._canUseIndexedDBPromise;
    if (!canUseIndexedDB) {
      return;
    } else {
      const existingHeartbeatsObject = await this.read();
      return writeHeartbeatsToIndexedDB(this.app, {
        lastSentHeartbeatDate: (_a = heartbeatsObject.lastSentHeartbeatDate) !== null && _a !== undefined ? _a : existingHeartbeatsObject.lastSentHeartbeatDate,
        heartbeats: heartbeatsObject.heartbeats
      });
    }
  }
  async add(heartbeatsObject) {
    var _a;
    const canUseIndexedDB = await this._canUseIndexedDBPromise;
    if (!canUseIndexedDB) {
      return;
    } else {
      const existingHeartbeatsObject = await this.read();
      return writeHeartbeatsToIndexedDB(this.app, {
        lastSentHeartbeatDate: (_a = heartbeatsObject.lastSentHeartbeatDate) !== null && _a !== undefined ? _a : existingHeartbeatsObject.lastSentHeartbeatDate,
        heartbeats: [
          ...existingHeartbeatsObject.heartbeats,
          ...heartbeatsObject.heartbeats
        ]
      });
    }
  }
}
registerCoreComponents("");

// node_modules/@firebase/database/dist/node-esm/index.node.esm.js
var each = function(obj, fn) {
  for (const key in obj) {
    if (obj.hasOwnProperty(key)) {
      fn(key, obj[key]);
    }
  }
};
var errorForServerCode = function(code, query) {
  let reason = "Unknown Error";
  if (code === "too_big") {
    reason = "The data requested exceeds the maximum size that can be accessed with a single request.";
  } else if (code === "permission_denied") {
    reason = "Client doesn't have permission to access the desired data.";
  } else if (code === "unavailable") {
    reason = "The service is unavailable";
  }
  const error = new Error(code + " at " + query._path.toString() + ": " + reason);
  error.code = code.toUpperCase();
  return error;
};
var repoInfoNeedsQueryParam = function(repoInfo) {
  return repoInfo.host !== repoInfo.internalHost || repoInfo.isCustomHost() || repoInfo.includeNamespaceInQueryParams;
};
var repoInfoConnectionURL = function(repoInfo, type, params) {
  assert(typeof type === "string", "typeof type must == string");
  assert(typeof params === "object", "typeof params must == object");
  let connURL;
  if (type === WEBSOCKET) {
    connURL = (repoInfo.secure ? "wss://" : "ws://") + repoInfo.internalHost + "/.ws?";
  } else if (type === LONG_POLLING) {
    connURL = (repoInfo.secure ? "https://" : "http://") + repoInfo.internalHost + "/.lp?";
  } else {
    throw new Error("Unknown connection type: " + type);
  }
  if (repoInfoNeedsQueryParam(repoInfo)) {
    params["ns"] = repoInfo.namespace;
  }
  const pairs = [];
  each(params, (key, value) => {
    pairs.push(key + "=" + value);
  });
  return connURL + pairs.join("&");
};
var statsManagerGetCollection = function(repoInfo) {
  const hashString = repoInfo.toString();
  if (!collections[hashString]) {
    collections[hashString] = new StatsCollection;
  }
  return collections[hashString];
};
var statsManagerGetOrCreateReporter = function(repoInfo, creatorFunction) {
  const hashString = repoInfo.toString();
  if (!reporters[hashString]) {
    reporters[hashString] = creatorFunction();
  }
  return reporters[hashString];
};
var setSDKVersion = function(version3) {
  SDK_VERSION2 = version3;
};
var setWebSocketImpl = function(impl) {
  WebSocketImpl = impl;
};
var newEmptyPath = function() {
  return new Path3("");
};
var pathGetFront = function(path5) {
  if (path5.pieceNum_ >= path5.pieces_.length) {
    return null;
  }
  return path5.pieces_[path5.pieceNum_];
};
var pathGetLength = function(path5) {
  return path5.pieces_.length - path5.pieceNum_;
};
var pathPopFront = function(path5) {
  let pieceNum = path5.pieceNum_;
  if (pieceNum < path5.pieces_.length) {
    pieceNum++;
  }
  return new Path3(path5.pieces_, pieceNum);
};
var pathGetBack = function(path5) {
  if (path5.pieceNum_ < path5.pieces_.length) {
    return path5.pieces_[path5.pieces_.length - 1];
  }
  return null;
};
var pathToUrlEncodedString = function(path5) {
  let pathString = "";
  for (let i = path5.pieceNum_;i < path5.pieces_.length; i++) {
    if (path5.pieces_[i] !== "") {
      pathString += "/" + encodeURIComponent(String(path5.pieces_[i]));
    }
  }
  return pathString || "/";
};
var pathSlice = function(path5, begin = 0) {
  return path5.pieces_.slice(path5.pieceNum_ + begin);
};
var pathParent = function(path5) {
  if (path5.pieceNum_ >= path5.pieces_.length) {
    return null;
  }
  const pieces = [];
  for (let i = path5.pieceNum_;i < path5.pieces_.length - 1; i++) {
    pieces.push(path5.pieces_[i]);
  }
  return new Path3(pieces, 0);
};
var pathChild = function(path5, childPathObj) {
  const pieces = [];
  for (let i = path5.pieceNum_;i < path5.pieces_.length; i++) {
    pieces.push(path5.pieces_[i]);
  }
  if (childPathObj instanceof Path3) {
    for (let i = childPathObj.pieceNum_;i < childPathObj.pieces_.length; i++) {
      pieces.push(childPathObj.pieces_[i]);
    }
  } else {
    const childPieces = childPathObj.split("/");
    for (let i = 0;i < childPieces.length; i++) {
      if (childPieces[i].length > 0) {
        pieces.push(childPieces[i]);
      }
    }
  }
  return new Path3(pieces, 0);
};
var pathIsEmpty = function(path5) {
  return path5.pieceNum_ >= path5.pieces_.length;
};
var newRelativePath = function(outerPath, innerPath) {
  const outer = pathGetFront(outerPath), inner = pathGetFront(innerPath);
  if (outer === null) {
    return innerPath;
  } else if (outer === inner) {
    return newRelativePath(pathPopFront(outerPath), pathPopFront(innerPath));
  } else {
    throw new Error("INTERNAL ERROR: innerPath (" + innerPath + ") is not within outerPath (" + outerPath + ")");
  }
};
var pathEquals = function(path5, other) {
  if (pathGetLength(path5) !== pathGetLength(other)) {
    return false;
  }
  for (let i = path5.pieceNum_, j = other.pieceNum_;i <= path5.pieces_.length; i++, j++) {
    if (path5.pieces_[i] !== other.pieces_[j]) {
      return false;
    }
  }
  return true;
};
var pathContains = function(path5, other) {
  let i = path5.pieceNum_;
  let j = other.pieceNum_;
  if (pathGetLength(path5) > pathGetLength(other)) {
    return false;
  }
  while (i < path5.pieces_.length) {
    if (path5.pieces_[i] !== other.pieces_[j]) {
      return false;
    }
    ++i;
    ++j;
  }
  return true;
};
var validationPathPush = function(validationPath, child) {
  if (validationPath.parts_.length > 0) {
    validationPath.byteLength_ += 1;
  }
  validationPath.parts_.push(child);
  validationPath.byteLength_ += stringLength(child);
  validationPathCheckValid(validationPath);
};
var validationPathPop = function(validationPath) {
  const last = validationPath.parts_.pop();
  validationPath.byteLength_ -= stringLength(last);
  if (validationPath.parts_.length > 0) {
    validationPath.byteLength_ -= 1;
  }
};
var validationPathCheckValid = function(validationPath) {
  if (validationPath.byteLength_ > MAX_PATH_LENGTH_BYTES) {
    throw new Error(validationPath.errorPrefix_ + "has a key path longer than " + MAX_PATH_LENGTH_BYTES + " bytes (" + validationPath.byteLength_ + ").");
  }
  if (validationPath.parts_.length > MAX_PATH_DEPTH) {
    throw new Error(validationPath.errorPrefix_ + "path specified exceeds the maximum depth that can be written (" + MAX_PATH_DEPTH + ") or object contains a cycle " + validationPathToErrorString(validationPath));
  }
};
var validationPathToErrorString = function(validationPath) {
  if (validationPath.parts_.length === 0) {
    return "";
  }
  return "in property '" + validationPath.parts_.join(".") + "'";
};
var NAME_ONLY_COMPARATOR = function(left, right) {
  return nameCompare(left.name, right.name);
};
var NAME_COMPARATOR = function(left, right) {
  return nameCompare(left, right);
};
var setMaxNode$1 = function(val) {
  MAX_NODE$2 = val;
};
var setNodeFromJSON = function(val) {
  nodeFromJSON$1 = val;
};
var setMaxNode = function(val) {
  MAX_NODE$1 = val;
};
var nodeFromJSON = function(json, priority = null) {
  if (json === null) {
    return ChildrenNode.EMPTY_NODE;
  }
  if (typeof json === "object" && (".priority" in json)) {
    priority = json[".priority"];
  }
  assert(priority === null || typeof priority === "string" || typeof priority === "number" || typeof priority === "object" && (".sv" in priority), "Invalid priority type found: " + typeof priority);
  if (typeof json === "object" && (".value" in json) && json[".value"] !== null) {
    json = json[".value"];
  }
  if (typeof json !== "object" || (".sv" in json)) {
    const jsonLeaf = json;
    return new LeafNode(jsonLeaf, nodeFromJSON(priority));
  }
  if (!(json instanceof Array) && USE_HINZE) {
    const children = [];
    let childrenHavePriority = false;
    const hinzeJsonObj = json;
    each(hinzeJsonObj, (key, child) => {
      if (key.substring(0, 1) !== ".") {
        const childNode = nodeFromJSON(child);
        if (!childNode.isEmpty()) {
          childrenHavePriority = childrenHavePriority || !childNode.getPriority().isEmpty();
          children.push(new NamedNode(key, childNode));
        }
      }
    });
    if (children.length === 0) {
      return ChildrenNode.EMPTY_NODE;
    }
    const childSet = buildChildSet(children, NAME_ONLY_COMPARATOR, (namedNode) => namedNode.name, NAME_COMPARATOR);
    if (childrenHavePriority) {
      const sortedChildSet = buildChildSet(children, PRIORITY_INDEX.getCompare());
      return new ChildrenNode(childSet, nodeFromJSON(priority), new IndexMap({ ".priority": sortedChildSet }, { ".priority": PRIORITY_INDEX }));
    } else {
      return new ChildrenNode(childSet, nodeFromJSON(priority), IndexMap.Default);
    }
  } else {
    let node = ChildrenNode.EMPTY_NODE;
    each(json, (key, childData) => {
      if (contains(json, key)) {
        if (key.substring(0, 1) !== ".") {
          const childNode = nodeFromJSON(childData);
          if (childNode.isLeafNode() || !childNode.isEmpty()) {
            node = node.updateImmediateChild(key, childNode);
          }
        }
      }
    });
    return node.updatePriority(nodeFromJSON(priority));
  }
};
var changeValue = function(snapshotNode) {
  return { type: "value", snapshotNode };
};
var changeChildAdded = function(childName, snapshotNode) {
  return { type: "child_added", snapshotNode, childName };
};
var changeChildRemoved = function(childName, snapshotNode) {
  return { type: "child_removed", snapshotNode, childName };
};
var changeChildChanged = function(childName, snapshotNode, oldSnap) {
  return {
    type: "child_changed",
    snapshotNode,
    childName,
    oldSnap
  };
};
var changeChildMoved = function(childName, snapshotNode) {
  return { type: "child_moved", snapshotNode, childName };
};
var queryParamsGetNodeFilter = function(queryParams) {
  if (queryParams.loadsAllData()) {
    return new IndexedFilter(queryParams.getIndex());
  } else if (queryParams.hasLimit()) {
    return new LimitedFilter(queryParams);
  } else {
    return new RangedFilter(queryParams);
  }
};
var queryParamsToRestQueryStringParameters = function(queryParams) {
  const qs = {};
  if (queryParams.isDefault()) {
    return qs;
  }
  let orderBy;
  if (queryParams.index_ === PRIORITY_INDEX) {
    orderBy = "$priority";
  } else if (queryParams.index_ === VALUE_INDEX) {
    orderBy = "$value";
  } else if (queryParams.index_ === KEY_INDEX) {
    orderBy = "$key";
  } else {
    assert(queryParams.index_ instanceof PathIndex, "Unrecognized index type!");
    orderBy = queryParams.index_.toString();
  }
  qs["orderBy"] = stringify(orderBy);
  if (queryParams.startSet_) {
    const startParam = queryParams.startAfterSet_ ? "startAfter" : "startAt";
    qs[startParam] = stringify(queryParams.indexStartValue_);
    if (queryParams.startNameSet_) {
      qs[startParam] += "," + stringify(queryParams.indexStartName_);
    }
  }
  if (queryParams.endSet_) {
    const endParam = queryParams.endBeforeSet_ ? "endBefore" : "endAt";
    qs[endParam] = stringify(queryParams.indexEndValue_);
    if (queryParams.endNameSet_) {
      qs[endParam] += "," + stringify(queryParams.indexEndName_);
    }
  }
  if (queryParams.limitSet_) {
    if (queryParams.isViewFromLeft()) {
      qs["limitToFirst"] = queryParams.limit_;
    } else {
      qs["limitToLast"] = queryParams.limit_;
    }
  }
  return qs;
};
var queryParamsGetQueryObject = function(queryParams) {
  const obj = {};
  if (queryParams.startSet_) {
    obj["sp"] = queryParams.indexStartValue_;
    if (queryParams.startNameSet_) {
      obj["sn"] = queryParams.indexStartName_;
    }
    obj["sin"] = !queryParams.startAfterSet_;
  }
  if (queryParams.endSet_) {
    obj["ep"] = queryParams.indexEndValue_;
    if (queryParams.endNameSet_) {
      obj["en"] = queryParams.indexEndName_;
    }
    obj["ein"] = !queryParams.endBeforeSet_;
  }
  if (queryParams.limitSet_) {
    obj["l"] = queryParams.limit_;
    let viewFrom = queryParams.viewFrom_;
    if (viewFrom === "") {
      if (queryParams.isViewFromLeft()) {
        viewFrom = "l";
      } else {
        viewFrom = "r";
      }
    }
    obj["vf"] = viewFrom;
  }
  if (queryParams.index_ !== PRIORITY_INDEX) {
    obj["i"] = queryParams.index_.toString();
  }
  return obj;
};
var newSparseSnapshotTree = function() {
  return {
    value: null,
    children: new Map
  };
};
var sparseSnapshotTreeRemember = function(sparseSnapshotTree, path5, data) {
  if (pathIsEmpty(path5)) {
    sparseSnapshotTree.value = data;
    sparseSnapshotTree.children.clear();
  } else if (sparseSnapshotTree.value !== null) {
    sparseSnapshotTree.value = sparseSnapshotTree.value.updateChild(path5, data);
  } else {
    const childKey = pathGetFront(path5);
    if (!sparseSnapshotTree.children.has(childKey)) {
      sparseSnapshotTree.children.set(childKey, newSparseSnapshotTree());
    }
    const child = sparseSnapshotTree.children.get(childKey);
    path5 = pathPopFront(path5);
    sparseSnapshotTreeRemember(child, path5, data);
  }
};
var sparseSnapshotTreeForEachTree = function(sparseSnapshotTree, prefixPath, func) {
  if (sparseSnapshotTree.value !== null) {
    func(prefixPath, sparseSnapshotTree.value);
  } else {
    sparseSnapshotTreeForEachChild(sparseSnapshotTree, (key, tree) => {
      const path5 = new Path3(prefixPath.toString() + "/" + key);
      sparseSnapshotTreeForEachTree(tree, path5, func);
    });
  }
};
var sparseSnapshotTreeForEachChild = function(sparseSnapshotTree, func) {
  sparseSnapshotTree.children.forEach((tree, key) => {
    func(key, tree);
  });
};
var newOperationSourceUser = function() {
  return {
    fromUser: true,
    fromServer: false,
    queryId: null,
    tagged: false
  };
};
var newOperationSourceServer = function() {
  return {
    fromUser: false,
    fromServer: true,
    queryId: null,
    tagged: false
  };
};
var newOperationSourceServerTaggedQuery = function(queryId) {
  return {
    fromUser: false,
    fromServer: true,
    queryId,
    tagged: true
  };
};
var eventGeneratorGenerateEventsForChanges = function(eventGenerator, changes, eventCache, eventRegistrations) {
  const events = [];
  const moves = [];
  changes.forEach((change) => {
    if (change.type === "child_changed" && eventGenerator.index_.indexedValueChanged(change.oldSnap, change.snapshotNode)) {
      moves.push(changeChildMoved(change.childName, change.snapshotNode));
    }
  });
  eventGeneratorGenerateEventsForType(eventGenerator, events, "child_removed", changes, eventRegistrations, eventCache);
  eventGeneratorGenerateEventsForType(eventGenerator, events, "child_added", changes, eventRegistrations, eventCache);
  eventGeneratorGenerateEventsForType(eventGenerator, events, "child_moved", moves, eventRegistrations, eventCache);
  eventGeneratorGenerateEventsForType(eventGenerator, events, "child_changed", changes, eventRegistrations, eventCache);
  eventGeneratorGenerateEventsForType(eventGenerator, events, "value", changes, eventRegistrations, eventCache);
  return events;
};
var eventGeneratorGenerateEventsForType = function(eventGenerator, events, eventType, changes, registrations, eventCache) {
  const filteredChanges = changes.filter((change) => change.type === eventType);
  filteredChanges.sort((a, b) => eventGeneratorCompareChanges(eventGenerator, a, b));
  filteredChanges.forEach((change) => {
    const materializedChange = eventGeneratorMaterializeSingleChange(eventGenerator, change, eventCache);
    registrations.forEach((registration) => {
      if (registration.respondsTo(change.type)) {
        events.push(registration.createEvent(materializedChange, eventGenerator.query_));
      }
    });
  });
};
var eventGeneratorMaterializeSingleChange = function(eventGenerator, change, eventCache) {
  if (change.type === "value" || change.type === "child_removed") {
    return change;
  } else {
    change.prevName = eventCache.getPredecessorChildName(change.childName, change.snapshotNode, eventGenerator.index_);
    return change;
  }
};
var eventGeneratorCompareChanges = function(eventGenerator, a, b) {
  if (a.childName == null || b.childName == null) {
    throw assertionError("Should only compare child_ events.");
  }
  const aWrapped = new NamedNode(a.childName, a.snapshotNode);
  const bWrapped = new NamedNode(b.childName, b.snapshotNode);
  return eventGenerator.index_.compare(aWrapped, bWrapped);
};
var newViewCache = function(eventCache, serverCache) {
  return { eventCache, serverCache };
};
var viewCacheUpdateEventSnap = function(viewCache, eventSnap, complete, filtered) {
  return newViewCache(new CacheNode(eventSnap, complete, filtered), viewCache.serverCache);
};
var viewCacheUpdateServerSnap = function(viewCache, serverSnap, complete, filtered) {
  return newViewCache(viewCache.eventCache, new CacheNode(serverSnap, complete, filtered));
};
var viewCacheGetCompleteEventSnap = function(viewCache) {
  return viewCache.eventCache.isFullyInitialized() ? viewCache.eventCache.getNode() : null;
};
var viewCacheGetCompleteServerSnap = function(viewCache) {
  return viewCache.serverCache.isFullyInitialized() ? viewCache.serverCache.getNode() : null;
};
var compoundWriteAddWrite = function(compoundWrite, path5, node) {
  if (pathIsEmpty(path5)) {
    return new CompoundWrite(new ImmutableTree(node));
  } else {
    const rootmost = compoundWrite.writeTree_.findRootMostValueAndPath(path5);
    if (rootmost != null) {
      const rootMostPath = rootmost.path;
      let value = rootmost.value;
      const relativePath = newRelativePath(rootMostPath, path5);
      value = value.updateChild(relativePath, node);
      return new CompoundWrite(compoundWrite.writeTree_.set(rootMostPath, value));
    } else {
      const subtree = new ImmutableTree(node);
      const newWriteTree = compoundWrite.writeTree_.setTree(path5, subtree);
      return new CompoundWrite(newWriteTree);
    }
  }
};
var compoundWriteAddWrites = function(compoundWrite, path5, updates) {
  let newWrite = compoundWrite;
  each(updates, (childKey, node) => {
    newWrite = compoundWriteAddWrite(newWrite, pathChild(path5, childKey), node);
  });
  return newWrite;
};
var compoundWriteRemoveWrite = function(compoundWrite, path5) {
  if (pathIsEmpty(path5)) {
    return CompoundWrite.empty();
  } else {
    const newWriteTree = compoundWrite.writeTree_.setTree(path5, new ImmutableTree(null));
    return new CompoundWrite(newWriteTree);
  }
};
var compoundWriteHasCompleteWrite = function(compoundWrite, path5) {
  return compoundWriteGetCompleteNode(compoundWrite, path5) != null;
};
var compoundWriteGetCompleteNode = function(compoundWrite, path5) {
  const rootmost = compoundWrite.writeTree_.findRootMostValueAndPath(path5);
  if (rootmost != null) {
    return compoundWrite.writeTree_.get(rootmost.path).getChild(newRelativePath(rootmost.path, path5));
  } else {
    return null;
  }
};
var compoundWriteGetCompleteChildren = function(compoundWrite) {
  const children = [];
  const node = compoundWrite.writeTree_.value;
  if (node != null) {
    if (!node.isLeafNode()) {
      node.forEachChild(PRIORITY_INDEX, (childName, childNode) => {
        children.push(new NamedNode(childName, childNode));
      });
    }
  } else {
    compoundWrite.writeTree_.children.inorderTraversal((childName, childTree) => {
      if (childTree.value != null) {
        children.push(new NamedNode(childName, childTree.value));
      }
    });
  }
  return children;
};
var compoundWriteChildCompoundWrite = function(compoundWrite, path5) {
  if (pathIsEmpty(path5)) {
    return compoundWrite;
  } else {
    const shadowingNode = compoundWriteGetCompleteNode(compoundWrite, path5);
    if (shadowingNode != null) {
      return new CompoundWrite(new ImmutableTree(shadowingNode));
    } else {
      return new CompoundWrite(compoundWrite.writeTree_.subtree(path5));
    }
  }
};
var compoundWriteIsEmpty = function(compoundWrite) {
  return compoundWrite.writeTree_.isEmpty();
};
var compoundWriteApply = function(compoundWrite, node) {
  return applySubtreeWrite(newEmptyPath(), compoundWrite.writeTree_, node);
};
var applySubtreeWrite = function(relativePath, writeTree, node) {
  if (writeTree.value != null) {
    return node.updateChild(relativePath, writeTree.value);
  } else {
    let priorityWrite = null;
    writeTree.children.inorderTraversal((childKey, childTree) => {
      if (childKey === ".priority") {
        assert(childTree.value !== null, "Priority writes must always be leaf nodes");
        priorityWrite = childTree.value;
      } else {
        node = applySubtreeWrite(pathChild(relativePath, childKey), childTree, node);
      }
    });
    if (!node.getChild(relativePath).isEmpty() && priorityWrite !== null) {
      node = node.updateChild(pathChild(relativePath, ".priority"), priorityWrite);
    }
    return node;
  }
};
var writeTreeChildWrites = function(writeTree, path5) {
  return newWriteTreeRef(path5, writeTree);
};
var writeTreeAddOverwrite = function(writeTree, path5, snap, writeId, visible) {
  assert(writeId > writeTree.lastWriteId, "Stacking an older write on top of newer ones");
  if (visible === undefined) {
    visible = true;
  }
  writeTree.allWrites.push({
    path: path5,
    snap,
    writeId,
    visible
  });
  if (visible) {
    writeTree.visibleWrites = compoundWriteAddWrite(writeTree.visibleWrites, path5, snap);
  }
  writeTree.lastWriteId = writeId;
};
var writeTreeGetWrite = function(writeTree, writeId) {
  for (let i = 0;i < writeTree.allWrites.length; i++) {
    const record = writeTree.allWrites[i];
    if (record.writeId === writeId) {
      return record;
    }
  }
  return null;
};
var writeTreeRemoveWrite = function(writeTree, writeId) {
  const idx = writeTree.allWrites.findIndex((s) => {
    return s.writeId === writeId;
  });
  assert(idx >= 0, "removeWrite called with nonexistent writeId.");
  const writeToRemove = writeTree.allWrites[idx];
  writeTree.allWrites.splice(idx, 1);
  let removedWriteWasVisible = writeToRemove.visible;
  let removedWriteOverlapsWithOtherWrites = false;
  let i = writeTree.allWrites.length - 1;
  while (removedWriteWasVisible && i >= 0) {
    const currentWrite = writeTree.allWrites[i];
    if (currentWrite.visible) {
      if (i >= idx && writeTreeRecordContainsPath_(currentWrite, writeToRemove.path)) {
        removedWriteWasVisible = false;
      } else if (pathContains(writeToRemove.path, currentWrite.path)) {
        removedWriteOverlapsWithOtherWrites = true;
      }
    }
    i--;
  }
  if (!removedWriteWasVisible) {
    return false;
  } else if (removedWriteOverlapsWithOtherWrites) {
    writeTreeResetTree_(writeTree);
    return true;
  } else {
    if (writeToRemove.snap) {
      writeTree.visibleWrites = compoundWriteRemoveWrite(writeTree.visibleWrites, writeToRemove.path);
    } else {
      const children = writeToRemove.children;
      each(children, (childName) => {
        writeTree.visibleWrites = compoundWriteRemoveWrite(writeTree.visibleWrites, pathChild(writeToRemove.path, childName));
      });
    }
    return true;
  }
};
var writeTreeRecordContainsPath_ = function(writeRecord, path5) {
  if (writeRecord.snap) {
    return pathContains(writeRecord.path, path5);
  } else {
    for (const childName in writeRecord.children) {
      if (writeRecord.children.hasOwnProperty(childName) && pathContains(pathChild(writeRecord.path, childName), path5)) {
        return true;
      }
    }
    return false;
  }
};
var writeTreeResetTree_ = function(writeTree) {
  writeTree.visibleWrites = writeTreeLayerTree_(writeTree.allWrites, writeTreeDefaultFilter_, newEmptyPath());
  if (writeTree.allWrites.length > 0) {
    writeTree.lastWriteId = writeTree.allWrites[writeTree.allWrites.length - 1].writeId;
  } else {
    writeTree.lastWriteId = -1;
  }
};
var writeTreeDefaultFilter_ = function(write) {
  return write.visible;
};
var writeTreeLayerTree_ = function(writes, filter, treeRoot) {
  let compoundWrite = CompoundWrite.empty();
  for (let i = 0;i < writes.length; ++i) {
    const write = writes[i];
    if (filter(write)) {
      const writePath = write.path;
      let relativePath;
      if (write.snap) {
        if (pathContains(treeRoot, writePath)) {
          relativePath = newRelativePath(treeRoot, writePath);
          compoundWrite = compoundWriteAddWrite(compoundWrite, relativePath, write.snap);
        } else if (pathContains(writePath, treeRoot)) {
          relativePath = newRelativePath(writePath, treeRoot);
          compoundWrite = compoundWriteAddWrite(compoundWrite, newEmptyPath(), write.snap.getChild(relativePath));
        } else
          ;
      } else if (write.children) {
        if (pathContains(treeRoot, writePath)) {
          relativePath = newRelativePath(treeRoot, writePath);
          compoundWrite = compoundWriteAddWrites(compoundWrite, relativePath, write.children);
        } else if (pathContains(writePath, treeRoot)) {
          relativePath = newRelativePath(writePath, treeRoot);
          if (pathIsEmpty(relativePath)) {
            compoundWrite = compoundWriteAddWrites(compoundWrite, newEmptyPath(), write.children);
          } else {
            const child = safeGet(write.children, pathGetFront(relativePath));
            if (child) {
              const deepNode = child.getChild(pathPopFront(relativePath));
              compoundWrite = compoundWriteAddWrite(compoundWrite, newEmptyPath(), deepNode);
            }
          }
        } else
          ;
      } else {
        throw assertionError("WriteRecord should have .snap or .children");
      }
    }
  }
  return compoundWrite;
};
var writeTreeCalcCompleteEventCache = function(writeTree, treePath, completeServerCache, writeIdsToExclude, includeHiddenWrites) {
  if (!writeIdsToExclude && !includeHiddenWrites) {
    const shadowingNode = compoundWriteGetCompleteNode(writeTree.visibleWrites, treePath);
    if (shadowingNode != null) {
      return shadowingNode;
    } else {
      const subMerge = compoundWriteChildCompoundWrite(writeTree.visibleWrites, treePath);
      if (compoundWriteIsEmpty(subMerge)) {
        return completeServerCache;
      } else if (completeServerCache == null && !compoundWriteHasCompleteWrite(subMerge, newEmptyPath())) {
        return null;
      } else {
        const layeredCache = completeServerCache || ChildrenNode.EMPTY_NODE;
        return compoundWriteApply(subMerge, layeredCache);
      }
    }
  } else {
    const merge = compoundWriteChildCompoundWrite(writeTree.visibleWrites, treePath);
    if (!includeHiddenWrites && compoundWriteIsEmpty(merge)) {
      return completeServerCache;
    } else {
      if (!includeHiddenWrites && completeServerCache == null && !compoundWriteHasCompleteWrite(merge, newEmptyPath())) {
        return null;
      } else {
        const filter = function(write) {
          return (write.visible || includeHiddenWrites) && (!writeIdsToExclude || !~writeIdsToExclude.indexOf(write.writeId)) && (pathContains(write.path, treePath) || pathContains(treePath, write.path));
        };
        const mergeAtPath = writeTreeLayerTree_(writeTree.allWrites, filter, treePath);
        const layeredCache = completeServerCache || ChildrenNode.EMPTY_NODE;
        return compoundWriteApply(mergeAtPath, layeredCache);
      }
    }
  }
};
var writeTreeCalcCompleteEventChildren = function(writeTree, treePath, completeServerChildren) {
  let completeChildren = ChildrenNode.EMPTY_NODE;
  const topLevelSet = compoundWriteGetCompleteNode(writeTree.visibleWrites, treePath);
  if (topLevelSet) {
    if (!topLevelSet.isLeafNode()) {
      topLevelSet.forEachChild(PRIORITY_INDEX, (childName, childSnap) => {
        completeChildren = completeChildren.updateImmediateChild(childName, childSnap);
      });
    }
    return completeChildren;
  } else if (completeServerChildren) {
    const merge = compoundWriteChildCompoundWrite(writeTree.visibleWrites, treePath);
    completeServerChildren.forEachChild(PRIORITY_INDEX, (childName, childNode) => {
      const node = compoundWriteApply(compoundWriteChildCompoundWrite(merge, new Path3(childName)), childNode);
      completeChildren = completeChildren.updateImmediateChild(childName, node);
    });
    compoundWriteGetCompleteChildren(merge).forEach((namedNode) => {
      completeChildren = completeChildren.updateImmediateChild(namedNode.name, namedNode.node);
    });
    return completeChildren;
  } else {
    const merge = compoundWriteChildCompoundWrite(writeTree.visibleWrites, treePath);
    compoundWriteGetCompleteChildren(merge).forEach((namedNode) => {
      completeChildren = completeChildren.updateImmediateChild(namedNode.name, namedNode.node);
    });
    return completeChildren;
  }
};
var writeTreeCalcEventCacheAfterServerOverwrite = function(writeTree, treePath, childPath, existingEventSnap, existingServerSnap) {
  assert(existingEventSnap || existingServerSnap, "Either existingEventSnap or existingServerSnap must exist");
  const path5 = pathChild(treePath, childPath);
  if (compoundWriteHasCompleteWrite(writeTree.visibleWrites, path5)) {
    return null;
  } else {
    const childMerge = compoundWriteChildCompoundWrite(writeTree.visibleWrites, path5);
    if (compoundWriteIsEmpty(childMerge)) {
      return existingServerSnap.getChild(childPath);
    } else {
      return compoundWriteApply(childMerge, existingServerSnap.getChild(childPath));
    }
  }
};
var writeTreeCalcCompleteChild = function(writeTree, treePath, childKey, existingServerSnap) {
  const path5 = pathChild(treePath, childKey);
  const shadowingNode = compoundWriteGetCompleteNode(writeTree.visibleWrites, path5);
  if (shadowingNode != null) {
    return shadowingNode;
  } else {
    if (existingServerSnap.isCompleteForChild(childKey)) {
      const childMerge = compoundWriteChildCompoundWrite(writeTree.visibleWrites, path5);
      return compoundWriteApply(childMerge, existingServerSnap.getNode().getImmediateChild(childKey));
    } else {
      return null;
    }
  }
};
var writeTreeShadowingWrite = function(writeTree, path5) {
  return compoundWriteGetCompleteNode(writeTree.visibleWrites, path5);
};
var writeTreeCalcIndexedSlice = function(writeTree, treePath, completeServerData, startPost, count, reverse, index) {
  let toIterate;
  const merge = compoundWriteChildCompoundWrite(writeTree.visibleWrites, treePath);
  const shadowingNode = compoundWriteGetCompleteNode(merge, newEmptyPath());
  if (shadowingNode != null) {
    toIterate = shadowingNode;
  } else if (completeServerData != null) {
    toIterate = compoundWriteApply(merge, completeServerData);
  } else {
    return [];
  }
  toIterate = toIterate.withIndex(index);
  if (!toIterate.isEmpty() && !toIterate.isLeafNode()) {
    const nodes = [];
    const cmp = index.getCompare();
    const iter = reverse ? toIterate.getReverseIteratorFrom(startPost, index) : toIterate.getIteratorFrom(startPost, index);
    let next = iter.getNext();
    while (next && nodes.length < count) {
      if (cmp(next, startPost) !== 0) {
        nodes.push(next);
      }
      next = iter.getNext();
    }
    return nodes;
  } else {
    return [];
  }
};
var newWriteTree = function() {
  return {
    visibleWrites: CompoundWrite.empty(),
    allWrites: [],
    lastWriteId: -1
  };
};
var writeTreeRefCalcCompleteEventCache = function(writeTreeRef, completeServerCache, writeIdsToExclude, includeHiddenWrites) {
  return writeTreeCalcCompleteEventCache(writeTreeRef.writeTree, writeTreeRef.treePath, completeServerCache, writeIdsToExclude, includeHiddenWrites);
};
var writeTreeRefCalcCompleteEventChildren = function(writeTreeRef, completeServerChildren) {
  return writeTreeCalcCompleteEventChildren(writeTreeRef.writeTree, writeTreeRef.treePath, completeServerChildren);
};
var writeTreeRefCalcEventCacheAfterServerOverwrite = function(writeTreeRef, path5, existingEventSnap, existingServerSnap) {
  return writeTreeCalcEventCacheAfterServerOverwrite(writeTreeRef.writeTree, writeTreeRef.treePath, path5, existingEventSnap, existingServerSnap);
};
var writeTreeRefShadowingWrite = function(writeTreeRef, path5) {
  return writeTreeShadowingWrite(writeTreeRef.writeTree, pathChild(writeTreeRef.treePath, path5));
};
var writeTreeRefCalcIndexedSlice = function(writeTreeRef, completeServerData, startPost, count, reverse, index) {
  return writeTreeCalcIndexedSlice(writeTreeRef.writeTree, writeTreeRef.treePath, completeServerData, startPost, count, reverse, index);
};
var writeTreeRefCalcCompleteChild = function(writeTreeRef, childKey, existingServerCache) {
  return writeTreeCalcCompleteChild(writeTreeRef.writeTree, writeTreeRef.treePath, childKey, existingServerCache);
};
var writeTreeRefChild = function(writeTreeRef, childName) {
  return newWriteTreeRef(pathChild(writeTreeRef.treePath, childName), writeTreeRef.writeTree);
};
var newWriteTreeRef = function(path5, writeTree) {
  return {
    treePath: path5,
    writeTree
  };
};
var newViewProcessor = function(filter) {
  return { filter };
};
var viewProcessorAssertIndexed = function(viewProcessor, viewCache) {
  assert(viewCache.eventCache.getNode().isIndexed(viewProcessor.filter.getIndex()), "Event snap not indexed");
  assert(viewCache.serverCache.getNode().isIndexed(viewProcessor.filter.getIndex()), "Server snap not indexed");
};
var viewProcessorApplyOperation = function(viewProcessor, oldViewCache, operation, writesCache, completeCache) {
  const accumulator = new ChildChangeAccumulator;
  let newViewCache2, filterServerNode;
  if (operation.type === OperationType.OVERWRITE) {
    const overwrite = operation;
    if (overwrite.source.fromUser) {
      newViewCache2 = viewProcessorApplyUserOverwrite(viewProcessor, oldViewCache, overwrite.path, overwrite.snap, writesCache, completeCache, accumulator);
    } else {
      assert(overwrite.source.fromServer, "Unknown source.");
      filterServerNode = overwrite.source.tagged || oldViewCache.serverCache.isFiltered() && !pathIsEmpty(overwrite.path);
      newViewCache2 = viewProcessorApplyServerOverwrite(viewProcessor, oldViewCache, overwrite.path, overwrite.snap, writesCache, completeCache, filterServerNode, accumulator);
    }
  } else if (operation.type === OperationType.MERGE) {
    const merge = operation;
    if (merge.source.fromUser) {
      newViewCache2 = viewProcessorApplyUserMerge(viewProcessor, oldViewCache, merge.path, merge.children, writesCache, completeCache, accumulator);
    } else {
      assert(merge.source.fromServer, "Unknown source.");
      filterServerNode = merge.source.tagged || oldViewCache.serverCache.isFiltered();
      newViewCache2 = viewProcessorApplyServerMerge(viewProcessor, oldViewCache, merge.path, merge.children, writesCache, completeCache, filterServerNode, accumulator);
    }
  } else if (operation.type === OperationType.ACK_USER_WRITE) {
    const ackUserWrite = operation;
    if (!ackUserWrite.revert) {
      newViewCache2 = viewProcessorAckUserWrite(viewProcessor, oldViewCache, ackUserWrite.path, ackUserWrite.affectedTree, writesCache, completeCache, accumulator);
    } else {
      newViewCache2 = viewProcessorRevertUserWrite(viewProcessor, oldViewCache, ackUserWrite.path, writesCache, completeCache, accumulator);
    }
  } else if (operation.type === OperationType.LISTEN_COMPLETE) {
    newViewCache2 = viewProcessorListenComplete(viewProcessor, oldViewCache, operation.path, writesCache, accumulator);
  } else {
    throw assertionError("Unknown operation type: " + operation.type);
  }
  const changes = accumulator.getChanges();
  viewProcessorMaybeAddValueEvent(oldViewCache, newViewCache2, changes);
  return { viewCache: newViewCache2, changes };
};
var viewProcessorMaybeAddValueEvent = function(oldViewCache, newViewCache2, accumulator) {
  const eventSnap = newViewCache2.eventCache;
  if (eventSnap.isFullyInitialized()) {
    const isLeafOrEmpty = eventSnap.getNode().isLeafNode() || eventSnap.getNode().isEmpty();
    const oldCompleteSnap = viewCacheGetCompleteEventSnap(oldViewCache);
    if (accumulator.length > 0 || !oldViewCache.eventCache.isFullyInitialized() || isLeafOrEmpty && !eventSnap.getNode().equals(oldCompleteSnap) || !eventSnap.getNode().getPriority().equals(oldCompleteSnap.getPriority())) {
      accumulator.push(changeValue(viewCacheGetCompleteEventSnap(newViewCache2)));
    }
  }
};
var viewProcessorGenerateEventCacheAfterServerEvent = function(viewProcessor, viewCache, changePath, writesCache, source2, accumulator) {
  const oldEventSnap = viewCache.eventCache;
  if (writeTreeRefShadowingWrite(writesCache, changePath) != null) {
    return viewCache;
  } else {
    let newEventCache, serverNode;
    if (pathIsEmpty(changePath)) {
      assert(viewCache.serverCache.isFullyInitialized(), "If change path is empty, we must have complete server data");
      if (viewCache.serverCache.isFiltered()) {
        const serverCache = viewCacheGetCompleteServerSnap(viewCache);
        const completeChildren = serverCache instanceof ChildrenNode ? serverCache : ChildrenNode.EMPTY_NODE;
        const completeEventChildren = writeTreeRefCalcCompleteEventChildren(writesCache, completeChildren);
        newEventCache = viewProcessor.filter.updateFullNode(viewCache.eventCache.getNode(), completeEventChildren, accumulator);
      } else {
        const completeNode = writeTreeRefCalcCompleteEventCache(writesCache, viewCacheGetCompleteServerSnap(viewCache));
        newEventCache = viewProcessor.filter.updateFullNode(viewCache.eventCache.getNode(), completeNode, accumulator);
      }
    } else {
      const childKey = pathGetFront(changePath);
      if (childKey === ".priority") {
        assert(pathGetLength(changePath) === 1, "Can't have a priority with additional path components");
        const oldEventNode = oldEventSnap.getNode();
        serverNode = viewCache.serverCache.getNode();
        const updatedPriority = writeTreeRefCalcEventCacheAfterServerOverwrite(writesCache, changePath, oldEventNode, serverNode);
        if (updatedPriority != null) {
          newEventCache = viewProcessor.filter.updatePriority(oldEventNode, updatedPriority);
        } else {
          newEventCache = oldEventSnap.getNode();
        }
      } else {
        const childChangePath = pathPopFront(changePath);
        let newEventChild;
        if (oldEventSnap.isCompleteForChild(childKey)) {
          serverNode = viewCache.serverCache.getNode();
          const eventChildUpdate = writeTreeRefCalcEventCacheAfterServerOverwrite(writesCache, changePath, oldEventSnap.getNode(), serverNode);
          if (eventChildUpdate != null) {
            newEventChild = oldEventSnap.getNode().getImmediateChild(childKey).updateChild(childChangePath, eventChildUpdate);
          } else {
            newEventChild = oldEventSnap.getNode().getImmediateChild(childKey);
          }
        } else {
          newEventChild = writeTreeRefCalcCompleteChild(writesCache, childKey, viewCache.serverCache);
        }
        if (newEventChild != null) {
          newEventCache = viewProcessor.filter.updateChild(oldEventSnap.getNode(), childKey, newEventChild, childChangePath, source2, accumulator);
        } else {
          newEventCache = oldEventSnap.getNode();
        }
      }
    }
    return viewCacheUpdateEventSnap(viewCache, newEventCache, oldEventSnap.isFullyInitialized() || pathIsEmpty(changePath), viewProcessor.filter.filtersNodes());
  }
};
var viewProcessorApplyServerOverwrite = function(viewProcessor, oldViewCache, changePath, changedSnap, writesCache, completeCache, filterServerNode, accumulator) {
  const oldServerSnap = oldViewCache.serverCache;
  let newServerCache;
  const serverFilter = filterServerNode ? viewProcessor.filter : viewProcessor.filter.getIndexedFilter();
  if (pathIsEmpty(changePath)) {
    newServerCache = serverFilter.updateFullNode(oldServerSnap.getNode(), changedSnap, null);
  } else if (serverFilter.filtersNodes() && !oldServerSnap.isFiltered()) {
    const newServerNode = oldServerSnap.getNode().updateChild(changePath, changedSnap);
    newServerCache = serverFilter.updateFullNode(oldServerSnap.getNode(), newServerNode, null);
  } else {
    const childKey = pathGetFront(changePath);
    if (!oldServerSnap.isCompleteForPath(changePath) && pathGetLength(changePath) > 1) {
      return oldViewCache;
    }
    const childChangePath = pathPopFront(changePath);
    const childNode = oldServerSnap.getNode().getImmediateChild(childKey);
    const newChildNode = childNode.updateChild(childChangePath, changedSnap);
    if (childKey === ".priority") {
      newServerCache = serverFilter.updatePriority(oldServerSnap.getNode(), newChildNode);
    } else {
      newServerCache = serverFilter.updateChild(oldServerSnap.getNode(), childKey, newChildNode, childChangePath, NO_COMPLETE_CHILD_SOURCE, null);
    }
  }
  const newViewCache2 = viewCacheUpdateServerSnap(oldViewCache, newServerCache, oldServerSnap.isFullyInitialized() || pathIsEmpty(changePath), serverFilter.filtersNodes());
  const source2 = new WriteTreeCompleteChildSource(writesCache, newViewCache2, completeCache);
  return viewProcessorGenerateEventCacheAfterServerEvent(viewProcessor, newViewCache2, changePath, writesCache, source2, accumulator);
};
var viewProcessorApplyUserOverwrite = function(viewProcessor, oldViewCache, changePath, changedSnap, writesCache, completeCache, accumulator) {
  const oldEventSnap = oldViewCache.eventCache;
  let newViewCache2, newEventCache;
  const source2 = new WriteTreeCompleteChildSource(writesCache, oldViewCache, completeCache);
  if (pathIsEmpty(changePath)) {
    newEventCache = viewProcessor.filter.updateFullNode(oldViewCache.eventCache.getNode(), changedSnap, accumulator);
    newViewCache2 = viewCacheUpdateEventSnap(oldViewCache, newEventCache, true, viewProcessor.filter.filtersNodes());
  } else {
    const childKey = pathGetFront(changePath);
    if (childKey === ".priority") {
      newEventCache = viewProcessor.filter.updatePriority(oldViewCache.eventCache.getNode(), changedSnap);
      newViewCache2 = viewCacheUpdateEventSnap(oldViewCache, newEventCache, oldEventSnap.isFullyInitialized(), oldEventSnap.isFiltered());
    } else {
      const childChangePath = pathPopFront(changePath);
      const oldChild = oldEventSnap.getNode().getImmediateChild(childKey);
      let newChild;
      if (pathIsEmpty(childChangePath)) {
        newChild = changedSnap;
      } else {
        const childNode = source2.getCompleteChild(childKey);
        if (childNode != null) {
          if (pathGetBack(childChangePath) === ".priority" && childNode.getChild(pathParent(childChangePath)).isEmpty()) {
            newChild = childNode;
          } else {
            newChild = childNode.updateChild(childChangePath, changedSnap);
          }
        } else {
          newChild = ChildrenNode.EMPTY_NODE;
        }
      }
      if (!oldChild.equals(newChild)) {
        const newEventSnap = viewProcessor.filter.updateChild(oldEventSnap.getNode(), childKey, newChild, childChangePath, source2, accumulator);
        newViewCache2 = viewCacheUpdateEventSnap(oldViewCache, newEventSnap, oldEventSnap.isFullyInitialized(), viewProcessor.filter.filtersNodes());
      } else {
        newViewCache2 = oldViewCache;
      }
    }
  }
  return newViewCache2;
};
var viewProcessorCacheHasChild = function(viewCache, childKey) {
  return viewCache.eventCache.isCompleteForChild(childKey);
};
var viewProcessorApplyUserMerge = function(viewProcessor, viewCache, path5, changedChildren, writesCache, serverCache, accumulator) {
  let curViewCache = viewCache;
  changedChildren.foreach((relativePath, childNode) => {
    const writePath = pathChild(path5, relativePath);
    if (viewProcessorCacheHasChild(viewCache, pathGetFront(writePath))) {
      curViewCache = viewProcessorApplyUserOverwrite(viewProcessor, curViewCache, writePath, childNode, writesCache, serverCache, accumulator);
    }
  });
  changedChildren.foreach((relativePath, childNode) => {
    const writePath = pathChild(path5, relativePath);
    if (!viewProcessorCacheHasChild(viewCache, pathGetFront(writePath))) {
      curViewCache = viewProcessorApplyUserOverwrite(viewProcessor, curViewCache, writePath, childNode, writesCache, serverCache, accumulator);
    }
  });
  return curViewCache;
};
var viewProcessorApplyMerge = function(viewProcessor, node, merge) {
  merge.foreach((relativePath, childNode) => {
    node = node.updateChild(relativePath, childNode);
  });
  return node;
};
var viewProcessorApplyServerMerge = function(viewProcessor, viewCache, path5, changedChildren, writesCache, serverCache, filterServerNode, accumulator) {
  if (viewCache.serverCache.getNode().isEmpty() && !viewCache.serverCache.isFullyInitialized()) {
    return viewCache;
  }
  let curViewCache = viewCache;
  let viewMergeTree;
  if (pathIsEmpty(path5)) {
    viewMergeTree = changedChildren;
  } else {
    viewMergeTree = new ImmutableTree(null).setTree(path5, changedChildren);
  }
  const serverNode = viewCache.serverCache.getNode();
  viewMergeTree.children.inorderTraversal((childKey, childTree) => {
    if (serverNode.hasChild(childKey)) {
      const serverChild = viewCache.serverCache.getNode().getImmediateChild(childKey);
      const newChild = viewProcessorApplyMerge(viewProcessor, serverChild, childTree);
      curViewCache = viewProcessorApplyServerOverwrite(viewProcessor, curViewCache, new Path3(childKey), newChild, writesCache, serverCache, filterServerNode, accumulator);
    }
  });
  viewMergeTree.children.inorderTraversal((childKey, childMergeTree) => {
    const isUnknownDeepMerge = !viewCache.serverCache.isCompleteForChild(childKey) && childMergeTree.value === null;
    if (!serverNode.hasChild(childKey) && !isUnknownDeepMerge) {
      const serverChild = viewCache.serverCache.getNode().getImmediateChild(childKey);
      const newChild = viewProcessorApplyMerge(viewProcessor, serverChild, childMergeTree);
      curViewCache = viewProcessorApplyServerOverwrite(viewProcessor, curViewCache, new Path3(childKey), newChild, writesCache, serverCache, filterServerNode, accumulator);
    }
  });
  return curViewCache;
};
var viewProcessorAckUserWrite = function(viewProcessor, viewCache, ackPath, affectedTree, writesCache, completeCache, accumulator) {
  if (writeTreeRefShadowingWrite(writesCache, ackPath) != null) {
    return viewCache;
  }
  const filterServerNode = viewCache.serverCache.isFiltered();
  const serverCache = viewCache.serverCache;
  if (affectedTree.value != null) {
    if (pathIsEmpty(ackPath) && serverCache.isFullyInitialized() || serverCache.isCompleteForPath(ackPath)) {
      return viewProcessorApplyServerOverwrite(viewProcessor, viewCache, ackPath, serverCache.getNode().getChild(ackPath), writesCache, completeCache, filterServerNode, accumulator);
    } else if (pathIsEmpty(ackPath)) {
      let changedChildren = new ImmutableTree(null);
      serverCache.getNode().forEachChild(KEY_INDEX, (name2, node) => {
        changedChildren = changedChildren.set(new Path3(name2), node);
      });
      return viewProcessorApplyServerMerge(viewProcessor, viewCache, ackPath, changedChildren, writesCache, completeCache, filterServerNode, accumulator);
    } else {
      return viewCache;
    }
  } else {
    let changedChildren = new ImmutableTree(null);
    affectedTree.foreach((mergePath, value) => {
      const serverCachePath = pathChild(ackPath, mergePath);
      if (serverCache.isCompleteForPath(serverCachePath)) {
        changedChildren = changedChildren.set(mergePath, serverCache.getNode().getChild(serverCachePath));
      }
    });
    return viewProcessorApplyServerMerge(viewProcessor, viewCache, ackPath, changedChildren, writesCache, completeCache, filterServerNode, accumulator);
  }
};
var viewProcessorListenComplete = function(viewProcessor, viewCache, path5, writesCache, accumulator) {
  const oldServerNode = viewCache.serverCache;
  const newViewCache2 = viewCacheUpdateServerSnap(viewCache, oldServerNode.getNode(), oldServerNode.isFullyInitialized() || pathIsEmpty(path5), oldServerNode.isFiltered());
  return viewProcessorGenerateEventCacheAfterServerEvent(viewProcessor, newViewCache2, path5, writesCache, NO_COMPLETE_CHILD_SOURCE, accumulator);
};
var viewProcessorRevertUserWrite = function(viewProcessor, viewCache, path5, writesCache, completeServerCache, accumulator) {
  let complete;
  if (writeTreeRefShadowingWrite(writesCache, path5) != null) {
    return viewCache;
  } else {
    const source2 = new WriteTreeCompleteChildSource(writesCache, viewCache, completeServerCache);
    const oldEventCache = viewCache.eventCache.getNode();
    let newEventCache;
    if (pathIsEmpty(path5) || pathGetFront(path5) === ".priority") {
      let newNode;
      if (viewCache.serverCache.isFullyInitialized()) {
        newNode = writeTreeRefCalcCompleteEventCache(writesCache, viewCacheGetCompleteServerSnap(viewCache));
      } else {
        const serverChildren = viewCache.serverCache.getNode();
        assert(serverChildren instanceof ChildrenNode, "serverChildren would be complete if leaf node");
        newNode = writeTreeRefCalcCompleteEventChildren(writesCache, serverChildren);
      }
      newNode = newNode;
      newEventCache = viewProcessor.filter.updateFullNode(oldEventCache, newNode, accumulator);
    } else {
      const childKey = pathGetFront(path5);
      let newChild = writeTreeRefCalcCompleteChild(writesCache, childKey, viewCache.serverCache);
      if (newChild == null && viewCache.serverCache.isCompleteForChild(childKey)) {
        newChild = oldEventCache.getImmediateChild(childKey);
      }
      if (newChild != null) {
        newEventCache = viewProcessor.filter.updateChild(oldEventCache, childKey, newChild, pathPopFront(path5), source2, accumulator);
      } else if (viewCache.eventCache.getNode().hasChild(childKey)) {
        newEventCache = viewProcessor.filter.updateChild(oldEventCache, childKey, ChildrenNode.EMPTY_NODE, pathPopFront(path5), source2, accumulator);
      } else {
        newEventCache = oldEventCache;
      }
      if (newEventCache.isEmpty() && viewCache.serverCache.isFullyInitialized()) {
        complete = writeTreeRefCalcCompleteEventCache(writesCache, viewCacheGetCompleteServerSnap(viewCache));
        if (complete.isLeafNode()) {
          newEventCache = viewProcessor.filter.updateFullNode(newEventCache, complete, accumulator);
        }
      }
    }
    complete = viewCache.serverCache.isFullyInitialized() || writeTreeRefShadowingWrite(writesCache, newEmptyPath()) != null;
    return viewCacheUpdateEventSnap(viewCache, newEventCache, complete, viewProcessor.filter.filtersNodes());
  }
};
var viewGetServerCache = function(view) {
  return view.viewCache_.serverCache.getNode();
};
var viewGetCompleteNode = function(view) {
  return viewCacheGetCompleteEventSnap(view.viewCache_);
};
var viewGetCompleteServerCache = function(view, path5) {
  const cache = viewCacheGetCompleteServerSnap(view.viewCache_);
  if (cache) {
    if (view.query._queryParams.loadsAllData() || !pathIsEmpty(path5) && !cache.getImmediateChild(pathGetFront(path5)).isEmpty()) {
      return cache.getChild(path5);
    }
  }
  return null;
};
var viewIsEmpty = function(view) {
  return view.eventRegistrations_.length === 0;
};
var viewAddEventRegistration = function(view, eventRegistration) {
  view.eventRegistrations_.push(eventRegistration);
};
var viewRemoveEventRegistration = function(view, eventRegistration, cancelError) {
  const cancelEvents = [];
  if (cancelError) {
    assert(eventRegistration == null, "A cancel should cancel all event registrations.");
    const path5 = view.query._path;
    view.eventRegistrations_.forEach((registration) => {
      const maybeEvent = registration.createCancelEvent(cancelError, path5);
      if (maybeEvent) {
        cancelEvents.push(maybeEvent);
      }
    });
  }
  if (eventRegistration) {
    let remaining = [];
    for (let i = 0;i < view.eventRegistrations_.length; ++i) {
      const existing = view.eventRegistrations_[i];
      if (!existing.matches(eventRegistration)) {
        remaining.push(existing);
      } else if (eventRegistration.hasAnyCallback()) {
        remaining = remaining.concat(view.eventRegistrations_.slice(i + 1));
        break;
      }
    }
    view.eventRegistrations_ = remaining;
  } else {
    view.eventRegistrations_ = [];
  }
  return cancelEvents;
};
var viewApplyOperation = function(view, operation, writesCache, completeServerCache) {
  if (operation.type === OperationType.MERGE && operation.source.queryId !== null) {
    assert(viewCacheGetCompleteServerSnap(view.viewCache_), "We should always have a full cache before handling merges");
    assert(viewCacheGetCompleteEventSnap(view.viewCache_), "Missing event cache, even though we have a server cache");
  }
  const oldViewCache = view.viewCache_;
  const result = viewProcessorApplyOperation(view.processor_, oldViewCache, operation, writesCache, completeServerCache);
  viewProcessorAssertIndexed(view.processor_, result.viewCache);
  assert(result.viewCache.serverCache.isFullyInitialized() || !oldViewCache.serverCache.isFullyInitialized(), "Once a server snap is complete, it should never go back");
  view.viewCache_ = result.viewCache;
  return viewGenerateEventsForChanges_(view, result.changes, result.viewCache.eventCache.getNode(), null);
};
var viewGetInitialEvents = function(view, registration) {
  const eventSnap = view.viewCache_.eventCache;
  const initialChanges = [];
  if (!eventSnap.getNode().isLeafNode()) {
    const eventNode = eventSnap.getNode();
    eventNode.forEachChild(PRIORITY_INDEX, (key, childNode) => {
      initialChanges.push(changeChildAdded(key, childNode));
    });
  }
  if (eventSnap.isFullyInitialized()) {
    initialChanges.push(changeValue(eventSnap.getNode()));
  }
  return viewGenerateEventsForChanges_(view, initialChanges, eventSnap.getNode(), registration);
};
var viewGenerateEventsForChanges_ = function(view, changes, eventCache, eventRegistration) {
  const registrations = eventRegistration ? [eventRegistration] : view.eventRegistrations_;
  return eventGeneratorGenerateEventsForChanges(view.eventGenerator_, changes, eventCache, registrations);
};
var syncPointSetReferenceConstructor = function(val) {
  assert(!referenceConstructor$1, "__referenceConstructor has already been defined");
  referenceConstructor$1 = val;
};
var syncPointGetReferenceConstructor = function() {
  assert(referenceConstructor$1, "Reference.ts has not been loaded");
  return referenceConstructor$1;
};
var syncPointIsEmpty = function(syncPoint) {
  return syncPoint.views.size === 0;
};
var syncPointApplyOperation = function(syncPoint, operation, writesCache, optCompleteServerCache) {
  const queryId = operation.source.queryId;
  if (queryId !== null) {
    const view = syncPoint.views.get(queryId);
    assert(view != null, "SyncTree gave us an op for an invalid query.");
    return viewApplyOperation(view, operation, writesCache, optCompleteServerCache);
  } else {
    let events = [];
    for (const view of syncPoint.views.values()) {
      events = events.concat(viewApplyOperation(view, operation, writesCache, optCompleteServerCache));
    }
    return events;
  }
};
var syncPointGetView = function(syncPoint, query, writesCache, serverCache, serverCacheComplete) {
  const queryId = query._queryIdentifier;
  const view = syncPoint.views.get(queryId);
  if (!view) {
    let eventCache = writeTreeRefCalcCompleteEventCache(writesCache, serverCacheComplete ? serverCache : null);
    let eventCacheComplete = false;
    if (eventCache) {
      eventCacheComplete = true;
    } else if (serverCache instanceof ChildrenNode) {
      eventCache = writeTreeRefCalcCompleteEventChildren(writesCache, serverCache);
      eventCacheComplete = false;
    } else {
      eventCache = ChildrenNode.EMPTY_NODE;
      eventCacheComplete = false;
    }
    const viewCache = newViewCache(new CacheNode(eventCache, eventCacheComplete, false), new CacheNode(serverCache, serverCacheComplete, false));
    return new View(query, viewCache);
  }
  return view;
};
var syncPointAddEventRegistration = function(syncPoint, query, eventRegistration, writesCache, serverCache, serverCacheComplete) {
  const view = syncPointGetView(syncPoint, query, writesCache, serverCache, serverCacheComplete);
  if (!syncPoint.views.has(query._queryIdentifier)) {
    syncPoint.views.set(query._queryIdentifier, view);
  }
  viewAddEventRegistration(view, eventRegistration);
  return viewGetInitialEvents(view, eventRegistration);
};
var syncPointRemoveEventRegistration = function(syncPoint, query, eventRegistration, cancelError) {
  const queryId = query._queryIdentifier;
  const removed = [];
  let cancelEvents = [];
  const hadCompleteView = syncPointHasCompleteView(syncPoint);
  if (queryId === "default") {
    for (const [viewQueryId, view] of syncPoint.views.entries()) {
      cancelEvents = cancelEvents.concat(viewRemoveEventRegistration(view, eventRegistration, cancelError));
      if (viewIsEmpty(view)) {
        syncPoint.views.delete(viewQueryId);
        if (!view.query._queryParams.loadsAllData()) {
          removed.push(view.query);
        }
      }
    }
  } else {
    const view = syncPoint.views.get(queryId);
    if (view) {
      cancelEvents = cancelEvents.concat(viewRemoveEventRegistration(view, eventRegistration, cancelError));
      if (viewIsEmpty(view)) {
        syncPoint.views.delete(queryId);
        if (!view.query._queryParams.loadsAllData()) {
          removed.push(view.query);
        }
      }
    }
  }
  if (hadCompleteView && !syncPointHasCompleteView(syncPoint)) {
    removed.push(new (syncPointGetReferenceConstructor())(query._repo, query._path));
  }
  return { removed, events: cancelEvents };
};
var syncPointGetQueryViews = function(syncPoint) {
  const result = [];
  for (const view of syncPoint.views.values()) {
    if (!view.query._queryParams.loadsAllData()) {
      result.push(view);
    }
  }
  return result;
};
var syncPointGetCompleteServerCache = function(syncPoint, path5) {
  let serverCache = null;
  for (const view of syncPoint.views.values()) {
    serverCache = serverCache || viewGetCompleteServerCache(view, path5);
  }
  return serverCache;
};
var syncPointViewForQuery = function(syncPoint, query) {
  const params = query._queryParams;
  if (params.loadsAllData()) {
    return syncPointGetCompleteView(syncPoint);
  } else {
    const queryId = query._queryIdentifier;
    return syncPoint.views.get(queryId);
  }
};
var syncPointViewExistsForQuery = function(syncPoint, query) {
  return syncPointViewForQuery(syncPoint, query) != null;
};
var syncPointHasCompleteView = function(syncPoint) {
  return syncPointGetCompleteView(syncPoint) != null;
};
var syncPointGetCompleteView = function(syncPoint) {
  for (const view of syncPoint.views.values()) {
    if (view.query._queryParams.loadsAllData()) {
      return view;
    }
  }
  return null;
};
var syncTreeSetReferenceConstructor = function(val) {
  assert(!referenceConstructor, "__referenceConstructor has already been defined");
  referenceConstructor = val;
};
var syncTreeGetReferenceConstructor = function() {
  assert(referenceConstructor, "Reference.ts has not been loaded");
  return referenceConstructor;
};
var syncTreeApplyUserOverwrite = function(syncTree, path5, newData, writeId, visible) {
  writeTreeAddOverwrite(syncTree.pendingWriteTree_, path5, newData, writeId, visible);
  if (!visible) {
    return [];
  } else {
    return syncTreeApplyOperationToSyncPoints_(syncTree, new Overwrite(newOperationSourceUser(), path5, newData));
  }
};
var syncTreeAckUserWrite = function(syncTree, writeId, revert = false) {
  const write = writeTreeGetWrite(syncTree.pendingWriteTree_, writeId);
  const needToReevaluate = writeTreeRemoveWrite(syncTree.pendingWriteTree_, writeId);
  if (!needToReevaluate) {
    return [];
  } else {
    let affectedTree = new ImmutableTree(null);
    if (write.snap != null) {
      affectedTree = affectedTree.set(newEmptyPath(), true);
    } else {
      each(write.children, (pathString) => {
        affectedTree = affectedTree.set(new Path3(pathString), true);
      });
    }
    return syncTreeApplyOperationToSyncPoints_(syncTree, new AckUserWrite(write.path, affectedTree, revert));
  }
};
var syncTreeApplyServerOverwrite = function(syncTree, path5, newData) {
  return syncTreeApplyOperationToSyncPoints_(syncTree, new Overwrite(newOperationSourceServer(), path5, newData));
};
var syncTreeApplyServerMerge = function(syncTree, path5, changedChildren) {
  const changeTree = ImmutableTree.fromObject(changedChildren);
  return syncTreeApplyOperationToSyncPoints_(syncTree, new Merge(newOperationSourceServer(), path5, changeTree));
};
var syncTreeApplyListenComplete = function(syncTree, path5) {
  return syncTreeApplyOperationToSyncPoints_(syncTree, new ListenComplete(newOperationSourceServer(), path5));
};
var syncTreeApplyTaggedListenComplete = function(syncTree, path5, tag) {
  const queryKey = syncTreeQueryKeyForTag_(syncTree, tag);
  if (queryKey) {
    const r = syncTreeParseQueryKey_(queryKey);
    const { path: queryPath, queryId } = r;
    const relativePath = newRelativePath(queryPath, path5);
    const op = new ListenComplete(newOperationSourceServerTaggedQuery(queryId), relativePath);
    return syncTreeApplyTaggedOperation_(syncTree, queryPath, op);
  } else {
    return [];
  }
};
var syncTreeRemoveEventRegistration = function(syncTree, query, eventRegistration, cancelError, skipListenerDedup = false) {
  const path5 = query._path;
  const maybeSyncPoint = syncTree.syncPointTree_.get(path5);
  let cancelEvents = [];
  if (maybeSyncPoint && (query._queryIdentifier === "default" || syncPointViewExistsForQuery(maybeSyncPoint, query))) {
    const removedAndEvents = syncPointRemoveEventRegistration(maybeSyncPoint, query, eventRegistration, cancelError);
    if (syncPointIsEmpty(maybeSyncPoint)) {
      syncTree.syncPointTree_ = syncTree.syncPointTree_.remove(path5);
    }
    const removed = removedAndEvents.removed;
    cancelEvents = removedAndEvents.events;
    if (!skipListenerDedup) {
      const removingDefault = removed.findIndex((query2) => {
        return query2._queryParams.loadsAllData();
      }) !== -1;
      const covered = syncTree.syncPointTree_.findOnPath(path5, (relativePath, parentSyncPoint) => syncPointHasCompleteView(parentSyncPoint));
      if (removingDefault && !covered) {
        const subtree = syncTree.syncPointTree_.subtree(path5);
        if (!subtree.isEmpty()) {
          const newViews = syncTreeCollectDistinctViewsForSubTree_(subtree);
          for (let i = 0;i < newViews.length; ++i) {
            const view = newViews[i], newQuery = view.query;
            const listener = syncTreeCreateListenerForView_(syncTree, view);
            syncTree.listenProvider_.startListening(syncTreeQueryForListening_(newQuery), syncTreeTagForQuery(syncTree, newQuery), listener.hashFn, listener.onComplete);
          }
        }
      }
      if (!covered && removed.length > 0 && !cancelError) {
        if (removingDefault) {
          const defaultTag = null;
          syncTree.listenProvider_.stopListening(syncTreeQueryForListening_(query), defaultTag);
        } else {
          removed.forEach((queryToRemove) => {
            const tagToRemove = syncTree.queryToTagMap.get(syncTreeMakeQueryKey_(queryToRemove));
            syncTree.listenProvider_.stopListening(syncTreeQueryForListening_(queryToRemove), tagToRemove);
          });
        }
      }
    }
    syncTreeRemoveTags_(syncTree, removed);
  }
  return cancelEvents;
};
var syncTreeApplyTaggedQueryOverwrite = function(syncTree, path5, snap, tag) {
  const queryKey = syncTreeQueryKeyForTag_(syncTree, tag);
  if (queryKey != null) {
    const r = syncTreeParseQueryKey_(queryKey);
    const { path: queryPath, queryId } = r;
    const relativePath = newRelativePath(queryPath, path5);
    const op = new Overwrite(newOperationSourceServerTaggedQuery(queryId), relativePath, snap);
    return syncTreeApplyTaggedOperation_(syncTree, queryPath, op);
  } else {
    return [];
  }
};
var syncTreeApplyTaggedQueryMerge = function(syncTree, path5, changedChildren, tag) {
  const queryKey = syncTreeQueryKeyForTag_(syncTree, tag);
  if (queryKey) {
    const r = syncTreeParseQueryKey_(queryKey);
    const { path: queryPath, queryId } = r;
    const relativePath = newRelativePath(queryPath, path5);
    const changeTree = ImmutableTree.fromObject(changedChildren);
    const op = new Merge(newOperationSourceServerTaggedQuery(queryId), relativePath, changeTree);
    return syncTreeApplyTaggedOperation_(syncTree, queryPath, op);
  } else {
    return [];
  }
};
var syncTreeAddEventRegistration = function(syncTree, query, eventRegistration, skipSetupListener = false) {
  const path5 = query._path;
  let serverCache = null;
  let foundAncestorDefaultView = false;
  syncTree.syncPointTree_.foreachOnPath(path5, (pathToSyncPoint, sp) => {
    const relativePath = newRelativePath(pathToSyncPoint, path5);
    serverCache = serverCache || syncPointGetCompleteServerCache(sp, relativePath);
    foundAncestorDefaultView = foundAncestorDefaultView || syncPointHasCompleteView(sp);
  });
  let syncPoint = syncTree.syncPointTree_.get(path5);
  if (!syncPoint) {
    syncPoint = new SyncPoint;
    syncTree.syncPointTree_ = syncTree.syncPointTree_.set(path5, syncPoint);
  } else {
    foundAncestorDefaultView = foundAncestorDefaultView || syncPointHasCompleteView(syncPoint);
    serverCache = serverCache || syncPointGetCompleteServerCache(syncPoint, newEmptyPath());
  }
  let serverCacheComplete;
  if (serverCache != null) {
    serverCacheComplete = true;
  } else {
    serverCacheComplete = false;
    serverCache = ChildrenNode.EMPTY_NODE;
    const subtree = syncTree.syncPointTree_.subtree(path5);
    subtree.foreachChild((childName, childSyncPoint) => {
      const completeCache = syncPointGetCompleteServerCache(childSyncPoint, newEmptyPath());
      if (completeCache) {
        serverCache = serverCache.updateImmediateChild(childName, completeCache);
      }
    });
  }
  const viewAlreadyExists = syncPointViewExistsForQuery(syncPoint, query);
  if (!viewAlreadyExists && !query._queryParams.loadsAllData()) {
    const queryKey = syncTreeMakeQueryKey_(query);
    assert(!syncTree.queryToTagMap.has(queryKey), "View does not exist, but we have a tag");
    const tag = syncTreeGetNextQueryTag_();
    syncTree.queryToTagMap.set(queryKey, tag);
    syncTree.tagToQueryMap.set(tag, queryKey);
  }
  const writesCache = writeTreeChildWrites(syncTree.pendingWriteTree_, path5);
  let events = syncPointAddEventRegistration(syncPoint, query, eventRegistration, writesCache, serverCache, serverCacheComplete);
  if (!viewAlreadyExists && !foundAncestorDefaultView && !skipSetupListener) {
    const view = syncPointViewForQuery(syncPoint, query);
    events = events.concat(syncTreeSetupListener_(syncTree, query, view));
  }
  return events;
};
var syncTreeCalcCompleteEventCache = function(syncTree, path5, writeIdsToExclude) {
  const includeHiddenSets = true;
  const writeTree = syncTree.pendingWriteTree_;
  const serverCache = syncTree.syncPointTree_.findOnPath(path5, (pathSoFar, syncPoint) => {
    const relativePath = newRelativePath(pathSoFar, path5);
    const serverCache2 = syncPointGetCompleteServerCache(syncPoint, relativePath);
    if (serverCache2) {
      return serverCache2;
    }
  });
  return writeTreeCalcCompleteEventCache(writeTree, path5, serverCache, writeIdsToExclude, includeHiddenSets);
};
var syncTreeGetServerValue = function(syncTree, query) {
  const path5 = query._path;
  let serverCache = null;
  syncTree.syncPointTree_.foreachOnPath(path5, (pathToSyncPoint, sp) => {
    const relativePath = newRelativePath(pathToSyncPoint, path5);
    serverCache = serverCache || syncPointGetCompleteServerCache(sp, relativePath);
  });
  let syncPoint = syncTree.syncPointTree_.get(path5);
  if (!syncPoint) {
    syncPoint = new SyncPoint;
    syncTree.syncPointTree_ = syncTree.syncPointTree_.set(path5, syncPoint);
  } else {
    serverCache = serverCache || syncPointGetCompleteServerCache(syncPoint, newEmptyPath());
  }
  const serverCacheComplete = serverCache != null;
  const serverCacheNode = serverCacheComplete ? new CacheNode(serverCache, true, false) : null;
  const writesCache = writeTreeChildWrites(syncTree.pendingWriteTree_, query._path);
  const view = syncPointGetView(syncPoint, query, writesCache, serverCacheComplete ? serverCacheNode.getNode() : ChildrenNode.EMPTY_NODE, serverCacheComplete);
  return viewGetCompleteNode(view);
};
var syncTreeApplyOperationToSyncPoints_ = function(syncTree, operation) {
  return syncTreeApplyOperationHelper_(operation, syncTree.syncPointTree_, null, writeTreeChildWrites(syncTree.pendingWriteTree_, newEmptyPath()));
};
var syncTreeApplyOperationHelper_ = function(operation, syncPointTree, serverCache, writesCache) {
  if (pathIsEmpty(operation.path)) {
    return syncTreeApplyOperationDescendantsHelper_(operation, syncPointTree, serverCache, writesCache);
  } else {
    const syncPoint = syncPointTree.get(newEmptyPath());
    if (serverCache == null && syncPoint != null) {
      serverCache = syncPointGetCompleteServerCache(syncPoint, newEmptyPath());
    }
    let events = [];
    const childName = pathGetFront(operation.path);
    const childOperation = operation.operationForChild(childName);
    const childTree = syncPointTree.children.get(childName);
    if (childTree && childOperation) {
      const childServerCache = serverCache ? serverCache.getImmediateChild(childName) : null;
      const childWritesCache = writeTreeRefChild(writesCache, childName);
      events = events.concat(syncTreeApplyOperationHelper_(childOperation, childTree, childServerCache, childWritesCache));
    }
    if (syncPoint) {
      events = events.concat(syncPointApplyOperation(syncPoint, operation, writesCache, serverCache));
    }
    return events;
  }
};
var syncTreeApplyOperationDescendantsHelper_ = function(operation, syncPointTree, serverCache, writesCache) {
  const syncPoint = syncPointTree.get(newEmptyPath());
  if (serverCache == null && syncPoint != null) {
    serverCache = syncPointGetCompleteServerCache(syncPoint, newEmptyPath());
  }
  let events = [];
  syncPointTree.children.inorderTraversal((childName, childTree) => {
    const childServerCache = serverCache ? serverCache.getImmediateChild(childName) : null;
    const childWritesCache = writeTreeRefChild(writesCache, childName);
    const childOperation = operation.operationForChild(childName);
    if (childOperation) {
      events = events.concat(syncTreeApplyOperationDescendantsHelper_(childOperation, childTree, childServerCache, childWritesCache));
    }
  });
  if (syncPoint) {
    events = events.concat(syncPointApplyOperation(syncPoint, operation, writesCache, serverCache));
  }
  return events;
};
var syncTreeCreateListenerForView_ = function(syncTree, view) {
  const query = view.query;
  const tag = syncTreeTagForQuery(syncTree, query);
  return {
    hashFn: () => {
      const cache = viewGetServerCache(view) || ChildrenNode.EMPTY_NODE;
      return cache.hash();
    },
    onComplete: (status) => {
      if (status === "ok") {
        if (tag) {
          return syncTreeApplyTaggedListenComplete(syncTree, query._path, tag);
        } else {
          return syncTreeApplyListenComplete(syncTree, query._path);
        }
      } else {
        const error = errorForServerCode(status, query);
        return syncTreeRemoveEventRegistration(syncTree, query, null, error);
      }
    }
  };
};
var syncTreeTagForQuery = function(syncTree, query) {
  const queryKey = syncTreeMakeQueryKey_(query);
  return syncTree.queryToTagMap.get(queryKey);
};
var syncTreeMakeQueryKey_ = function(query) {
  return query._path.toString() + "$" + query._queryIdentifier;
};
var syncTreeQueryKeyForTag_ = function(syncTree, tag) {
  return syncTree.tagToQueryMap.get(tag);
};
var syncTreeParseQueryKey_ = function(queryKey) {
  const splitIndex = queryKey.indexOf("$");
  assert(splitIndex !== -1 && splitIndex < queryKey.length - 1, "Bad queryKey.");
  return {
    queryId: queryKey.substr(splitIndex + 1),
    path: new Path3(queryKey.substr(0, splitIndex))
  };
};
var syncTreeApplyTaggedOperation_ = function(syncTree, queryPath, operation) {
  const syncPoint = syncTree.syncPointTree_.get(queryPath);
  assert(syncPoint, "Missing sync point for query tag that we're tracking");
  const writesCache = writeTreeChildWrites(syncTree.pendingWriteTree_, queryPath);
  return syncPointApplyOperation(syncPoint, operation, writesCache, null);
};
var syncTreeCollectDistinctViewsForSubTree_ = function(subtree) {
  return subtree.fold((relativePath, maybeChildSyncPoint, childMap) => {
    if (maybeChildSyncPoint && syncPointHasCompleteView(maybeChildSyncPoint)) {
      const completeView = syncPointGetCompleteView(maybeChildSyncPoint);
      return [completeView];
    } else {
      let views = [];
      if (maybeChildSyncPoint) {
        views = syncPointGetQueryViews(maybeChildSyncPoint);
      }
      each(childMap, (_key, childViews) => {
        views = views.concat(childViews);
      });
      return views;
    }
  });
};
var syncTreeQueryForListening_ = function(query) {
  if (query._queryParams.loadsAllData() && !query._queryParams.isDefault()) {
    return new (syncTreeGetReferenceConstructor())(query._repo, query._path);
  } else {
    return query;
  }
};
var syncTreeRemoveTags_ = function(syncTree, queries) {
  for (let j = 0;j < queries.length; ++j) {
    const removedQuery = queries[j];
    if (!removedQuery._queryParams.loadsAllData()) {
      const removedQueryKey = syncTreeMakeQueryKey_(removedQuery);
      const removedQueryTag = syncTree.queryToTagMap.get(removedQueryKey);
      syncTree.queryToTagMap.delete(removedQueryKey);
      syncTree.tagToQueryMap.delete(removedQueryTag);
    }
  }
};
var syncTreeGetNextQueryTag_ = function() {
  return syncTreeNextQueryTag_++;
};
var syncTreeSetupListener_ = function(syncTree, query, view) {
  const path5 = query._path;
  const tag = syncTreeTagForQuery(syncTree, query);
  const listener = syncTreeCreateListenerForView_(syncTree, view);
  const events = syncTree.listenProvider_.startListening(syncTreeQueryForListening_(query), tag, listener.hashFn, listener.onComplete);
  const subtree = syncTree.syncPointTree_.subtree(path5);
  if (tag) {
    assert(!syncPointHasCompleteView(subtree.value), "If we're adding a query, it shouldn't be shadowed");
  } else {
    const queriesToStop = subtree.fold((relativePath, maybeChildSyncPoint, childMap) => {
      if (!pathIsEmpty(relativePath) && maybeChildSyncPoint && syncPointHasCompleteView(maybeChildSyncPoint)) {
        return [syncPointGetCompleteView(maybeChildSyncPoint).query];
      } else {
        let queries = [];
        if (maybeChildSyncPoint) {
          queries = queries.concat(syncPointGetQueryViews(maybeChildSyncPoint).map((view2) => view2.query));
        }
        each(childMap, (_key, childQueries) => {
          queries = queries.concat(childQueries);
        });
        return queries;
      }
    });
    for (let i = 0;i < queriesToStop.length; ++i) {
      const queryToStop = queriesToStop[i];
      syncTree.listenProvider_.stopListening(syncTreeQueryForListening_(queryToStop), syncTreeTagForQuery(syncTree, queryToStop));
    }
  }
  return events;
};
var resolveDeferredValue = function(node, existingVal, serverValues) {
  const rawPri = node.getPriority().val();
  const priority = resolveDeferredLeafValue(rawPri, existingVal.getImmediateChild(".priority"), serverValues);
  let newNode;
  if (node.isLeafNode()) {
    const leafNode = node;
    const value = resolveDeferredLeafValue(leafNode.getValue(), existingVal, serverValues);
    if (value !== leafNode.getValue() || priority !== leafNode.getPriority().val()) {
      return new LeafNode(value, nodeFromJSON(priority));
    } else {
      return node;
    }
  } else {
    const childrenNode = node;
    newNode = childrenNode;
    if (priority !== childrenNode.getPriority().val()) {
      newNode = newNode.updatePriority(new LeafNode(priority));
    }
    childrenNode.forEachChild(PRIORITY_INDEX, (childName, childNode) => {
      const newChildNode = resolveDeferredValue(childNode, existingVal.getImmediateChild(childName), serverValues);
      if (newChildNode !== childNode) {
        newNode = newNode.updateImmediateChild(childName, newChildNode);
      }
    });
    return newNode;
  }
};
var treeSubTree = function(tree, pathObj) {
  let path5 = pathObj instanceof Path3 ? pathObj : new Path3(pathObj);
  let child = tree, next = pathGetFront(path5);
  while (next !== null) {
    const childNode = safeGet(child.node.children, next) || {
      children: {},
      childCount: 0
    };
    child = new Tree(next, child, childNode);
    path5 = pathPopFront(path5);
    next = pathGetFront(path5);
  }
  return child;
};
var treeGetValue = function(tree) {
  return tree.node.value;
};
var treeSetValue = function(tree, value) {
  tree.node.value = value;
  treeUpdateParents(tree);
};
var treeHasChildren = function(tree) {
  return tree.node.childCount > 0;
};
var treeIsEmpty = function(tree) {
  return treeGetValue(tree) === undefined && !treeHasChildren(tree);
};
var treeForEachChild = function(tree, action) {
  each(tree.node.children, (child, childTree) => {
    action(new Tree(child, tree, childTree));
  });
};
var treeForEachDescendant = function(tree, action, includeSelf, childrenFirst) {
  if (includeSelf && !childrenFirst) {
    action(tree);
  }
  treeForEachChild(tree, (child) => {
    treeForEachDescendant(child, action, true, childrenFirst);
  });
  if (includeSelf && childrenFirst) {
    action(tree);
  }
};
var treeForEachAncestor = function(tree, action, includeSelf) {
  let node = includeSelf ? tree : tree.parent;
  while (node !== null) {
    if (action(node)) {
      return true;
    }
    node = node.parent;
  }
  return false;
};
var treeGetPath = function(tree) {
  return new Path3(tree.parent === null ? tree.name : treeGetPath(tree.parent) + "/" + tree.name);
};
var treeUpdateParents = function(tree) {
  if (tree.parent !== null) {
    treeUpdateChild(tree.parent, tree.name, tree);
  }
};
var treeUpdateChild = function(tree, childName, child) {
  const childEmpty = treeIsEmpty(child);
  const childExists = contains(tree.node.children, childName);
  if (childEmpty && childExists) {
    delete tree.node.children[childName];
    tree.node.childCount--;
    treeUpdateParents(tree);
  } else if (!childEmpty && !childExists) {
    tree.node.children[childName] = child.node;
    tree.node.childCount++;
    treeUpdateParents(tree);
  }
};
var eventQueueQueueEvents = function(eventQueue, eventDataList) {
  let currList = null;
  for (let i = 0;i < eventDataList.length; i++) {
    const data = eventDataList[i];
    const path5 = data.getPath();
    if (currList !== null && !pathEquals(path5, currList.path)) {
      eventQueue.eventLists_.push(currList);
      currList = null;
    }
    if (currList === null) {
      currList = { events: [], path: path5 };
    }
    currList.events.push(data);
  }
  if (currList) {
    eventQueue.eventLists_.push(currList);
  }
};
var eventQueueRaiseEventsForChangedPath = function(eventQueue, changedPath, eventDataList) {
  eventQueueQueueEvents(eventQueue, eventDataList);
  eventQueueRaiseQueuedEventsMatchingPredicate(eventQueue, (eventPath) => pathContains(eventPath, changedPath) || pathContains(changedPath, eventPath));
};
var eventQueueRaiseQueuedEventsMatchingPredicate = function(eventQueue, predicate) {
  eventQueue.recursionDepth_++;
  let sentAll = true;
  for (let i = 0;i < eventQueue.eventLists_.length; i++) {
    const eventList = eventQueue.eventLists_[i];
    if (eventList) {
      const eventPath = eventList.path;
      if (predicate(eventPath)) {
        eventListRaise(eventQueue.eventLists_[i]);
        eventQueue.eventLists_[i] = null;
      } else {
        sentAll = false;
      }
    }
  }
  if (sentAll) {
    eventQueue.eventLists_ = [];
  }
  eventQueue.recursionDepth_--;
};
var eventListRaise = function(eventList) {
  for (let i = 0;i < eventList.events.length; i++) {
    const eventData = eventList.events[i];
    if (eventData !== null) {
      eventList.events[i] = null;
      const eventFn = eventData.getEventRunner();
      if (logger4) {
        log2("event: " + eventData.toString());
      }
      exceptionGuard(eventFn);
    }
  }
};
var repoStart = function(repo, appId, authOverride) {
  repo.stats_ = statsManagerGetCollection(repo.repoInfo_);
  if (repo.forceRestClient_ || beingCrawled()) {
    repo.server_ = new ReadonlyRestClient(repo.repoInfo_, (pathString, data, isMerge, tag) => {
      repoOnDataUpdate(repo, pathString, data, isMerge, tag);
    }, repo.authTokenProvider_, repo.appCheckProvider_);
    setTimeout(() => repoOnConnectStatus(repo, true), 0);
  } else {
    if (typeof authOverride !== "undefined" && authOverride !== null) {
      if (typeof authOverride !== "object") {
        throw new Error("Only objects are supported for option databaseAuthVariableOverride");
      }
      try {
        stringify(authOverride);
      } catch (e) {
        throw new Error("Invalid authOverride provided: " + e);
      }
    }
    repo.persistentConnection_ = new PersistentConnection(repo.repoInfo_, appId, (pathString, data, isMerge, tag) => {
      repoOnDataUpdate(repo, pathString, data, isMerge, tag);
    }, (connectStatus) => {
      repoOnConnectStatus(repo, connectStatus);
    }, (updates) => {
      repoOnServerInfoUpdate(repo, updates);
    }, repo.authTokenProvider_, repo.appCheckProvider_, authOverride);
    repo.server_ = repo.persistentConnection_;
  }
  repo.authTokenProvider_.addTokenChangeListener((token) => {
    repo.server_.refreshAuthToken(token);
  });
  repo.appCheckProvider_.addTokenChangeListener((result) => {
    repo.server_.refreshAppCheckToken(result.token);
  });
  repo.statsReporter_ = statsManagerGetOrCreateReporter(repo.repoInfo_, () => new StatsReporter(repo.stats_, repo.server_));
  repo.infoData_ = new SnapshotHolder;
  repo.infoSyncTree_ = new SyncTree({
    startListening: (query, tag, currentHashFn, onComplete) => {
      let infoEvents = [];
      const node = repo.infoData_.getNode(query._path);
      if (!node.isEmpty()) {
        infoEvents = syncTreeApplyServerOverwrite(repo.infoSyncTree_, query._path, node);
        setTimeout(() => {
          onComplete("ok");
        }, 0);
      }
      return infoEvents;
    },
    stopListening: () => {
    }
  });
  repoUpdateInfo(repo, "connected", false);
  repo.serverSyncTree_ = new SyncTree({
    startListening: (query, tag, currentHashFn, onComplete) => {
      repo.server_.listen(query, currentHashFn, tag, (status, data) => {
        const events = onComplete(status, data);
        eventQueueRaiseEventsForChangedPath(repo.eventQueue_, query._path, events);
      });
      return [];
    },
    stopListening: (query, tag) => {
      repo.server_.unlisten(query, tag);
    }
  });
};
var repoServerTime = function(repo) {
  const offsetNode = repo.infoData_.getNode(new Path3(".info/serverTimeOffset"));
  const offset = offsetNode.val() || 0;
  return new Date().getTime() + offset;
};
var repoGenerateServerValues = function(repo) {
  return generateWithValues({
    timestamp: repoServerTime(repo)
  });
};
var repoOnDataUpdate = function(repo, pathString, data, isMerge, tag) {
  repo.dataUpdateCount++;
  const path5 = new Path3(pathString);
  data = repo.interceptServerDataCallback_ ? repo.interceptServerDataCallback_(pathString, data) : data;
  let events = [];
  if (tag) {
    if (isMerge) {
      const taggedChildren = map(data, (raw) => nodeFromJSON(raw));
      events = syncTreeApplyTaggedQueryMerge(repo.serverSyncTree_, path5, taggedChildren, tag);
    } else {
      const taggedSnap = nodeFromJSON(data);
      events = syncTreeApplyTaggedQueryOverwrite(repo.serverSyncTree_, path5, taggedSnap, tag);
    }
  } else if (isMerge) {
    const changedChildren = map(data, (raw) => nodeFromJSON(raw));
    events = syncTreeApplyServerMerge(repo.serverSyncTree_, path5, changedChildren);
  } else {
    const snap = nodeFromJSON(data);
    events = syncTreeApplyServerOverwrite(repo.serverSyncTree_, path5, snap);
  }
  let affectedPath = path5;
  if (events.length > 0) {
    affectedPath = repoRerunTransactions(repo, path5);
  }
  eventQueueRaiseEventsForChangedPath(repo.eventQueue_, affectedPath, events);
};
var repoOnConnectStatus = function(repo, connectStatus) {
  repoUpdateInfo(repo, "connected", connectStatus);
  if (connectStatus === false) {
    repoRunOnDisconnectEvents(repo);
  }
};
var repoOnServerInfoUpdate = function(repo, updates) {
  each(updates, (key, value) => {
    repoUpdateInfo(repo, key, value);
  });
};
var repoUpdateInfo = function(repo, pathString, value) {
  const path5 = new Path3("/.info/" + pathString);
  const newNode = nodeFromJSON(value);
  repo.infoData_.updateSnapshot(path5, newNode);
  const events = syncTreeApplyServerOverwrite(repo.infoSyncTree_, path5, newNode);
  eventQueueRaiseEventsForChangedPath(repo.eventQueue_, path5, events);
};
var repoGetNextWriteId = function(repo) {
  return repo.nextWriteId_++;
};
var repoGetValue = function(repo, query, eventRegistration) {
  const cached = syncTreeGetServerValue(repo.serverSyncTree_, query);
  if (cached != null) {
    return Promise.resolve(cached);
  }
  return repo.server_.get(query).then((payload) => {
    const node = nodeFromJSON(payload).withIndex(query._queryParams.getIndex());
    syncTreeAddEventRegistration(repo.serverSyncTree_, query, eventRegistration, true);
    let events;
    if (query._queryParams.loadsAllData()) {
      events = syncTreeApplyServerOverwrite(repo.serverSyncTree_, query._path, node);
    } else {
      const tag = syncTreeTagForQuery(repo.serverSyncTree_, query);
      events = syncTreeApplyTaggedQueryOverwrite(repo.serverSyncTree_, query._path, node, tag);
    }
    eventQueueRaiseEventsForChangedPath(repo.eventQueue_, query._path, events);
    syncTreeRemoveEventRegistration(repo.serverSyncTree_, query, eventRegistration, null, true);
    return node;
  }, (err) => {
    repoLog(repo, "get for query " + stringify(query) + " failed: " + err);
    return Promise.reject(new Error(err));
  });
};
var repoRunOnDisconnectEvents = function(repo) {
  repoLog(repo, "onDisconnectEvents");
  const serverValues = repoGenerateServerValues(repo);
  const resolvedOnDisconnectTree = newSparseSnapshotTree();
  sparseSnapshotTreeForEachTree(repo.onDisconnect_, newEmptyPath(), (path5, node) => {
    const resolved = resolveDeferredValueTree(path5, node, repo.serverSyncTree_, serverValues);
    sparseSnapshotTreeRemember(resolvedOnDisconnectTree, path5, resolved);
  });
  let events = [];
  sparseSnapshotTreeForEachTree(resolvedOnDisconnectTree, newEmptyPath(), (path5, snap) => {
    events = events.concat(syncTreeApplyServerOverwrite(repo.serverSyncTree_, path5, snap));
    const affectedPath = repoAbortTransactions(repo, path5);
    repoRerunTransactions(repo, affectedPath);
  });
  repo.onDisconnect_ = newSparseSnapshotTree();
  eventQueueRaiseEventsForChangedPath(repo.eventQueue_, newEmptyPath(), events);
};
var repoInterrupt = function(repo) {
  if (repo.persistentConnection_) {
    repo.persistentConnection_.interrupt(INTERRUPT_REASON);
  }
};
var repoLog = function(repo, ...varArgs) {
  let prefix = "";
  if (repo.persistentConnection_) {
    prefix = repo.persistentConnection_.id + ":";
  }
  log2(prefix, ...varArgs);
};
var repoGetLatestState = function(repo, path5, excludeSets) {
  return syncTreeCalcCompleteEventCache(repo.serverSyncTree_, path5, excludeSets) || ChildrenNode.EMPTY_NODE;
};
var repoSendReadyTransactions = function(repo, node = repo.transactionQueueTree_) {
  if (!node) {
    repoPruneCompletedTransactionsBelowNode(repo, node);
  }
  if (treeGetValue(node)) {
    const queue = repoBuildTransactionQueue(repo, node);
    assert(queue.length > 0, "Sending zero length transaction queue");
    const allRun = queue.every((transaction) => transaction.status === 0);
    if (allRun) {
      repoSendTransactionQueue(repo, treeGetPath(node), queue);
    }
  } else if (treeHasChildren(node)) {
    treeForEachChild(node, (childNode) => {
      repoSendReadyTransactions(repo, childNode);
    });
  }
};
var repoSendTransactionQueue = function(repo, path5, queue) {
  const setsToIgnore = queue.map((txn) => {
    return txn.currentWriteId;
  });
  const latestState = repoGetLatestState(repo, path5, setsToIgnore);
  let snapToSend = latestState;
  const latestHash = latestState.hash();
  for (let i = 0;i < queue.length; i++) {
    const txn = queue[i];
    assert(txn.status === 0, "tryToSendTransactionQueue_: items in queue should all be run.");
    txn.status = 1;
    txn.retryCount++;
    const relativePath = newRelativePath(path5, txn.path);
    snapToSend = snapToSend.updateChild(relativePath, txn.currentOutputSnapshotRaw);
  }
  const dataToSend = snapToSend.val(true);
  const pathToSend = path5;
  repo.server_.put(pathToSend.toString(), dataToSend, (status) => {
    repoLog(repo, "transaction put response", {
      path: pathToSend.toString(),
      status
    });
    let events = [];
    if (status === "ok") {
      const callbacks = [];
      for (let i = 0;i < queue.length; i++) {
        queue[i].status = 2;
        events = events.concat(syncTreeAckUserWrite(repo.serverSyncTree_, queue[i].currentWriteId));
        if (queue[i].onComplete) {
          callbacks.push(() => queue[i].onComplete(null, true, queue[i].currentOutputSnapshotResolved));
        }
        queue[i].unwatcher();
      }
      repoPruneCompletedTransactionsBelowNode(repo, treeSubTree(repo.transactionQueueTree_, path5));
      repoSendReadyTransactions(repo, repo.transactionQueueTree_);
      eventQueueRaiseEventsForChangedPath(repo.eventQueue_, path5, events);
      for (let i = 0;i < callbacks.length; i++) {
        exceptionGuard(callbacks[i]);
      }
    } else {
      if (status === "datastale") {
        for (let i = 0;i < queue.length; i++) {
          if (queue[i].status === 3) {
            queue[i].status = 4;
          } else {
            queue[i].status = 0;
          }
        }
      } else {
        warn("transaction at " + pathToSend.toString() + " failed: " + status);
        for (let i = 0;i < queue.length; i++) {
          queue[i].status = 4;
          queue[i].abortReason = status;
        }
      }
      repoRerunTransactions(repo, path5);
    }
  }, latestHash);
};
var repoRerunTransactions = function(repo, changedPath) {
  const rootMostTransactionNode = repoGetAncestorTransactionNode(repo, changedPath);
  const path5 = treeGetPath(rootMostTransactionNode);
  const queue = repoBuildTransactionQueue(repo, rootMostTransactionNode);
  repoRerunTransactionQueue(repo, queue, path5);
  return path5;
};
var repoRerunTransactionQueue = function(repo, queue, path5) {
  if (queue.length === 0) {
    return;
  }
  const callbacks = [];
  let events = [];
  const txnsToRerun = queue.filter((q) => {
    return q.status === 0;
  });
  const setsToIgnore = txnsToRerun.map((q) => {
    return q.currentWriteId;
  });
  for (let i = 0;i < queue.length; i++) {
    const transaction = queue[i];
    const relativePath = newRelativePath(path5, transaction.path);
    let abortTransaction = false, abortReason;
    assert(relativePath !== null, "rerunTransactionsUnderNode_: relativePath should not be null.");
    if (transaction.status === 4) {
      abortTransaction = true;
      abortReason = transaction.abortReason;
      events = events.concat(syncTreeAckUserWrite(repo.serverSyncTree_, transaction.currentWriteId, true));
    } else if (transaction.status === 0) {
      if (transaction.retryCount >= MAX_TRANSACTION_RETRIES) {
        abortTransaction = true;
        abortReason = "maxretry";
        events = events.concat(syncTreeAckUserWrite(repo.serverSyncTree_, transaction.currentWriteId, true));
      } else {
        const currentNode = repoGetLatestState(repo, transaction.path, setsToIgnore);
        transaction.currentInputSnapshot = currentNode;
        const newData = queue[i].update(currentNode.val());
        if (newData !== undefined) {
          validateFirebaseData("transaction failed: Data returned ", newData, transaction.path);
          let newDataNode = nodeFromJSON(newData);
          const hasExplicitPriority = typeof newData === "object" && newData != null && contains(newData, ".priority");
          if (!hasExplicitPriority) {
            newDataNode = newDataNode.updatePriority(currentNode.getPriority());
          }
          const oldWriteId = transaction.currentWriteId;
          const serverValues = repoGenerateServerValues(repo);
          const newNodeResolved = resolveDeferredValueSnapshot(newDataNode, currentNode, serverValues);
          transaction.currentOutputSnapshotRaw = newDataNode;
          transaction.currentOutputSnapshotResolved = newNodeResolved;
          transaction.currentWriteId = repoGetNextWriteId(repo);
          setsToIgnore.splice(setsToIgnore.indexOf(oldWriteId), 1);
          events = events.concat(syncTreeApplyUserOverwrite(repo.serverSyncTree_, transaction.path, newNodeResolved, transaction.currentWriteId, transaction.applyLocally));
          events = events.concat(syncTreeAckUserWrite(repo.serverSyncTree_, oldWriteId, true));
        } else {
          abortTransaction = true;
          abortReason = "nodata";
          events = events.concat(syncTreeAckUserWrite(repo.serverSyncTree_, transaction.currentWriteId, true));
        }
      }
    }
    eventQueueRaiseEventsForChangedPath(repo.eventQueue_, path5, events);
    events = [];
    if (abortTransaction) {
      queue[i].status = 2;
      (function(unwatcher) {
        setTimeout(unwatcher, Math.floor(0));
      })(queue[i].unwatcher);
      if (queue[i].onComplete) {
        if (abortReason === "nodata") {
          callbacks.push(() => queue[i].onComplete(null, false, queue[i].currentInputSnapshot));
        } else {
          callbacks.push(() => queue[i].onComplete(new Error(abortReason), false, null));
        }
      }
    }
  }
  repoPruneCompletedTransactionsBelowNode(repo, repo.transactionQueueTree_);
  for (let i = 0;i < callbacks.length; i++) {
    exceptionGuard(callbacks[i]);
  }
  repoSendReadyTransactions(repo, repo.transactionQueueTree_);
};
var repoGetAncestorTransactionNode = function(repo, path5) {
  let front;
  let transactionNode = repo.transactionQueueTree_;
  front = pathGetFront(path5);
  while (front !== null && treeGetValue(transactionNode) === undefined) {
    transactionNode = treeSubTree(transactionNode, front);
    path5 = pathPopFront(path5);
    front = pathGetFront(path5);
  }
  return transactionNode;
};
var repoBuildTransactionQueue = function(repo, transactionNode) {
  const transactionQueue = [];
  repoAggregateTransactionQueuesForNode(repo, transactionNode, transactionQueue);
  transactionQueue.sort((a, b) => a.order - b.order);
  return transactionQueue;
};
var repoAggregateTransactionQueuesForNode = function(repo, node, queue) {
  const nodeQueue = treeGetValue(node);
  if (nodeQueue) {
    for (let i = 0;i < nodeQueue.length; i++) {
      queue.push(nodeQueue[i]);
    }
  }
  treeForEachChild(node, (child) => {
    repoAggregateTransactionQueuesForNode(repo, child, queue);
  });
};
var repoPruneCompletedTransactionsBelowNode = function(repo, node) {
  const queue = treeGetValue(node);
  if (queue) {
    let to = 0;
    for (let from = 0;from < queue.length; from++) {
      if (queue[from].status !== 2) {
        queue[to] = queue[from];
        to++;
      }
    }
    queue.length = to;
    treeSetValue(node, queue.length > 0 ? queue : undefined);
  }
  treeForEachChild(node, (childNode) => {
    repoPruneCompletedTransactionsBelowNode(repo, childNode);
  });
};
var repoAbortTransactions = function(repo, path5) {
  const affectedPath = treeGetPath(repoGetAncestorTransactionNode(repo, path5));
  const transactionNode = treeSubTree(repo.transactionQueueTree_, path5);
  treeForEachAncestor(transactionNode, (node) => {
    repoAbortTransactionsOnNode(repo, node);
  });
  repoAbortTransactionsOnNode(repo, transactionNode);
  treeForEachDescendant(transactionNode, (node) => {
    repoAbortTransactionsOnNode(repo, node);
  });
  return affectedPath;
};
var repoAbortTransactionsOnNode = function(repo, node) {
  const queue = treeGetValue(node);
  if (queue) {
    const callbacks = [];
    let events = [];
    let lastSent = -1;
    for (let i = 0;i < queue.length; i++) {
      if (queue[i].status === 3)
        ;
      else if (queue[i].status === 1) {
        assert(lastSent === i - 1, "All SENT items should be at beginning of queue.");
        lastSent = i;
        queue[i].status = 3;
        queue[i].abortReason = "set";
      } else {
        assert(queue[i].status === 0, "Unexpected transaction status in abort");
        queue[i].unwatcher();
        events = events.concat(syncTreeAckUserWrite(repo.serverSyncTree_, queue[i].currentWriteId, true));
        if (queue[i].onComplete) {
          callbacks.push(queue[i].onComplete.bind(null, new Error("set"), false, null));
        }
      }
    }
    if (lastSent === -1) {
      treeSetValue(node, undefined);
    } else {
      queue.length = lastSent + 1;
    }
    eventQueueRaiseEventsForChangedPath(repo.eventQueue_, treeGetPath(node), events);
    for (let i = 0;i < callbacks.length; i++) {
      exceptionGuard(callbacks[i]);
    }
  }
};
var decodePath = function(pathString) {
  let pathStringDecoded = "";
  const pieces = pathString.split("/");
  for (let i = 0;i < pieces.length; i++) {
    if (pieces[i].length > 0) {
      let piece = pieces[i];
      try {
        piece = decodeURIComponent(piece.replace(/\+/g, " "));
      } catch (e) {
      }
      pathStringDecoded += "/" + piece;
    }
  }
  return pathStringDecoded;
};
var decodeQuery = function(queryString) {
  const results = {};
  if (queryString.charAt(0) === "?") {
    queryString = queryString.substring(1);
  }
  for (const segment of queryString.split("&")) {
    if (segment.length === 0) {
      continue;
    }
    const kv = segment.split("=");
    if (kv.length === 2) {
      results[decodeURIComponent(kv[0])] = decodeURIComponent(kv[1]);
    } else {
      warn(`Invalid query segment '${segment}' in query '${queryString}'`);
    }
  }
  return results;
};
var ref = function(db, path5) {
  db = getModularInstance(db);
  db._checkNotDeleted("ref");
  return path5 !== undefined ? child(db._root, path5) : db._root;
};
var child = function(parent, path5) {
  parent = getModularInstance(parent);
  if (pathGetFront(parent._path) === null) {
    validateRootPathString("child", "path", path5, false);
  } else {
    validatePathString("child", "path", path5, false);
  }
  return new ReferenceImpl(parent._repo, pathChild(parent._path, path5));
};
var get = function(query) {
  query = getModularInstance(query);
  const callbackContext = new CallbackContext(() => {
  });
  const container = new ValueEventRegistration(callbackContext);
  return repoGetValue(query._repo, query, container).then((node) => {
    return new DataSnapshot(node, new ReferenceImpl(query._repo, query._path), query._queryParams.getIndex());
  });
};
var repoManagerApplyEmulatorSettings = function(repo, host, port, tokenProvider) {
  repo.repoInfo_ = new RepoInfo(`${host}:${port}`, false, repo.repoInfo_.namespace, repo.repoInfo_.webSocketOnly, repo.repoInfo_.nodeAdmin, repo.repoInfo_.persistenceKey, repo.repoInfo_.includeNamespaceInQueryParams, true);
  if (tokenProvider) {
    repo.authTokenProvider_ = tokenProvider;
  }
};
var repoManagerDatabaseFromApp = function(app2, authProvider, appCheckProvider, url, nodeAdmin) {
  let dbUrl = url || app2.options.databaseURL;
  if (dbUrl === undefined) {
    if (!app2.options.projectId) {
      fatal("Can't determine Firebase Database URL. Be sure to include  a Project ID when calling firebase.initializeApp().");
    }
    log2("Using default host for project ", app2.options.projectId);
    dbUrl = `${app2.options.projectId}-default-rtdb.firebaseio.com`;
  }
  let parsedUrl = parseRepoInfo(dbUrl, nodeAdmin);
  let repoInfo = parsedUrl.repoInfo;
  let isEmulator;
  let dbEmulatorHost = undefined;
  if (typeof process !== "undefined" && process.env) {
    dbEmulatorHost = process.env[FIREBASE_DATABASE_EMULATOR_HOST_VAR];
  }
  if (dbEmulatorHost) {
    isEmulator = true;
    dbUrl = `http://${dbEmulatorHost}?ns=${repoInfo.namespace}`;
    parsedUrl = parseRepoInfo(dbUrl, nodeAdmin);
    repoInfo = parsedUrl.repoInfo;
  } else {
    isEmulator = !parsedUrl.repoInfo.secure;
  }
  const authTokenProvider = nodeAdmin && isEmulator ? new EmulatorTokenProvider(EmulatorTokenProvider.OWNER) : new FirebaseAuthTokenProvider(app2.name, app2.options, authProvider);
  validateUrl("Invalid Firebase Database URL", parsedUrl);
  if (!pathIsEmpty(parsedUrl.path)) {
    fatal("Database URL must point to the root of a Firebase Database (not including a child path).");
  }
  const repo = repoManagerCreateRepo(repoInfo, app2, authTokenProvider, new AppCheckTokenProvider(app2.name, appCheckProvider));
  return new Database(repo, app2);
};
var repoManagerDeleteRepo = function(repo, appName) {
  const appRepos = repos[appName];
  if (!appRepos || appRepos[repo.key] !== repo) {
    fatal(`Database ${appName}(${repo.repoInfo_}) has already been deleted.`);
  }
  repoInterrupt(repo);
  delete appRepos[repo.key];
};
var repoManagerCreateRepo = function(repoInfo, app2, authTokenProvider, appCheckProvider) {
  let appRepos = repos[app2.name];
  if (!appRepos) {
    appRepos = {};
    repos[app2.name] = appRepos;
  }
  let repo = appRepos[repoInfo.toURLString()];
  if (repo) {
    fatal("Database initialized multiple times. Please make sure the format of the database URL matches with each database() call.");
  }
  repo = new Repo(repoInfo, useRestClient, authTokenProvider, appCheckProvider);
  appRepos[repoInfo.toURLString()] = repo;
  return repo;
};
var getDatabase = function(app2 = getApp(), url) {
  const db = _getProvider(app2, "database").getImmediate({
    identifier: url
  });
  if (!db._instanceStarted) {
    const emulator = getDefaultEmulatorHostnameAndPort("database");
    if (emulator) {
      connectDatabaseEmulator(db, ...emulator);
    }
  }
  return db;
};
var connectDatabaseEmulator = function(db, host, port, options = {}) {
  db = getModularInstance(db);
  db._checkNotDeleted("useEmulator");
  if (db._instanceStarted) {
    fatal("Cannot call useEmulator() after instance has already been initialized.");
  }
  const repo = db._repoInternal;
  let tokenProvider = undefined;
  if (repo.repoInfo_.nodeAdmin) {
    if (options.mockUserToken) {
      fatal('mockUserToken is not supported by the Admin SDK. For client access with mock users, please use the "firebase" package instead of "firebase-admin".');
    }
    tokenProvider = new EmulatorTokenProvider(EmulatorTokenProvider.OWNER);
  } else if (options.mockUserToken) {
    const token = typeof options.mockUserToken === "string" ? options.mockUserToken : createMockUserToken(options.mockUserToken, db.app.options.projectId);
    tokenProvider = new EmulatorTokenProvider(token);
  }
  repoManagerApplyEmulatorSettings(repo, host, port, tokenProvider);
};
var registerDatabase = function(variant) {
  setSDKVersion(SDK_VERSION);
  _registerComponent(new Component("database", (container, { instanceIdentifier: url }) => {
    const app2 = container.getProvider("app").getImmediate();
    const authProvider = container.getProvider("auth-internal");
    const appCheckProvider = container.getProvider("app-check-internal");
    return repoManagerDatabaseFromApp(app2, authProvider, appCheckProvider, url);
  }, "PUBLIC").setMultipleInstances(true));
  registerVersion(name2, version3, variant);
  registerVersion(name2, version3, "esm2017");
};
var PROTOCOL_VERSION = "5";
var VERSION_PARAM = "v";
var TRANSPORT_SESSION_PARAM = "s";
var REFERER_PARAM = "r";
var FORGE_REF = "f";
var FORGE_DOMAIN_RE = /(console\.firebase|firebase-console-\w+\.corp|firebase\.corp)\.google\.com/;
var LAST_SESSION_PARAM = "ls";
var APPLICATION_ID_PARAM = "p";
var APP_CHECK_TOKEN_PARAM = "ac";
var WEBSOCKET = "websocket";
var LONG_POLLING = "long_polling";

class DOMStorageWrapper {
  constructor(domStorage_) {
    this.domStorage_ = domStorage_;
    this.prefix_ = "firebase:";
  }
  set(key, value) {
    if (value == null) {
      this.domStorage_.removeItem(this.prefixedName_(key));
    } else {
      this.domStorage_.setItem(this.prefixedName_(key), stringify(value));
    }
  }
  get(key) {
    const storedVal = this.domStorage_.getItem(this.prefixedName_(key));
    if (storedVal == null) {
      return null;
    } else {
      return jsonEval(storedVal);
    }
  }
  remove(key) {
    this.domStorage_.removeItem(this.prefixedName_(key));
  }
  prefixedName_(name2) {
    return this.prefix_ + name2;
  }
  toString() {
    return this.domStorage_.toString();
  }
}

class MemoryStorage {
  constructor() {
    this.cache_ = {};
    this.isInMemoryStorage = true;
  }
  set(key, value) {
    if (value == null) {
      delete this.cache_[key];
    } else {
      this.cache_[key] = value;
    }
  }
  get(key) {
    if (contains(this.cache_, key)) {
      return this.cache_[key];
    }
    return null;
  }
  remove(key) {
    delete this.cache_[key];
  }
}
var createStoragefor = function(domStorageName) {
  try {
    if (typeof window !== "undefined" && typeof window[domStorageName] !== "undefined") {
      const domStorage = window[domStorageName];
      domStorage.setItem("firebase:sentinel", "cache");
      domStorage.removeItem("firebase:sentinel");
      return new DOMStorageWrapper(domStorage);
    }
  } catch (e) {
  }
  return new MemoryStorage;
};
var PersistentStorage = createStoragefor("localStorage");
var SessionStorage = createStoragefor("sessionStorage");
var logClient = new Logger("@firebase/database");
var LUIDGenerator = function() {
  let id = 1;
  return function() {
    return id++;
  };
}();
var sha1 = function(str) {
  const utf8Bytes = stringToByteArray(str);
  const sha12 = new Sha1;
  sha12.update(utf8Bytes);
  const sha1Bytes = sha12.digest();
  return base64.encodeByteArray(sha1Bytes);
};
var buildLogMessage_ = function(...varArgs) {
  let message = "";
  for (let i = 0;i < varArgs.length; i++) {
    const arg2 = varArgs[i];
    if (Array.isArray(arg2) || arg2 && typeof arg2 === "object" && typeof arg2.length === "number") {
      message += buildLogMessage_.apply(null, arg2);
    } else if (typeof arg2 === "object") {
      message += stringify(arg2);
    } else {
      message += arg2;
    }
    message += " ";
  }
  return message;
};
var logger4 = null;
var firstLog_ = true;
var enableLogging$1 = function(logger_, persistent) {
  assert(!persistent || logger_ === true || logger_ === false, "Can't turn on custom loggers persistently.");
  if (logger_ === true) {
    logClient.logLevel = LogLevel.VERBOSE;
    logger4 = logClient.log.bind(logClient);
    if (persistent) {
      SessionStorage.set("logging_enabled", true);
    }
  } else if (typeof logger_ === "function") {
    logger4 = logger_;
  } else {
    logger4 = null;
    SessionStorage.remove("logging_enabled");
  }
};
var log2 = function(...varArgs) {
  if (firstLog_ === true) {
    firstLog_ = false;
    if (logger4 === null && SessionStorage.get("logging_enabled") === true) {
      enableLogging$1(true);
    }
  }
  if (logger4) {
    const message = buildLogMessage_.apply(null, varArgs);
    logger4(message);
  }
};
var logWrapper = function(prefix) {
  return function(...varArgs) {
    log2(prefix, ...varArgs);
  };
};
var error = function(...varArgs) {
  const message = "FIREBASE INTERNAL ERROR: " + buildLogMessage_(...varArgs);
  logClient.error(message);
};
var fatal = function(...varArgs) {
  const message = `FIREBASE FATAL ERROR: ${buildLogMessage_(...varArgs)}`;
  logClient.error(message);
  throw new Error(message);
};
var warn = function(...varArgs) {
  const message = "FIREBASE WARNING: " + buildLogMessage_(...varArgs);
  logClient.warn(message);
};
var warnIfPageIsSecure = function() {
  if (typeof window !== "undefined" && window.location && window.location.protocol && window.location.protocol.indexOf("https:") !== -1) {
    warn("Insecure Firebase access from a secure page. Please use https in calls to new Firebase().");
  }
};
var isInvalidJSONNumber = function(data) {
  return typeof data === "number" && (data !== data || data === Number.POSITIVE_INFINITY || data === Number.NEGATIVE_INFINITY);
};
var executeWhenDOMReady = function(fn) {
  if (isNodeSdk() || document.readyState === "complete") {
    fn();
  } else {
    let called = false;
    const wrappedFn = function() {
      if (!document.body) {
        setTimeout(wrappedFn, Math.floor(10));
        return;
      }
      if (!called) {
        called = true;
        fn();
      }
    };
    if (document.addEventListener) {
      document.addEventListener("DOMContentLoaded", wrappedFn, false);
      window.addEventListener("load", wrappedFn, false);
    } else if (document.attachEvent) {
      document.attachEvent("onreadystatechange", () => {
        if (document.readyState === "complete") {
          wrappedFn();
        }
      });
      window.attachEvent("onload", wrappedFn);
    }
  }
};
var MIN_NAME = "[MIN_NAME]";
var MAX_NAME = "[MAX_NAME]";
var nameCompare = function(a, b) {
  if (a === b) {
    return 0;
  } else if (a === MIN_NAME || b === MAX_NAME) {
    return -1;
  } else if (b === MIN_NAME || a === MAX_NAME) {
    return 1;
  } else {
    const aAsInt = tryParseInt(a), bAsInt = tryParseInt(b);
    if (aAsInt !== null) {
      if (bAsInt !== null) {
        return aAsInt - bAsInt === 0 ? a.length - b.length : aAsInt - bAsInt;
      } else {
        return -1;
      }
    } else if (bAsInt !== null) {
      return 1;
    } else {
      return a < b ? -1 : 1;
    }
  }
};
var stringCompare = function(a, b) {
  if (a === b) {
    return 0;
  } else if (a < b) {
    return -1;
  } else {
    return 1;
  }
};
var requireKey = function(key, obj) {
  if (obj && (key in obj)) {
    return obj[key];
  } else {
    throw new Error("Missing required key (" + key + ") in object: " + stringify(obj));
  }
};
var ObjectToUniqueKey = function(obj) {
  if (typeof obj !== "object" || obj === null) {
    return stringify(obj);
  }
  const keys = [];
  for (const k in obj) {
    keys.push(k);
  }
  keys.sort();
  let key = "{";
  for (let i = 0;i < keys.length; i++) {
    if (i !== 0) {
      key += ",";
    }
    key += stringify(keys[i]);
    key += ":";
    key += ObjectToUniqueKey(obj[keys[i]]);
  }
  key += "}";
  return key;
};
var splitStringBySize = function(str, segsize) {
  const len = str.length;
  if (len <= segsize) {
    return [str];
  }
  const dataSegs = [];
  for (let c = 0;c < len; c += segsize) {
    if (c + segsize > len) {
      dataSegs.push(str.substring(c, len));
    } else {
      dataSegs.push(str.substring(c, c + segsize));
    }
  }
  return dataSegs;
};
var doubleToIEEE754String = function(v) {
  assert(!isInvalidJSONNumber(v), "Invalid JSON number");
  const ebits = 11, fbits = 52;
  const bias = (1 << ebits - 1) - 1;
  let s, e, f, ln, i;
  if (v === 0) {
    e = 0;
    f = 0;
    s = 1 / v === (-Infinity) ? 1 : 0;
  } else {
    s = v < 0;
    v = Math.abs(v);
    if (v >= Math.pow(2, 1 - bias)) {
      ln = Math.min(Math.floor(Math.log(v) / Math.LN2), bias);
      e = ln + bias;
      f = Math.round(v * Math.pow(2, fbits - ln) - Math.pow(2, fbits));
    } else {
      e = 0;
      f = Math.round(v / Math.pow(2, 1 - bias - fbits));
    }
  }
  const bits = [];
  for (i = fbits;i; i -= 1) {
    bits.push(f % 2 ? 1 : 0);
    f = Math.floor(f / 2);
  }
  for (i = ebits;i; i -= 1) {
    bits.push(e % 2 ? 1 : 0);
    e = Math.floor(e / 2);
  }
  bits.push(s ? 1 : 0);
  bits.reverse();
  const str = bits.join("");
  let hexByteString = "";
  for (i = 0;i < 64; i += 8) {
    let hexByte = parseInt(str.substr(i, 8), 2).toString(16);
    if (hexByte.length === 1) {
      hexByte = "0" + hexByte;
    }
    hexByteString = hexByteString + hexByte;
  }
  return hexByteString.toLowerCase();
};
var isChromeExtensionContentScript = function() {
  return !!(typeof window === "object" && window["chrome"] && window["chrome"]["extension"] && !/^chrome/.test(window.location.href));
};
var isWindowsStoreApp = function() {
  return typeof Windows === "object" && typeof Windows.UI === "object";
};
var INTEGER_REGEXP_ = new RegExp("^-?(0*)\\d{1,10}$");
var INTEGER_32_MIN = -2147483648;
var INTEGER_32_MAX = 2147483647;
var tryParseInt = function(str) {
  if (INTEGER_REGEXP_.test(str)) {
    const intVal = Number(str);
    if (intVal >= INTEGER_32_MIN && intVal <= INTEGER_32_MAX) {
      return intVal;
    }
  }
  return null;
};
var exceptionGuard = function(fn) {
  try {
    fn();
  } catch (e) {
    setTimeout(() => {
      const stack = e.stack || "";
      warn("Exception was thrown by user callback.", stack);
      throw e;
    }, Math.floor(0));
  }
};
var beingCrawled = function() {
  const userAgent = typeof window === "object" && window["navigator"] && window["navigator"]["userAgent"] || "";
  return userAgent.search(/googlebot|google webmaster tools|bingbot|yahoo! slurp|baiduspider|yandexbot|duckduckbot/i) >= 0;
};
var setTimeoutNonBlocking = function(fn, time) {
  const timeout = setTimeout(fn, time);
  if (typeof timeout === "number" && typeof Deno !== "undefined" && Deno["unrefTimer"]) {
    Deno.unrefTimer(timeout);
  } else if (typeof timeout === "object" && timeout["unref"]) {
    timeout["unref"]();
  }
  return timeout;
};

class RepoInfo {
  constructor(host, secure, namespace, webSocketOnly, nodeAdmin = false, persistenceKey = "", includeNamespaceInQueryParams = false, isUsingEmulator = false) {
    this.secure = secure;
    this.namespace = namespace;
    this.webSocketOnly = webSocketOnly;
    this.nodeAdmin = nodeAdmin;
    this.persistenceKey = persistenceKey;
    this.includeNamespaceInQueryParams = includeNamespaceInQueryParams;
    this.isUsingEmulator = isUsingEmulator;
    this._host = host.toLowerCase();
    this._domain = this._host.substr(this._host.indexOf(".") + 1);
    this.internalHost = PersistentStorage.get("host:" + host) || this._host;
  }
  isCacheableHost() {
    return this.internalHost.substr(0, 2) === "s-";
  }
  isCustomHost() {
    return this._domain !== "firebaseio.com" && this._domain !== "firebaseio-demo.com";
  }
  get host() {
    return this._host;
  }
  set host(newHost) {
    if (newHost !== this.internalHost) {
      this.internalHost = newHost;
      if (this.isCacheableHost()) {
        PersistentStorage.set("host:" + this._host, this.internalHost);
      }
    }
  }
  toString() {
    let str = this.toURLString();
    if (this.persistenceKey) {
      str += "<" + this.persistenceKey + ">";
    }
    return str;
  }
  toURLString() {
    const protocol = this.secure ? "https://" : "http://";
    const query = this.includeNamespaceInQueryParams ? `?ns=${this.namespace}` : "";
    return `${protocol}${this.host}/${query}`;
  }
}

class StatsCollection {
  constructor() {
    this.counters_ = {};
  }
  incrementCounter(name2, amount = 1) {
    if (!contains(this.counters_, name2)) {
      this.counters_[name2] = 0;
    }
    this.counters_[name2] += amount;
  }
  get() {
    return deepCopy(this.counters_);
  }
}
var collections = {};
var reporters = {};
var SDK_VERSION2 = "";
var WEBSOCKET_MAX_FRAME_SIZE = 16384;
var WEBSOCKET_KEEPALIVE_INTERVAL = 45000;
var WebSocketImpl = null;
if (typeof MozWebSocket !== "undefined") {
  WebSocketImpl = MozWebSocket;
} else if (typeof WebSocket !== "undefined") {
  WebSocketImpl = WebSocket;
}

class WebSocketConnection {
  constructor(connId, repoInfo, applicationId, appCheckToken, authToken, transportSessionId, lastSessionId) {
    this.connId = connId;
    this.applicationId = applicationId;
    this.appCheckToken = appCheckToken;
    this.authToken = authToken;
    this.keepaliveTimer = null;
    this.frames = null;
    this.totalFrames = 0;
    this.bytesSent = 0;
    this.bytesReceived = 0;
    this.log_ = logWrapper(this.connId);
    this.stats_ = statsManagerGetCollection(repoInfo);
    this.connURL = WebSocketConnection.connectionURL_(repoInfo, transportSessionId, lastSessionId, appCheckToken, applicationId);
    this.nodeAdmin = repoInfo.nodeAdmin;
  }
  static connectionURL_(repoInfo, transportSessionId, lastSessionId, appCheckToken, applicationId) {
    const urlParams = {};
    urlParams[VERSION_PARAM] = PROTOCOL_VERSION;
    if (!isNodeSdk() && typeof location !== "undefined" && location.hostname && FORGE_DOMAIN_RE.test(location.hostname)) {
      urlParams[REFERER_PARAM] = FORGE_REF;
    }
    if (transportSessionId) {
      urlParams[TRANSPORT_SESSION_PARAM] = transportSessionId;
    }
    if (lastSessionId) {
      urlParams[LAST_SESSION_PARAM] = lastSessionId;
    }
    if (appCheckToken) {
      urlParams[APP_CHECK_TOKEN_PARAM] = appCheckToken;
    }
    if (applicationId) {
      urlParams[APPLICATION_ID_PARAM] = applicationId;
    }
    return repoInfoConnectionURL(repoInfo, WEBSOCKET, urlParams);
  }
  open(onMessage, onDisconnect) {
    this.onDisconnect = onDisconnect;
    this.onMessage = onMessage;
    this.log_("Websocket connecting to " + this.connURL);
    this.everConnected_ = false;
    PersistentStorage.set("previous_websocket_failure", true);
    try {
      let options;
      if (isNodeSdk()) {
        const device = this.nodeAdmin ? "AdminNode" : "Node";
        options = {
          headers: {
            "User-Agent": `Firebase/${PROTOCOL_VERSION}/${SDK_VERSION2}/${process.platform}/${device}`,
            "X-Firebase-GMPID": this.applicationId || ""
          }
        };
        if (this.authToken) {
          options.headers["Authorization"] = `Bearer ${this.authToken}`;
        }
        if (this.appCheckToken) {
          options.headers["X-Firebase-AppCheck"] = this.appCheckToken;
        }
        const env = process["env"];
        const proxy = this.connURL.indexOf("wss://") === 0 ? env["HTTPS_PROXY"] || env["https_proxy"] : env["HTTP_PROXY"] || env["http_proxy"];
        if (proxy) {
          options["proxy"] = { origin: proxy };
        }
      }
      this.mySock = new WebSocketImpl(this.connURL, [], options);
    } catch (e) {
      this.log_("Error instantiating WebSocket.");
      const error2 = e.message || e.data;
      if (error2) {
        this.log_(error2);
      }
      this.onClosed_();
      return;
    }
    this.mySock.onopen = () => {
      this.log_("Websocket connected.");
      this.everConnected_ = true;
    };
    this.mySock.onclose = () => {
      this.log_("Websocket connection was disconnected.");
      this.mySock = null;
      this.onClosed_();
    };
    this.mySock.onmessage = (m) => {
      this.handleIncomingFrame(m);
    };
    this.mySock.onerror = (e) => {
      this.log_("WebSocket error.  Closing connection.");
      const error2 = e.message || e.data;
      if (error2) {
        this.log_(error2);
      }
      this.onClosed_();
    };
  }
  start() {
  }
  static forceDisallow() {
    WebSocketConnection.forceDisallow_ = true;
  }
  static isAvailable() {
    let isOldAndroid = false;
    if (typeof navigator !== "undefined" && navigator.userAgent) {
      const oldAndroidRegex = /Android ([0-9]{0,}\.[0-9]{0,})/;
      const oldAndroidMatch = navigator.userAgent.match(oldAndroidRegex);
      if (oldAndroidMatch && oldAndroidMatch.length > 1) {
        if (parseFloat(oldAndroidMatch[1]) < 4.4) {
          isOldAndroid = true;
        }
      }
    }
    return !isOldAndroid && WebSocketImpl !== null && !WebSocketConnection.forceDisallow_;
  }
  static previouslyFailed() {
    return PersistentStorage.isInMemoryStorage || PersistentStorage.get("previous_websocket_failure") === true;
  }
  markConnectionHealthy() {
    PersistentStorage.remove("previous_websocket_failure");
  }
  appendFrame_(data) {
    this.frames.push(data);
    if (this.frames.length === this.totalFrames) {
      const fullMess = this.frames.join("");
      this.frames = null;
      const jsonMess = jsonEval(fullMess);
      this.onMessage(jsonMess);
    }
  }
  handleNewFrameCount_(frameCount) {
    this.totalFrames = frameCount;
    this.frames = [];
  }
  extractFrameCount_(data) {
    assert(this.frames === null, "We already have a frame buffer");
    if (data.length <= 6) {
      const frameCount = Number(data);
      if (!isNaN(frameCount)) {
        this.handleNewFrameCount_(frameCount);
        return null;
      }
    }
    this.handleNewFrameCount_(1);
    return data;
  }
  handleIncomingFrame(mess) {
    if (this.mySock === null) {
      return;
    }
    const data = mess["data"];
    this.bytesReceived += data.length;
    this.stats_.incrementCounter("bytes_received", data.length);
    this.resetKeepAlive();
    if (this.frames !== null) {
      this.appendFrame_(data);
    } else {
      const remainingData = this.extractFrameCount_(data);
      if (remainingData !== null) {
        this.appendFrame_(remainingData);
      }
    }
  }
  send(data) {
    this.resetKeepAlive();
    const dataStr = stringify(data);
    this.bytesSent += dataStr.length;
    this.stats_.incrementCounter("bytes_sent", dataStr.length);
    const dataSegs = splitStringBySize(dataStr, WEBSOCKET_MAX_FRAME_SIZE);
    if (dataSegs.length > 1) {
      this.sendString_(String(dataSegs.length));
    }
    for (let i = 0;i < dataSegs.length; i++) {
      this.sendString_(dataSegs[i]);
    }
  }
  shutdown_() {
    this.isClosed_ = true;
    if (this.keepaliveTimer) {
      clearInterval(this.keepaliveTimer);
      this.keepaliveTimer = null;
    }
    if (this.mySock) {
      this.mySock.close();
      this.mySock = null;
    }
  }
  onClosed_() {
    if (!this.isClosed_) {
      this.log_("WebSocket is closing itself");
      this.shutdown_();
      if (this.onDisconnect) {
        this.onDisconnect(this.everConnected_);
        this.onDisconnect = null;
      }
    }
  }
  close() {
    if (!this.isClosed_) {
      this.log_("WebSocket is being closed");
      this.shutdown_();
    }
  }
  resetKeepAlive() {
    clearInterval(this.keepaliveTimer);
    this.keepaliveTimer = setInterval(() => {
      if (this.mySock) {
        this.sendString_("0");
      }
      this.resetKeepAlive();
    }, Math.floor(WEBSOCKET_KEEPALIVE_INTERVAL));
  }
  sendString_(str) {
    try {
      this.mySock.send(str);
    } catch (e) {
      this.log_("Exception thrown from WebSocket.send():", e.message || e.data, "Closing connection.");
      setTimeout(this.onClosed_.bind(this), 0);
    }
  }
}
WebSocketConnection.responsesRequiredToBeHealthy = 2;
WebSocketConnection.healthyTimeout = 30000;
var name2 = "@firebase/database";
var version3 = "0.14.4";

class AppCheckTokenProvider {
  constructor(appName_, appCheckProvider) {
    this.appName_ = appName_;
    this.appCheckProvider = appCheckProvider;
    this.appCheck = appCheckProvider === null || appCheckProvider === undefined ? undefined : appCheckProvider.getImmediate({ optional: true });
    if (!this.appCheck) {
      appCheckProvider === null || appCheckProvider === undefined || appCheckProvider.get().then((appCheck) => this.appCheck = appCheck);
    }
  }
  getToken(forceRefresh) {
    if (!this.appCheck) {
      return new Promise((resolve, reject) => {
        setTimeout(() => {
          if (this.appCheck) {
            this.getToken(forceRefresh).then(resolve, reject);
          } else {
            resolve(null);
          }
        }, 0);
      });
    }
    return this.appCheck.getToken(forceRefresh);
  }
  addTokenChangeListener(listener) {
    var _a;
    (_a = this.appCheckProvider) === null || _a === undefined || _a.get().then((appCheck) => appCheck.addTokenListener(listener));
  }
  notifyForInvalidToken() {
    warn(`Provided AppCheck credentials for the app named "${this.appName_}" ` + "are invalid. This usually indicates your app was not initialized correctly.");
  }
}

class FirebaseAuthTokenProvider {
  constructor(appName_, firebaseOptions_, authProvider_) {
    this.appName_ = appName_;
    this.firebaseOptions_ = firebaseOptions_;
    this.authProvider_ = authProvider_;
    this.auth_ = null;
    this.auth_ = authProvider_.getImmediate({ optional: true });
    if (!this.auth_) {
      authProvider_.onInit((auth) => this.auth_ = auth);
    }
  }
  getToken(forceRefresh) {
    if (!this.auth_) {
      return new Promise((resolve, reject) => {
        setTimeout(() => {
          if (this.auth_) {
            this.getToken(forceRefresh).then(resolve, reject);
          } else {
            resolve(null);
          }
        }, 0);
      });
    }
    return this.auth_.getToken(forceRefresh).catch((error2) => {
      if (error2 && error2.code === "auth/token-not-initialized") {
        log2("Got auth/token-not-initialized error.  Treating as null token.");
        return null;
      } else {
        return Promise.reject(error2);
      }
    });
  }
  addTokenChangeListener(listener) {
    if (this.auth_) {
      this.auth_.addAuthTokenListener(listener);
    } else {
      this.authProvider_.get().then((auth) => auth.addAuthTokenListener(listener));
    }
  }
  removeTokenChangeListener(listener) {
    this.authProvider_.get().then((auth) => auth.removeAuthTokenListener(listener));
  }
  notifyForInvalidToken() {
    let errorMessage = 'Provided authentication credentials for the app named "' + this.appName_ + '" are invalid. This usually indicates your app was not initialized correctly. ';
    if ("credential" in this.firebaseOptions_) {
      errorMessage += 'Make sure the "credential" property provided to initializeApp() is authorized to access the specified "databaseURL" and is from the correct project.';
    } else if ("serviceAccount" in this.firebaseOptions_) {
      errorMessage += 'Make sure the "serviceAccount" property provided to initializeApp() is authorized to access the specified "databaseURL" and is from the correct project.';
    } else {
      errorMessage += 'Make sure the "apiKey" and "databaseURL" properties provided to initializeApp() match the values provided for your app at https://console.firebase.google.com/.';
    }
    warn(errorMessage);
  }
}

class EmulatorTokenProvider {
  constructor(accessToken) {
    this.accessToken = accessToken;
  }
  getToken(forceRefresh) {
    return Promise.resolve({
      accessToken: this.accessToken
    });
  }
  addTokenChangeListener(listener) {
    listener(this.accessToken);
  }
  removeTokenChangeListener(listener) {
  }
  notifyForInvalidToken() {
  }
}
EmulatorTokenProvider.OWNER = "owner";

class PacketReceiver {
  constructor(onMessage_) {
    this.onMessage_ = onMessage_;
    this.pendingResponses = [];
    this.currentResponseNum = 0;
    this.closeAfterResponse = -1;
    this.onClose = null;
  }
  closeAfter(responseNum, callback) {
    this.closeAfterResponse = responseNum;
    this.onClose = callback;
    if (this.closeAfterResponse < this.currentResponseNum) {
      this.onClose();
      this.onClose = null;
    }
  }
  handleResponse(requestNum, data) {
    this.pendingResponses[requestNum] = data;
    while (this.pendingResponses[this.currentResponseNum]) {
      const toProcess = this.pendingResponses[this.currentResponseNum];
      delete this.pendingResponses[this.currentResponseNum];
      for (let i = 0;i < toProcess.length; ++i) {
        if (toProcess[i]) {
          exceptionGuard(() => {
            this.onMessage_(toProcess[i]);
          });
        }
      }
      if (this.currentResponseNum === this.closeAfterResponse) {
        if (this.onClose) {
          this.onClose();
          this.onClose = null;
        }
        break;
      }
      this.currentResponseNum++;
    }
  }
}
var FIREBASE_LONGPOLL_START_PARAM = "start";
var FIREBASE_LONGPOLL_CLOSE_COMMAND = "close";
var FIREBASE_LONGPOLL_COMMAND_CB_NAME = "pLPCommand";
var FIREBASE_LONGPOLL_DATA_CB_NAME = "pRTLPCB";
var FIREBASE_LONGPOLL_ID_PARAM = "id";
var FIREBASE_LONGPOLL_PW_PARAM = "pw";
var FIREBASE_LONGPOLL_SERIAL_PARAM = "ser";
var FIREBASE_LONGPOLL_CALLBACK_ID_PARAM = "cb";
var FIREBASE_LONGPOLL_SEGMENT_NUM_PARAM = "seg";
var FIREBASE_LONGPOLL_SEGMENTS_IN_PACKET = "ts";
var FIREBASE_LONGPOLL_DATA_PARAM = "d";
var FIREBASE_LONGPOLL_DISCONN_FRAME_REQUEST_PARAM = "dframe";
var MAX_URL_DATA_SIZE = 1870;
var SEG_HEADER_SIZE = 30;
var MAX_PAYLOAD_SIZE = MAX_URL_DATA_SIZE - SEG_HEADER_SIZE;
var KEEPALIVE_REQUEST_INTERVAL = 25000;
var LP_CONNECT_TIMEOUT = 30000;

class BrowserPollConnection {
  constructor(connId, repoInfo, applicationId, appCheckToken, authToken, transportSessionId, lastSessionId) {
    this.connId = connId;
    this.repoInfo = repoInfo;
    this.applicationId = applicationId;
    this.appCheckToken = appCheckToken;
    this.authToken = authToken;
    this.transportSessionId = transportSessionId;
    this.lastSessionId = lastSessionId;
    this.bytesSent = 0;
    this.bytesReceived = 0;
    this.everConnected_ = false;
    this.log_ = logWrapper(connId);
    this.stats_ = statsManagerGetCollection(repoInfo);
    this.urlFn = (params) => {
      if (this.appCheckToken) {
        params[APP_CHECK_TOKEN_PARAM] = this.appCheckToken;
      }
      return repoInfoConnectionURL(repoInfo, LONG_POLLING, params);
    };
  }
  open(onMessage, onDisconnect) {
    this.curSegmentNum = 0;
    this.onDisconnect_ = onDisconnect;
    this.myPacketOrderer = new PacketReceiver(onMessage);
    this.isClosed_ = false;
    this.connectTimeoutTimer_ = setTimeout(() => {
      this.log_("Timed out trying to connect.");
      this.onClosed_();
      this.connectTimeoutTimer_ = null;
    }, Math.floor(LP_CONNECT_TIMEOUT));
    executeWhenDOMReady(() => {
      if (this.isClosed_) {
        return;
      }
      this.scriptTagHolder = new FirebaseIFrameScriptHolder((...args7) => {
        const [command, arg1, arg2, arg3, arg4] = args7;
        this.incrementIncomingBytes_(args7);
        if (!this.scriptTagHolder) {
          return;
        }
        if (this.connectTimeoutTimer_) {
          clearTimeout(this.connectTimeoutTimer_);
          this.connectTimeoutTimer_ = null;
        }
        this.everConnected_ = true;
        if (command === FIREBASE_LONGPOLL_START_PARAM) {
          this.id = arg1;
          this.password = arg2;
        } else if (command === FIREBASE_LONGPOLL_CLOSE_COMMAND) {
          if (arg1) {
            this.scriptTagHolder.sendNewPolls = false;
            this.myPacketOrderer.closeAfter(arg1, () => {
              this.onClosed_();
            });
          } else {
            this.onClosed_();
          }
        } else {
          throw new Error("Unrecognized command received: " + command);
        }
      }, (...args7) => {
        const [pN, data] = args7;
        this.incrementIncomingBytes_(args7);
        this.myPacketOrderer.handleResponse(pN, data);
      }, () => {
        this.onClosed_();
      }, this.urlFn);
      const urlParams = {};
      urlParams[FIREBASE_LONGPOLL_START_PARAM] = "t";
      urlParams[FIREBASE_LONGPOLL_SERIAL_PARAM] = Math.floor(Math.random() * 1e8);
      if (this.scriptTagHolder.uniqueCallbackIdentifier) {
        urlParams[FIREBASE_LONGPOLL_CALLBACK_ID_PARAM] = this.scriptTagHolder.uniqueCallbackIdentifier;
      }
      urlParams[VERSION_PARAM] = PROTOCOL_VERSION;
      if (this.transportSessionId) {
        urlParams[TRANSPORT_SESSION_PARAM] = this.transportSessionId;
      }
      if (this.lastSessionId) {
        urlParams[LAST_SESSION_PARAM] = this.lastSessionId;
      }
      if (this.applicationId) {
        urlParams[APPLICATION_ID_PARAM] = this.applicationId;
      }
      if (this.appCheckToken) {
        urlParams[APP_CHECK_TOKEN_PARAM] = this.appCheckToken;
      }
      if (typeof location !== "undefined" && location.hostname && FORGE_DOMAIN_RE.test(location.hostname)) {
        urlParams[REFERER_PARAM] = FORGE_REF;
      }
      const connectURL = this.urlFn(urlParams);
      this.log_("Connecting via long-poll to " + connectURL);
      this.scriptTagHolder.addTag(connectURL, () => {
      });
    });
  }
  start() {
    this.scriptTagHolder.startLongPoll(this.id, this.password);
    this.addDisconnectPingFrame(this.id, this.password);
  }
  static forceAllow() {
    BrowserPollConnection.forceAllow_ = true;
  }
  static forceDisallow() {
    BrowserPollConnection.forceDisallow_ = true;
  }
  static isAvailable() {
    if (isNodeSdk()) {
      return false;
    } else if (BrowserPollConnection.forceAllow_) {
      return true;
    } else {
      return !BrowserPollConnection.forceDisallow_ && typeof document !== "undefined" && document.createElement != null && !isChromeExtensionContentScript() && !isWindowsStoreApp();
    }
  }
  markConnectionHealthy() {
  }
  shutdown_() {
    this.isClosed_ = true;
    if (this.scriptTagHolder) {
      this.scriptTagHolder.close();
      this.scriptTagHolder = null;
    }
    if (this.myDisconnFrame) {
      document.body.removeChild(this.myDisconnFrame);
      this.myDisconnFrame = null;
    }
    if (this.connectTimeoutTimer_) {
      clearTimeout(this.connectTimeoutTimer_);
      this.connectTimeoutTimer_ = null;
    }
  }
  onClosed_() {
    if (!this.isClosed_) {
      this.log_("Longpoll is closing itself");
      this.shutdown_();
      if (this.onDisconnect_) {
        this.onDisconnect_(this.everConnected_);
        this.onDisconnect_ = null;
      }
    }
  }
  close() {
    if (!this.isClosed_) {
      this.log_("Longpoll is being closed.");
      this.shutdown_();
    }
  }
  send(data) {
    const dataStr = stringify(data);
    this.bytesSent += dataStr.length;
    this.stats_.incrementCounter("bytes_sent", dataStr.length);
    const base64data = base64Encode2(dataStr);
    const dataSegs = splitStringBySize(base64data, MAX_PAYLOAD_SIZE);
    for (let i = 0;i < dataSegs.length; i++) {
      this.scriptTagHolder.enqueueSegment(this.curSegmentNum, dataSegs.length, dataSegs[i]);
      this.curSegmentNum++;
    }
  }
  addDisconnectPingFrame(id, pw) {
    if (isNodeSdk()) {
      return;
    }
    this.myDisconnFrame = document.createElement("iframe");
    const urlParams = {};
    urlParams[FIREBASE_LONGPOLL_DISCONN_FRAME_REQUEST_PARAM] = "t";
    urlParams[FIREBASE_LONGPOLL_ID_PARAM] = id;
    urlParams[FIREBASE_LONGPOLL_PW_PARAM] = pw;
    this.myDisconnFrame.src = this.urlFn(urlParams);
    this.myDisconnFrame.style.display = "none";
    document.body.appendChild(this.myDisconnFrame);
  }
  incrementIncomingBytes_(args7) {
    const bytesReceived = stringify(args7).length;
    this.bytesReceived += bytesReceived;
    this.stats_.incrementCounter("bytes_received", bytesReceived);
  }
}

class FirebaseIFrameScriptHolder {
  constructor(commandCB, onMessageCB, onDisconnect, urlFn) {
    this.onDisconnect = onDisconnect;
    this.urlFn = urlFn;
    this.outstandingRequests = new Set;
    this.pendingSegs = [];
    this.currentSerial = Math.floor(Math.random() * 1e8);
    this.sendNewPolls = true;
    if (!isNodeSdk()) {
      this.uniqueCallbackIdentifier = LUIDGenerator();
      window[FIREBASE_LONGPOLL_COMMAND_CB_NAME + this.uniqueCallbackIdentifier] = commandCB;
      window[FIREBASE_LONGPOLL_DATA_CB_NAME + this.uniqueCallbackIdentifier] = onMessageCB;
      this.myIFrame = FirebaseIFrameScriptHolder.createIFrame_();
      let script = "";
      if (this.myIFrame.src && this.myIFrame.src.substr(0, "javascript:".length) === "javascript:") {
        const currentDomain = document.domain;
        script = '<script>document.domain="' + currentDomain + '";</script>';
      }
      const iframeContents = "<html><body>" + script + "</body></html>";
      try {
        this.myIFrame.doc.open();
        this.myIFrame.doc.write(iframeContents);
        this.myIFrame.doc.close();
      } catch (e) {
        log2("frame writing exception");
        if (e.stack) {
          log2(e.stack);
        }
        log2(e);
      }
    } else {
      this.commandCB = commandCB;
      this.onMessageCB = onMessageCB;
    }
  }
  static createIFrame_() {
    const iframe = document.createElement("iframe");
    iframe.style.display = "none";
    if (document.body) {
      document.body.appendChild(iframe);
      try {
        const a = iframe.contentWindow.document;
        if (!a) {
          log2("No IE domain setting required");
        }
      } catch (e) {
        const domain = document.domain;
        iframe.src = "javascript:void((function(){document.open();document.domain='" + domain + "';document.close();})())";
      }
    } else {
      throw "Document body has not initialized. Wait to initialize Firebase until after the document is ready.";
    }
    if (iframe.contentDocument) {
      iframe.doc = iframe.contentDocument;
    } else if (iframe.contentWindow) {
      iframe.doc = iframe.contentWindow.document;
    } else if (iframe.document) {
      iframe.doc = iframe.document;
    }
    return iframe;
  }
  close() {
    this.alive = false;
    if (this.myIFrame) {
      this.myIFrame.doc.body.textContent = "";
      setTimeout(() => {
        if (this.myIFrame !== null) {
          document.body.removeChild(this.myIFrame);
          this.myIFrame = null;
        }
      }, Math.floor(0));
    }
    const onDisconnect = this.onDisconnect;
    if (onDisconnect) {
      this.onDisconnect = null;
      onDisconnect();
    }
  }
  startLongPoll(id, pw) {
    this.myID = id;
    this.myPW = pw;
    this.alive = true;
    while (this.newRequest_()) {
    }
  }
  newRequest_() {
    if (this.alive && this.sendNewPolls && this.outstandingRequests.size < (this.pendingSegs.length > 0 ? 2 : 1)) {
      this.currentSerial++;
      const urlParams = {};
      urlParams[FIREBASE_LONGPOLL_ID_PARAM] = this.myID;
      urlParams[FIREBASE_LONGPOLL_PW_PARAM] = this.myPW;
      urlParams[FIREBASE_LONGPOLL_SERIAL_PARAM] = this.currentSerial;
      let theURL = this.urlFn(urlParams);
      let curDataString = "";
      let i = 0;
      while (this.pendingSegs.length > 0) {
        const nextSeg = this.pendingSegs[0];
        if (nextSeg.d.length + SEG_HEADER_SIZE + curDataString.length <= MAX_URL_DATA_SIZE) {
          const theSeg = this.pendingSegs.shift();
          curDataString = curDataString + "&" + FIREBASE_LONGPOLL_SEGMENT_NUM_PARAM + i + "=" + theSeg.seg + "&" + FIREBASE_LONGPOLL_SEGMENTS_IN_PACKET + i + "=" + theSeg.ts + "&" + FIREBASE_LONGPOLL_DATA_PARAM + i + "=" + theSeg.d;
          i++;
        } else {
          break;
        }
      }
      theURL = theURL + curDataString;
      this.addLongPollTag_(theURL, this.currentSerial);
      return true;
    } else {
      return false;
    }
  }
  enqueueSegment(segnum, totalsegs, data) {
    this.pendingSegs.push({ seg: segnum, ts: totalsegs, d: data });
    if (this.alive) {
      this.newRequest_();
    }
  }
  addLongPollTag_(url, serial) {
    this.outstandingRequests.add(serial);
    const doNewRequest = () => {
      this.outstandingRequests.delete(serial);
      this.newRequest_();
    };
    const keepaliveTimeout = setTimeout(doNewRequest, Math.floor(KEEPALIVE_REQUEST_INTERVAL));
    const readyStateCB = () => {
      clearTimeout(keepaliveTimeout);
      doNewRequest();
    };
    this.addTag(url, readyStateCB);
  }
  addTag(url, loadCB) {
    if (isNodeSdk()) {
      this.doNodeLongPoll(url, loadCB);
    } else {
      setTimeout(() => {
        try {
          if (!this.sendNewPolls) {
            return;
          }
          const newScript = this.myIFrame.doc.createElement("script");
          newScript.type = "text/javascript";
          newScript.async = true;
          newScript.src = url;
          newScript.onload = newScript.onreadystatechange = function() {
            const rstate = newScript.readyState;
            if (!rstate || rstate === "loaded" || rstate === "complete") {
              newScript.onload = newScript.onreadystatechange = null;
              if (newScript.parentNode) {
                newScript.parentNode.removeChild(newScript);
              }
              loadCB();
            }
          };
          newScript.onerror = () => {
            log2("Long-poll script failed to load: " + url);
            this.sendNewPolls = false;
            this.close();
          };
          this.myIFrame.doc.body.appendChild(newScript);
        } catch (e) {
        }
      }, Math.floor(1));
    }
  }
}

class TransportManager {
  constructor(repoInfo) {
    this.initTransports_(repoInfo);
  }
  static get ALL_TRANSPORTS() {
    return [BrowserPollConnection, WebSocketConnection];
  }
  static get IS_TRANSPORT_INITIALIZED() {
    return this.globalTransportInitialized_;
  }
  initTransports_(repoInfo) {
    const isWebSocketsAvailable = WebSocketConnection && WebSocketConnection["isAvailable"]();
    let isSkipPollConnection = isWebSocketsAvailable && !WebSocketConnection.previouslyFailed();
    if (repoInfo.webSocketOnly) {
      if (!isWebSocketsAvailable) {
        warn("wss:// URL used, but browser isn't known to support websockets.  Trying anyway.");
      }
      isSkipPollConnection = true;
    }
    if (isSkipPollConnection) {
      this.transports_ = [WebSocketConnection];
    } else {
      const transports = this.transports_ = [];
      for (const transport of TransportManager.ALL_TRANSPORTS) {
        if (transport && transport["isAvailable"]()) {
          transports.push(transport);
        }
      }
      TransportManager.globalTransportInitialized_ = true;
    }
  }
  initialTransport() {
    if (this.transports_.length > 0) {
      return this.transports_[0];
    } else {
      throw new Error("No transports available");
    }
  }
  upgradeTransport() {
    if (this.transports_.length > 1) {
      return this.transports_[1];
    } else {
      return null;
    }
  }
}
TransportManager.globalTransportInitialized_ = false;
var UPGRADE_TIMEOUT = 60000;
var DELAY_BEFORE_SENDING_EXTRA_REQUESTS = 5000;
var BYTES_SENT_HEALTHY_OVERRIDE = 10 * 1024;
var BYTES_RECEIVED_HEALTHY_OVERRIDE = 100 * 1024;
var MESSAGE_TYPE = "t";
var MESSAGE_DATA = "d";
var CONTROL_SHUTDOWN = "s";
var CONTROL_RESET = "r";
var CONTROL_ERROR = "e";
var CONTROL_PONG = "o";
var SWITCH_ACK = "a";
var END_TRANSMISSION = "n";
var PING = "p";
var SERVER_HELLO = "h";

class Connection {
  constructor(id, repoInfo_, applicationId_, appCheckToken_, authToken_, onMessage_, onReady_, onDisconnect_, onKill_, lastSessionId) {
    this.id = id;
    this.repoInfo_ = repoInfo_;
    this.applicationId_ = applicationId_;
    this.appCheckToken_ = appCheckToken_;
    this.authToken_ = authToken_;
    this.onMessage_ = onMessage_;
    this.onReady_ = onReady_;
    this.onDisconnect_ = onDisconnect_;
    this.onKill_ = onKill_;
    this.lastSessionId = lastSessionId;
    this.connectionCount = 0;
    this.pendingDataMessages = [];
    this.state_ = 0;
    this.log_ = logWrapper("c:" + this.id + ":");
    this.transportManager_ = new TransportManager(repoInfo_);
    this.log_("Connection created");
    this.start_();
  }
  start_() {
    const conn = this.transportManager_.initialTransport();
    this.conn_ = new conn(this.nextTransportId_(), this.repoInfo_, this.applicationId_, this.appCheckToken_, this.authToken_, null, this.lastSessionId);
    this.primaryResponsesRequired_ = conn["responsesRequiredToBeHealthy"] || 0;
    const onMessageReceived = this.connReceiver_(this.conn_);
    const onConnectionLost = this.disconnReceiver_(this.conn_);
    this.tx_ = this.conn_;
    this.rx_ = this.conn_;
    this.secondaryConn_ = null;
    this.isHealthy_ = false;
    setTimeout(() => {
      this.conn_ && this.conn_.open(onMessageReceived, onConnectionLost);
    }, Math.floor(0));
    const healthyTimeoutMS = conn["healthyTimeout"] || 0;
    if (healthyTimeoutMS > 0) {
      this.healthyTimeout_ = setTimeoutNonBlocking(() => {
        this.healthyTimeout_ = null;
        if (!this.isHealthy_) {
          if (this.conn_ && this.conn_.bytesReceived > BYTES_RECEIVED_HEALTHY_OVERRIDE) {
            this.log_("Connection exceeded healthy timeout but has received " + this.conn_.bytesReceived + " bytes.  Marking connection healthy.");
            this.isHealthy_ = true;
            this.conn_.markConnectionHealthy();
          } else if (this.conn_ && this.conn_.bytesSent > BYTES_SENT_HEALTHY_OVERRIDE) {
            this.log_("Connection exceeded healthy timeout but has sent " + this.conn_.bytesSent + " bytes.  Leaving connection alive.");
          } else {
            this.log_("Closing unhealthy connection after timeout.");
            this.close();
          }
        }
      }, Math.floor(healthyTimeoutMS));
    }
  }
  nextTransportId_() {
    return "c:" + this.id + ":" + this.connectionCount++;
  }
  disconnReceiver_(conn) {
    return (everConnected) => {
      if (conn === this.conn_) {
        this.onConnectionLost_(everConnected);
      } else if (conn === this.secondaryConn_) {
        this.log_("Secondary connection lost.");
        this.onSecondaryConnectionLost_();
      } else {
        this.log_("closing an old connection");
      }
    };
  }
  connReceiver_(conn) {
    return (message) => {
      if (this.state_ !== 2) {
        if (conn === this.rx_) {
          this.onPrimaryMessageReceived_(message);
        } else if (conn === this.secondaryConn_) {
          this.onSecondaryMessageReceived_(message);
        } else {
          this.log_("message on old connection");
        }
      }
    };
  }
  sendRequest(dataMsg) {
    const msg = { t: "d", d: dataMsg };
    this.sendData_(msg);
  }
  tryCleanupConnection() {
    if (this.tx_ === this.secondaryConn_ && this.rx_ === this.secondaryConn_) {
      this.log_("cleaning up and promoting a connection: " + this.secondaryConn_.connId);
      this.conn_ = this.secondaryConn_;
      this.secondaryConn_ = null;
    }
  }
  onSecondaryControl_(controlData) {
    if (MESSAGE_TYPE in controlData) {
      const cmd = controlData[MESSAGE_TYPE];
      if (cmd === SWITCH_ACK) {
        this.upgradeIfSecondaryHealthy_();
      } else if (cmd === CONTROL_RESET) {
        this.log_("Got a reset on secondary, closing it");
        this.secondaryConn_.close();
        if (this.tx_ === this.secondaryConn_ || this.rx_ === this.secondaryConn_) {
          this.close();
        }
      } else if (cmd === CONTROL_PONG) {
        this.log_("got pong on secondary.");
        this.secondaryResponsesRequired_--;
        this.upgradeIfSecondaryHealthy_();
      }
    }
  }
  onSecondaryMessageReceived_(parsedData) {
    const layer = requireKey("t", parsedData);
    const data = requireKey("d", parsedData);
    if (layer === "c") {
      this.onSecondaryControl_(data);
    } else if (layer === "d") {
      this.pendingDataMessages.push(data);
    } else {
      throw new Error("Unknown protocol layer: " + layer);
    }
  }
  upgradeIfSecondaryHealthy_() {
    if (this.secondaryResponsesRequired_ <= 0) {
      this.log_("Secondary connection is healthy.");
      this.isHealthy_ = true;
      this.secondaryConn_.markConnectionHealthy();
      this.proceedWithUpgrade_();
    } else {
      this.log_("sending ping on secondary.");
      this.secondaryConn_.send({ t: "c", d: { t: PING, d: {} } });
    }
  }
  proceedWithUpgrade_() {
    this.secondaryConn_.start();
    this.log_("sending client ack on secondary");
    this.secondaryConn_.send({ t: "c", d: { t: SWITCH_ACK, d: {} } });
    this.log_("Ending transmission on primary");
    this.conn_.send({ t: "c", d: { t: END_TRANSMISSION, d: {} } });
    this.tx_ = this.secondaryConn_;
    this.tryCleanupConnection();
  }
  onPrimaryMessageReceived_(parsedData) {
    const layer = requireKey("t", parsedData);
    const data = requireKey("d", parsedData);
    if (layer === "c") {
      this.onControl_(data);
    } else if (layer === "d") {
      this.onDataMessage_(data);
    }
  }
  onDataMessage_(message) {
    this.onPrimaryResponse_();
    this.onMessage_(message);
  }
  onPrimaryResponse_() {
    if (!this.isHealthy_) {
      this.primaryResponsesRequired_--;
      if (this.primaryResponsesRequired_ <= 0) {
        this.log_("Primary connection is healthy.");
        this.isHealthy_ = true;
        this.conn_.markConnectionHealthy();
      }
    }
  }
  onControl_(controlData) {
    const cmd = requireKey(MESSAGE_TYPE, controlData);
    if (MESSAGE_DATA in controlData) {
      const payload = controlData[MESSAGE_DATA];
      if (cmd === SERVER_HELLO) {
        const handshakePayload = Object.assign({}, payload);
        if (this.repoInfo_.isUsingEmulator) {
          handshakePayload.h = this.repoInfo_.host;
        }
        this.onHandshake_(handshakePayload);
      } else if (cmd === END_TRANSMISSION) {
        this.log_("recvd end transmission on primary");
        this.rx_ = this.secondaryConn_;
        for (let i = 0;i < this.pendingDataMessages.length; ++i) {
          this.onDataMessage_(this.pendingDataMessages[i]);
        }
        this.pendingDataMessages = [];
        this.tryCleanupConnection();
      } else if (cmd === CONTROL_SHUTDOWN) {
        this.onConnectionShutdown_(payload);
      } else if (cmd === CONTROL_RESET) {
        this.onReset_(payload);
      } else if (cmd === CONTROL_ERROR) {
        error("Server Error: " + payload);
      } else if (cmd === CONTROL_PONG) {
        this.log_("got pong on primary.");
        this.onPrimaryResponse_();
        this.sendPingOnPrimaryIfNecessary_();
      } else {
        error("Unknown control packet command: " + cmd);
      }
    }
  }
  onHandshake_(handshake) {
    const timestamp = handshake.ts;
    const version4 = handshake.v;
    const host = handshake.h;
    this.sessionId = handshake.s;
    this.repoInfo_.host = host;
    if (this.state_ === 0) {
      this.conn_.start();
      this.onConnectionEstablished_(this.conn_, timestamp);
      if (PROTOCOL_VERSION !== version4) {
        warn("Protocol version mismatch detected");
      }
      this.tryStartUpgrade_();
    }
  }
  tryStartUpgrade_() {
    const conn = this.transportManager_.upgradeTransport();
    if (conn) {
      this.startUpgrade_(conn);
    }
  }
  startUpgrade_(conn) {
    this.secondaryConn_ = new conn(this.nextTransportId_(), this.repoInfo_, this.applicationId_, this.appCheckToken_, this.authToken_, this.sessionId);
    this.secondaryResponsesRequired_ = conn["responsesRequiredToBeHealthy"] || 0;
    const onMessage = this.connReceiver_(this.secondaryConn_);
    const onDisconnect = this.disconnReceiver_(this.secondaryConn_);
    this.secondaryConn_.open(onMessage, onDisconnect);
    setTimeoutNonBlocking(() => {
      if (this.secondaryConn_) {
        this.log_("Timed out trying to upgrade.");
        this.secondaryConn_.close();
      }
    }, Math.floor(UPGRADE_TIMEOUT));
  }
  onReset_(host) {
    this.log_("Reset packet received.  New host: " + host);
    this.repoInfo_.host = host;
    if (this.state_ === 1) {
      this.close();
    } else {
      this.closeConnections_();
      this.start_();
    }
  }
  onConnectionEstablished_(conn, timestamp) {
    this.log_("Realtime connection established.");
    this.conn_ = conn;
    this.state_ = 1;
    if (this.onReady_) {
      this.onReady_(timestamp, this.sessionId);
      this.onReady_ = null;
    }
    if (this.primaryResponsesRequired_ === 0) {
      this.log_("Primary connection is healthy.");
      this.isHealthy_ = true;
    } else {
      setTimeoutNonBlocking(() => {
        this.sendPingOnPrimaryIfNecessary_();
      }, Math.floor(DELAY_BEFORE_SENDING_EXTRA_REQUESTS));
    }
  }
  sendPingOnPrimaryIfNecessary_() {
    if (!this.isHealthy_ && this.state_ === 1) {
      this.log_("sending ping on primary.");
      this.sendData_({ t: "c", d: { t: PING, d: {} } });
    }
  }
  onSecondaryConnectionLost_() {
    const conn = this.secondaryConn_;
    this.secondaryConn_ = null;
    if (this.tx_ === conn || this.rx_ === conn) {
      this.close();
    }
  }
  onConnectionLost_(everConnected) {
    this.conn_ = null;
    if (!everConnected && this.state_ === 0) {
      this.log_("Realtime connection failed.");
      if (this.repoInfo_.isCacheableHost()) {
        PersistentStorage.remove("host:" + this.repoInfo_.host);
        this.repoInfo_.internalHost = this.repoInfo_.host;
      }
    } else if (this.state_ === 1) {
      this.log_("Realtime connection lost.");
    }
    this.close();
  }
  onConnectionShutdown_(reason) {
    this.log_("Connection shutdown command received. Shutting down...");
    if (this.onKill_) {
      this.onKill_(reason);
      this.onKill_ = null;
    }
    this.onDisconnect_ = null;
    this.close();
  }
  sendData_(data) {
    if (this.state_ !== 1) {
      throw "Connection is not connected";
    } else {
      this.tx_.send(data);
    }
  }
  close() {
    if (this.state_ !== 2) {
      this.log_("Closing realtime connection.");
      this.state_ = 2;
      this.closeConnections_();
      if (this.onDisconnect_) {
        this.onDisconnect_();
        this.onDisconnect_ = null;
      }
    }
  }
  closeConnections_() {
    this.log_("Shutting down all connections");
    if (this.conn_) {
      this.conn_.close();
      this.conn_ = null;
    }
    if (this.secondaryConn_) {
      this.secondaryConn_.close();
      this.secondaryConn_ = null;
    }
    if (this.healthyTimeout_) {
      clearTimeout(this.healthyTimeout_);
      this.healthyTimeout_ = null;
    }
  }
}

class ServerActions {
  put(pathString, data, onComplete, hash) {
  }
  merge(pathString, data, onComplete, hash) {
  }
  refreshAuthToken(token) {
  }
  refreshAppCheckToken(token) {
  }
  onDisconnectPut(pathString, data, onComplete) {
  }
  onDisconnectMerge(pathString, data, onComplete) {
  }
  onDisconnectCancel(pathString, onComplete) {
  }
  reportStats(stats) {
  }
}

class EventEmitter {
  constructor(allowedEvents_) {
    this.allowedEvents_ = allowedEvents_;
    this.listeners_ = {};
    assert(Array.isArray(allowedEvents_) && allowedEvents_.length > 0, "Requires a non-empty array");
  }
  trigger(eventType, ...varArgs) {
    if (Array.isArray(this.listeners_[eventType])) {
      const listeners = [...this.listeners_[eventType]];
      for (let i = 0;i < listeners.length; i++) {
        listeners[i].callback.apply(listeners[i].context, varArgs);
      }
    }
  }
  on(eventType, callback, context) {
    this.validateEventType_(eventType);
    this.listeners_[eventType] = this.listeners_[eventType] || [];
    this.listeners_[eventType].push({ callback, context });
    const eventData = this.getInitialEvent(eventType);
    if (eventData) {
      callback.apply(context, eventData);
    }
  }
  off(eventType, callback, context) {
    this.validateEventType_(eventType);
    const listeners = this.listeners_[eventType] || [];
    for (let i = 0;i < listeners.length; i++) {
      if (listeners[i].callback === callback && (!context || context === listeners[i].context)) {
        listeners.splice(i, 1);
        return;
      }
    }
  }
  validateEventType_(eventType) {
    assert(this.allowedEvents_.find((et) => {
      return et === eventType;
    }), "Unknown event: " + eventType);
  }
}

class OnlineMonitor extends EventEmitter {
  constructor() {
    super(["online"]);
    this.online_ = true;
    if (typeof window !== "undefined" && typeof window.addEventListener !== "undefined" && !isMobileCordova()) {
      window.addEventListener("online", () => {
        if (!this.online_) {
          this.online_ = true;
          this.trigger("online", true);
        }
      }, false);
      window.addEventListener("offline", () => {
        if (this.online_) {
          this.online_ = false;
          this.trigger("online", false);
        }
      }, false);
    }
  }
  static getInstance() {
    return new OnlineMonitor;
  }
  getInitialEvent(eventType) {
    assert(eventType === "online", "Unknown event type: " + eventType);
    return [this.online_];
  }
  currentlyOnline() {
    return this.online_;
  }
}
var MAX_PATH_DEPTH = 32;
var MAX_PATH_LENGTH_BYTES = 768;

class Path3 {
  constructor(pathOrString, pieceNum) {
    if (pieceNum === undefined) {
      this.pieces_ = pathOrString.split("/");
      let copyTo = 0;
      for (let i = 0;i < this.pieces_.length; i++) {
        if (this.pieces_[i].length > 0) {
          this.pieces_[copyTo] = this.pieces_[i];
          copyTo++;
        }
      }
      this.pieces_.length = copyTo;
      this.pieceNum_ = 0;
    } else {
      this.pieces_ = pathOrString;
      this.pieceNum_ = pieceNum;
    }
  }
  toString() {
    let pathString = "";
    for (let i = this.pieceNum_;i < this.pieces_.length; i++) {
      if (this.pieces_[i] !== "") {
        pathString += "/" + this.pieces_[i];
      }
    }
    return pathString || "/";
  }
}

class ValidationPath {
  constructor(path5, errorPrefix_) {
    this.errorPrefix_ = errorPrefix_;
    this.parts_ = pathSlice(path5, 0);
    this.byteLength_ = Math.max(1, this.parts_.length);
    for (let i = 0;i < this.parts_.length; i++) {
      this.byteLength_ += stringLength(this.parts_[i]);
    }
    validationPathCheckValid(this);
  }
}

class VisibilityMonitor extends EventEmitter {
  constructor() {
    super(["visible"]);
    let hidden;
    let visibilityChange;
    if (typeof document !== "undefined" && typeof document.addEventListener !== "undefined") {
      if (typeof document["hidden"] !== "undefined") {
        visibilityChange = "visibilitychange";
        hidden = "hidden";
      } else if (typeof document["mozHidden"] !== "undefined") {
        visibilityChange = "mozvisibilitychange";
        hidden = "mozHidden";
      } else if (typeof document["msHidden"] !== "undefined") {
        visibilityChange = "msvisibilitychange";
        hidden = "msHidden";
      } else if (typeof document["webkitHidden"] !== "undefined") {
        visibilityChange = "webkitvisibilitychange";
        hidden = "webkitHidden";
      }
    }
    this.visible_ = true;
    if (visibilityChange) {
      document.addEventListener(visibilityChange, () => {
        const visible = !document[hidden];
        if (visible !== this.visible_) {
          this.visible_ = visible;
          this.trigger("visible", visible);
        }
      }, false);
    }
  }
  static getInstance() {
    return new VisibilityMonitor;
  }
  getInitialEvent(eventType) {
    assert(eventType === "visible", "Unknown event type: " + eventType);
    return [this.visible_];
  }
}
var RECONNECT_MIN_DELAY = 1000;
var RECONNECT_MAX_DELAY_DEFAULT = 60 * 5 * 1000;
var RECONNECT_MAX_DELAY_FOR_ADMINS = 30 * 1000;
var RECONNECT_DELAY_MULTIPLIER = 1.3;
var RECONNECT_DELAY_RESET_TIMEOUT = 30000;
var SERVER_KILL_INTERRUPT_REASON = "server_kill";
var INVALID_TOKEN_THRESHOLD = 3;

class PersistentConnection extends ServerActions {
  constructor(repoInfo_, applicationId_, onDataUpdate_, onConnectStatus_, onServerInfoUpdate_, authTokenProvider_, appCheckTokenProvider_, authOverride_) {
    super();
    this.repoInfo_ = repoInfo_;
    this.applicationId_ = applicationId_;
    this.onDataUpdate_ = onDataUpdate_;
    this.onConnectStatus_ = onConnectStatus_;
    this.onServerInfoUpdate_ = onServerInfoUpdate_;
    this.authTokenProvider_ = authTokenProvider_;
    this.appCheckTokenProvider_ = appCheckTokenProvider_;
    this.authOverride_ = authOverride_;
    this.id = PersistentConnection.nextPersistentConnectionId_++;
    this.log_ = logWrapper("p:" + this.id + ":");
    this.interruptReasons_ = {};
    this.listens = new Map;
    this.outstandingPuts_ = [];
    this.outstandingGets_ = [];
    this.outstandingPutCount_ = 0;
    this.outstandingGetCount_ = 0;
    this.onDisconnectRequestQueue_ = [];
    this.connected_ = false;
    this.reconnectDelay_ = RECONNECT_MIN_DELAY;
    this.maxReconnectDelay_ = RECONNECT_MAX_DELAY_DEFAULT;
    this.securityDebugCallback_ = null;
    this.lastSessionId = null;
    this.establishConnectionTimer_ = null;
    this.visible_ = false;
    this.requestCBHash_ = {};
    this.requestNumber_ = 0;
    this.realtime_ = null;
    this.authToken_ = null;
    this.appCheckToken_ = null;
    this.forceTokenRefresh_ = false;
    this.invalidAuthTokenCount_ = 0;
    this.invalidAppCheckTokenCount_ = 0;
    this.firstConnection_ = true;
    this.lastConnectionAttemptTime_ = null;
    this.lastConnectionEstablishedTime_ = null;
    if (authOverride_ && !isNodeSdk()) {
      throw new Error("Auth override specified in options, but not supported on non Node.js platforms");
    }
    VisibilityMonitor.getInstance().on("visible", this.onVisible_, this);
    if (repoInfo_.host.indexOf("fblocal") === -1) {
      OnlineMonitor.getInstance().on("online", this.onOnline_, this);
    }
  }
  sendRequest(action, body, onResponse) {
    const curReqNum = ++this.requestNumber_;
    const msg = { r: curReqNum, a: action, b: body };
    this.log_(stringify(msg));
    assert(this.connected_, "sendRequest call when we're not connected not allowed.");
    this.realtime_.sendRequest(msg);
    if (onResponse) {
      this.requestCBHash_[curReqNum] = onResponse;
    }
  }
  get(query) {
    this.initConnection_();
    const deferred = new Deferred;
    const request = {
      p: query._path.toString(),
      q: query._queryObject
    };
    const outstandingGet = {
      action: "g",
      request,
      onComplete: (message) => {
        const payload = message["d"];
        if (message["s"] === "ok") {
          deferred.resolve(payload);
        } else {
          deferred.reject(payload);
        }
      }
    };
    this.outstandingGets_.push(outstandingGet);
    this.outstandingGetCount_++;
    const index = this.outstandingGets_.length - 1;
    if (this.connected_) {
      this.sendGet_(index);
    }
    return deferred.promise;
  }
  listen(query, currentHashFn, tag, onComplete) {
    this.initConnection_();
    const queryId = query._queryIdentifier;
    const pathString = query._path.toString();
    this.log_("Listen called for " + pathString + " " + queryId);
    if (!this.listens.has(pathString)) {
      this.listens.set(pathString, new Map);
    }
    assert(query._queryParams.isDefault() || !query._queryParams.loadsAllData(), "listen() called for non-default but complete query");
    assert(!this.listens.get(pathString).has(queryId), `listen() called twice for same path/queryId.`);
    const listenSpec = {
      onComplete,
      hashFn: currentHashFn,
      query,
      tag
    };
    this.listens.get(pathString).set(queryId, listenSpec);
    if (this.connected_) {
      this.sendListen_(listenSpec);
    }
  }
  sendGet_(index) {
    const get2 = this.outstandingGets_[index];
    this.sendRequest("g", get2.request, (message) => {
      delete this.outstandingGets_[index];
      this.outstandingGetCount_--;
      if (this.outstandingGetCount_ === 0) {
        this.outstandingGets_ = [];
      }
      if (get2.onComplete) {
        get2.onComplete(message);
      }
    });
  }
  sendListen_(listenSpec) {
    const query = listenSpec.query;
    const pathString = query._path.toString();
    const queryId = query._queryIdentifier;
    this.log_("Listen on " + pathString + " for " + queryId);
    const req = { p: pathString };
    const action = "q";
    if (listenSpec.tag) {
      req["q"] = query._queryObject;
      req["t"] = listenSpec.tag;
    }
    req["h"] = listenSpec.hashFn();
    this.sendRequest(action, req, (message) => {
      const payload = message["d"];
      const status = message["s"];
      PersistentConnection.warnOnListenWarnings_(payload, query);
      const currentListenSpec = this.listens.get(pathString) && this.listens.get(pathString).get(queryId);
      if (currentListenSpec === listenSpec) {
        this.log_("listen response", message);
        if (status !== "ok") {
          this.removeListen_(pathString, queryId);
        }
        if (listenSpec.onComplete) {
          listenSpec.onComplete(status, payload);
        }
      }
    });
  }
  static warnOnListenWarnings_(payload, query) {
    if (payload && typeof payload === "object" && contains(payload, "w")) {
      const warnings = safeGet(payload, "w");
      if (Array.isArray(warnings) && ~warnings.indexOf("no_index")) {
        const indexSpec = '".indexOn": "' + query._queryParams.getIndex().toString() + '"';
        const indexPath = query._path.toString();
        warn(`Using an unspecified index. Your data will be downloaded and ` + `filtered on the client. Consider adding ${indexSpec} at ` + `${indexPath} to your security rules for better performance.`);
      }
    }
  }
  refreshAuthToken(token) {
    this.authToken_ = token;
    this.log_("Auth token refreshed");
    if (this.authToken_) {
      this.tryAuth();
    } else {
      if (this.connected_) {
        this.sendRequest("unauth", {}, () => {
        });
      }
    }
    this.reduceReconnectDelayIfAdminCredential_(token);
  }
  reduceReconnectDelayIfAdminCredential_(credential) {
    const isFirebaseSecret = credential && credential.length === 40;
    if (isFirebaseSecret || isAdmin(credential)) {
      this.log_("Admin auth credential detected.  Reducing max reconnect time.");
      this.maxReconnectDelay_ = RECONNECT_MAX_DELAY_FOR_ADMINS;
    }
  }
  refreshAppCheckToken(token) {
    this.appCheckToken_ = token;
    this.log_("App check token refreshed");
    if (this.appCheckToken_) {
      this.tryAppCheck();
    } else {
      if (this.connected_) {
        this.sendRequest("unappeck", {}, () => {
        });
      }
    }
  }
  tryAuth() {
    if (this.connected_ && this.authToken_) {
      const token = this.authToken_;
      const authMethod = isValidFormat(token) ? "auth" : "gauth";
      const requestData = { cred: token };
      if (this.authOverride_ === null) {
        requestData["noauth"] = true;
      } else if (typeof this.authOverride_ === "object") {
        requestData["authvar"] = this.authOverride_;
      }
      this.sendRequest(authMethod, requestData, (res) => {
        const status = res["s"];
        const data = res["d"] || "error";
        if (this.authToken_ === token) {
          if (status === "ok") {
            this.invalidAuthTokenCount_ = 0;
          } else {
            this.onAuthRevoked_(status, data);
          }
        }
      });
    }
  }
  tryAppCheck() {
    if (this.connected_ && this.appCheckToken_) {
      this.sendRequest("appcheck", { token: this.appCheckToken_ }, (res) => {
        const status = res["s"];
        const data = res["d"] || "error";
        if (status === "ok") {
          this.invalidAppCheckTokenCount_ = 0;
        } else {
          this.onAppCheckRevoked_(status, data);
        }
      });
    }
  }
  unlisten(query, tag) {
    const pathString = query._path.toString();
    const queryId = query._queryIdentifier;
    this.log_("Unlisten called for " + pathString + " " + queryId);
    assert(query._queryParams.isDefault() || !query._queryParams.loadsAllData(), "unlisten() called for non-default but complete query");
    const listen = this.removeListen_(pathString, queryId);
    if (listen && this.connected_) {
      this.sendUnlisten_(pathString, queryId, query._queryObject, tag);
    }
  }
  sendUnlisten_(pathString, queryId, queryObj, tag) {
    this.log_("Unlisten on " + pathString + " for " + queryId);
    const req = { p: pathString };
    const action = "n";
    if (tag) {
      req["q"] = queryObj;
      req["t"] = tag;
    }
    this.sendRequest(action, req);
  }
  onDisconnectPut(pathString, data, onComplete) {
    this.initConnection_();
    if (this.connected_) {
      this.sendOnDisconnect_("o", pathString, data, onComplete);
    } else {
      this.onDisconnectRequestQueue_.push({
        pathString,
        action: "o",
        data,
        onComplete
      });
    }
  }
  onDisconnectMerge(pathString, data, onComplete) {
    this.initConnection_();
    if (this.connected_) {
      this.sendOnDisconnect_("om", pathString, data, onComplete);
    } else {
      this.onDisconnectRequestQueue_.push({
        pathString,
        action: "om",
        data,
        onComplete
      });
    }
  }
  onDisconnectCancel(pathString, onComplete) {
    this.initConnection_();
    if (this.connected_) {
      this.sendOnDisconnect_("oc", pathString, null, onComplete);
    } else {
      this.onDisconnectRequestQueue_.push({
        pathString,
        action: "oc",
        data: null,
        onComplete
      });
    }
  }
  sendOnDisconnect_(action, pathString, data, onComplete) {
    const request = { p: pathString, d: data };
    this.log_("onDisconnect " + action, request);
    this.sendRequest(action, request, (response) => {
      if (onComplete) {
        setTimeout(() => {
          onComplete(response["s"], response["d"]);
        }, Math.floor(0));
      }
    });
  }
  put(pathString, data, onComplete, hash) {
    this.putInternal("p", pathString, data, onComplete, hash);
  }
  merge(pathString, data, onComplete, hash) {
    this.putInternal("m", pathString, data, onComplete, hash);
  }
  putInternal(action, pathString, data, onComplete, hash) {
    this.initConnection_();
    const request = {
      p: pathString,
      d: data
    };
    if (hash !== undefined) {
      request["h"] = hash;
    }
    this.outstandingPuts_.push({
      action,
      request,
      onComplete
    });
    this.outstandingPutCount_++;
    const index = this.outstandingPuts_.length - 1;
    if (this.connected_) {
      this.sendPut_(index);
    } else {
      this.log_("Buffering put: " + pathString);
    }
  }
  sendPut_(index) {
    const action = this.outstandingPuts_[index].action;
    const request = this.outstandingPuts_[index].request;
    const onComplete = this.outstandingPuts_[index].onComplete;
    this.outstandingPuts_[index].queued = this.connected_;
    this.sendRequest(action, request, (message) => {
      this.log_(action + " response", message);
      delete this.outstandingPuts_[index];
      this.outstandingPutCount_--;
      if (this.outstandingPutCount_ === 0) {
        this.outstandingPuts_ = [];
      }
      if (onComplete) {
        onComplete(message["s"], message["d"]);
      }
    });
  }
  reportStats(stats) {
    if (this.connected_) {
      const request = { c: stats };
      this.log_("reportStats", request);
      this.sendRequest("s", request, (result) => {
        const status = result["s"];
        if (status !== "ok") {
          const errorReason = result["d"];
          this.log_("reportStats", "Error sending stats: " + errorReason);
        }
      });
    }
  }
  onDataMessage_(message) {
    if ("r" in message) {
      this.log_("from server: " + stringify(message));
      const reqNum = message["r"];
      const onResponse = this.requestCBHash_[reqNum];
      if (onResponse) {
        delete this.requestCBHash_[reqNum];
        onResponse(message["b"]);
      }
    } else if ("error" in message) {
      throw "A server-side error has occurred: " + message["error"];
    } else if ("a" in message) {
      this.onDataPush_(message["a"], message["b"]);
    }
  }
  onDataPush_(action, body) {
    this.log_("handleServerMessage", action, body);
    if (action === "d") {
      this.onDataUpdate_(body["p"], body["d"], false, body["t"]);
    } else if (action === "m") {
      this.onDataUpdate_(body["p"], body["d"], true, body["t"]);
    } else if (action === "c") {
      this.onListenRevoked_(body["p"], body["q"]);
    } else if (action === "ac") {
      this.onAuthRevoked_(body["s"], body["d"]);
    } else if (action === "apc") {
      this.onAppCheckRevoked_(body["s"], body["d"]);
    } else if (action === "sd") {
      this.onSecurityDebugPacket_(body);
    } else {
      error("Unrecognized action received from server: " + stringify(action) + "\nAre you using the latest client?");
    }
  }
  onReady_(timestamp, sessionId) {
    this.log_("connection ready");
    this.connected_ = true;
    this.lastConnectionEstablishedTime_ = new Date().getTime();
    this.handleTimestamp_(timestamp);
    this.lastSessionId = sessionId;
    if (this.firstConnection_) {
      this.sendConnectStats_();
    }
    this.restoreState_();
    this.firstConnection_ = false;
    this.onConnectStatus_(true);
  }
  scheduleConnect_(timeout) {
    assert(!this.realtime_, "Scheduling a connect when we're already connected/ing?");
    if (this.establishConnectionTimer_) {
      clearTimeout(this.establishConnectionTimer_);
    }
    this.establishConnectionTimer_ = setTimeout(() => {
      this.establishConnectionTimer_ = null;
      this.establishConnection_();
    }, Math.floor(timeout));
  }
  initConnection_() {
    if (!this.realtime_ && this.firstConnection_) {
      this.scheduleConnect_(0);
    }
  }
  onVisible_(visible) {
    if (visible && !this.visible_ && this.reconnectDelay_ === this.maxReconnectDelay_) {
      this.log_("Window became visible.  Reducing delay.");
      this.reconnectDelay_ = RECONNECT_MIN_DELAY;
      if (!this.realtime_) {
        this.scheduleConnect_(0);
      }
    }
    this.visible_ = visible;
  }
  onOnline_(online) {
    if (online) {
      this.log_("Browser went online.");
      this.reconnectDelay_ = RECONNECT_MIN_DELAY;
      if (!this.realtime_) {
        this.scheduleConnect_(0);
      }
    } else {
      this.log_("Browser went offline.  Killing connection.");
      if (this.realtime_) {
        this.realtime_.close();
      }
    }
  }
  onRealtimeDisconnect_() {
    this.log_("data client disconnected");
    this.connected_ = false;
    this.realtime_ = null;
    this.cancelSentTransactions_();
    this.requestCBHash_ = {};
    if (this.shouldReconnect_()) {
      if (!this.visible_) {
        this.log_("Window isn't visible.  Delaying reconnect.");
        this.reconnectDelay_ = this.maxReconnectDelay_;
        this.lastConnectionAttemptTime_ = new Date().getTime();
      } else if (this.lastConnectionEstablishedTime_) {
        const timeSinceLastConnectSucceeded = new Date().getTime() - this.lastConnectionEstablishedTime_;
        if (timeSinceLastConnectSucceeded > RECONNECT_DELAY_RESET_TIMEOUT) {
          this.reconnectDelay_ = RECONNECT_MIN_DELAY;
        }
        this.lastConnectionEstablishedTime_ = null;
      }
      const timeSinceLastConnectAttempt = new Date().getTime() - this.lastConnectionAttemptTime_;
      let reconnectDelay = Math.max(0, this.reconnectDelay_ - timeSinceLastConnectAttempt);
      reconnectDelay = Math.random() * reconnectDelay;
      this.log_("Trying to reconnect in " + reconnectDelay + "ms");
      this.scheduleConnect_(reconnectDelay);
      this.reconnectDelay_ = Math.min(this.maxReconnectDelay_, this.reconnectDelay_ * RECONNECT_DELAY_MULTIPLIER);
    }
    this.onConnectStatus_(false);
  }
  async establishConnection_() {
    if (this.shouldReconnect_()) {
      this.log_("Making a connection attempt");
      this.lastConnectionAttemptTime_ = new Date().getTime();
      this.lastConnectionEstablishedTime_ = null;
      const onDataMessage = this.onDataMessage_.bind(this);
      const onReady = this.onReady_.bind(this);
      const onDisconnect = this.onRealtimeDisconnect_.bind(this);
      const connId = this.id + ":" + PersistentConnection.nextConnectionId_++;
      const lastSessionId = this.lastSessionId;
      let canceled = false;
      let connection = null;
      const closeFn = function() {
        if (connection) {
          connection.close();
        } else {
          canceled = true;
          onDisconnect();
        }
      };
      const sendRequestFn = function(msg) {
        assert(connection, "sendRequest call when we're not connected not allowed.");
        connection.sendRequest(msg);
      };
      this.realtime_ = {
        close: closeFn,
        sendRequest: sendRequestFn
      };
      const forceRefresh = this.forceTokenRefresh_;
      this.forceTokenRefresh_ = false;
      try {
        const [authToken, appCheckToken] = await Promise.all([
          this.authTokenProvider_.getToken(forceRefresh),
          this.appCheckTokenProvider_.getToken(forceRefresh)
        ]);
        if (!canceled) {
          log2("getToken() completed. Creating connection.");
          this.authToken_ = authToken && authToken.accessToken;
          this.appCheckToken_ = appCheckToken && appCheckToken.token;
          connection = new Connection(connId, this.repoInfo_, this.applicationId_, this.appCheckToken_, this.authToken_, onDataMessage, onReady, onDisconnect, (reason) => {
            warn(reason + " (" + this.repoInfo_.toString() + ")");
            this.interrupt(SERVER_KILL_INTERRUPT_REASON);
          }, lastSessionId);
        } else {
          log2("getToken() completed but was canceled");
        }
      } catch (error2) {
        this.log_("Failed to get token: " + error2);
        if (!canceled) {
          if (this.repoInfo_.nodeAdmin) {
            warn(error2);
          }
          closeFn();
        }
      }
    }
  }
  interrupt(reason) {
    log2("Interrupting connection for reason: " + reason);
    this.interruptReasons_[reason] = true;
    if (this.realtime_) {
      this.realtime_.close();
    } else {
      if (this.establishConnectionTimer_) {
        clearTimeout(this.establishConnectionTimer_);
        this.establishConnectionTimer_ = null;
      }
      if (this.connected_) {
        this.onRealtimeDisconnect_();
      }
    }
  }
  resume(reason) {
    log2("Resuming connection for reason: " + reason);
    delete this.interruptReasons_[reason];
    if (isEmpty(this.interruptReasons_)) {
      this.reconnectDelay_ = RECONNECT_MIN_DELAY;
      if (!this.realtime_) {
        this.scheduleConnect_(0);
      }
    }
  }
  handleTimestamp_(timestamp) {
    const delta = timestamp - new Date().getTime();
    this.onServerInfoUpdate_({ serverTimeOffset: delta });
  }
  cancelSentTransactions_() {
    for (let i = 0;i < this.outstandingPuts_.length; i++) {
      const put = this.outstandingPuts_[i];
      if (put && ("h" in put.request) && put.queued) {
        if (put.onComplete) {
          put.onComplete("disconnect");
        }
        delete this.outstandingPuts_[i];
        this.outstandingPutCount_--;
      }
    }
    if (this.outstandingPutCount_ === 0) {
      this.outstandingPuts_ = [];
    }
  }
  onListenRevoked_(pathString, query) {
    let queryId;
    if (!query) {
      queryId = "default";
    } else {
      queryId = query.map((q) => ObjectToUniqueKey(q)).join("$");
    }
    const listen = this.removeListen_(pathString, queryId);
    if (listen && listen.onComplete) {
      listen.onComplete("permission_denied");
    }
  }
  removeListen_(pathString, queryId) {
    const normalizedPathString = new Path3(pathString).toString();
    let listen;
    if (this.listens.has(normalizedPathString)) {
      const map2 = this.listens.get(normalizedPathString);
      listen = map2.get(queryId);
      map2.delete(queryId);
      if (map2.size === 0) {
        this.listens.delete(normalizedPathString);
      }
    } else {
      listen = undefined;
    }
    return listen;
  }
  onAuthRevoked_(statusCode, explanation) {
    log2("Auth token revoked: " + statusCode + "/" + explanation);
    this.authToken_ = null;
    this.forceTokenRefresh_ = true;
    this.realtime_.close();
    if (statusCode === "invalid_token" || statusCode === "permission_denied") {
      this.invalidAuthTokenCount_++;
      if (this.invalidAuthTokenCount_ >= INVALID_TOKEN_THRESHOLD) {
        this.reconnectDelay_ = RECONNECT_MAX_DELAY_FOR_ADMINS;
        this.authTokenProvider_.notifyForInvalidToken();
      }
    }
  }
  onAppCheckRevoked_(statusCode, explanation) {
    log2("App check token revoked: " + statusCode + "/" + explanation);
    this.appCheckToken_ = null;
    this.forceTokenRefresh_ = true;
    if (statusCode === "invalid_token" || statusCode === "permission_denied") {
      this.invalidAppCheckTokenCount_++;
      if (this.invalidAppCheckTokenCount_ >= INVALID_TOKEN_THRESHOLD) {
        this.appCheckTokenProvider_.notifyForInvalidToken();
      }
    }
  }
  onSecurityDebugPacket_(body) {
    if (this.securityDebugCallback_) {
      this.securityDebugCallback_(body);
    } else {
      if ("msg" in body) {
        console.log("FIREBASE: " + body["msg"].replace("\n", "\nFIREBASE: "));
      }
    }
  }
  restoreState_() {
    this.tryAuth();
    this.tryAppCheck();
    for (const queries of this.listens.values()) {
      for (const listenSpec of queries.values()) {
        this.sendListen_(listenSpec);
      }
    }
    for (let i = 0;i < this.outstandingPuts_.length; i++) {
      if (this.outstandingPuts_[i]) {
        this.sendPut_(i);
      }
    }
    while (this.onDisconnectRequestQueue_.length) {
      const request = this.onDisconnectRequestQueue_.shift();
      this.sendOnDisconnect_(request.action, request.pathString, request.data, request.onComplete);
    }
    for (let i = 0;i < this.outstandingGets_.length; i++) {
      if (this.outstandingGets_[i]) {
        this.sendGet_(i);
      }
    }
  }
  sendConnectStats_() {
    const stats = {};
    let clientName = "js";
    if (isNodeSdk()) {
      if (this.repoInfo_.nodeAdmin) {
        clientName = "admin_node";
      } else {
        clientName = "node";
      }
    }
    stats["sdk." + clientName + "." + SDK_VERSION2.replace(/\./g, "-")] = 1;
    if (isMobileCordova()) {
      stats["framework.cordova"] = 1;
    } else if (isReactNative()) {
      stats["framework.reactnative"] = 1;
    }
    this.reportStats(stats);
  }
  shouldReconnect_() {
    const online = OnlineMonitor.getInstance().currentlyOnline();
    return isEmpty(this.interruptReasons_) && online;
  }
}
PersistentConnection.nextPersistentConnectionId_ = 0;
PersistentConnection.nextConnectionId_ = 0;

class NamedNode {
  constructor(name3, node) {
    this.name = name3;
    this.node = node;
  }
  static Wrap(name3, node) {
    return new NamedNode(name3, node);
  }
}

class Index {
  getCompare() {
    return this.compare.bind(this);
  }
  indexedValueChanged(oldNode, newNode) {
    const oldWrapped = new NamedNode(MIN_NAME, oldNode);
    const newWrapped = new NamedNode(MIN_NAME, newNode);
    return this.compare(oldWrapped, newWrapped) !== 0;
  }
  minPost() {
    return NamedNode.MIN;
  }
}
var __EMPTY_NODE;

class KeyIndex extends Index {
  static get __EMPTY_NODE() {
    return __EMPTY_NODE;
  }
  static set __EMPTY_NODE(val) {
    __EMPTY_NODE = val;
  }
  compare(a, b) {
    return nameCompare(a.name, b.name);
  }
  isDefinedOn(node) {
    throw assertionError("KeyIndex.isDefinedOn not expected to be called.");
  }
  indexedValueChanged(oldNode, newNode) {
    return false;
  }
  minPost() {
    return NamedNode.MIN;
  }
  maxPost() {
    return new NamedNode(MAX_NAME, __EMPTY_NODE);
  }
  makePost(indexValue, name3) {
    assert(typeof indexValue === "string", "KeyIndex indexValue must always be a string.");
    return new NamedNode(indexValue, __EMPTY_NODE);
  }
  toString() {
    return ".key";
  }
}
var KEY_INDEX = new KeyIndex;

class SortedMapIterator {
  constructor(node, startKey, comparator, isReverse_, resultGenerator_ = null) {
    this.isReverse_ = isReverse_;
    this.resultGenerator_ = resultGenerator_;
    this.nodeStack_ = [];
    let cmp = 1;
    while (!node.isEmpty()) {
      node = node;
      cmp = startKey ? comparator(node.key, startKey) : 1;
      if (isReverse_) {
        cmp *= -1;
      }
      if (cmp < 0) {
        if (this.isReverse_) {
          node = node.left;
        } else {
          node = node.right;
        }
      } else if (cmp === 0) {
        this.nodeStack_.push(node);
        break;
      } else {
        this.nodeStack_.push(node);
        if (this.isReverse_) {
          node = node.right;
        } else {
          node = node.left;
        }
      }
    }
  }
  getNext() {
    if (this.nodeStack_.length === 0) {
      return null;
    }
    let node = this.nodeStack_.pop();
    let result;
    if (this.resultGenerator_) {
      result = this.resultGenerator_(node.key, node.value);
    } else {
      result = { key: node.key, value: node.value };
    }
    if (this.isReverse_) {
      node = node.left;
      while (!node.isEmpty()) {
        this.nodeStack_.push(node);
        node = node.right;
      }
    } else {
      node = node.right;
      while (!node.isEmpty()) {
        this.nodeStack_.push(node);
        node = node.left;
      }
    }
    return result;
  }
  hasNext() {
    return this.nodeStack_.length > 0;
  }
  peek() {
    if (this.nodeStack_.length === 0) {
      return null;
    }
    const node = this.nodeStack_[this.nodeStack_.length - 1];
    if (this.resultGenerator_) {
      return this.resultGenerator_(node.key, node.value);
    } else {
      return { key: node.key, value: node.value };
    }
  }
}

class LLRBNode {
  constructor(key, value, color, left, right) {
    this.key = key;
    this.value = value;
    this.color = color != null ? color : LLRBNode.RED;
    this.left = left != null ? left : SortedMap.EMPTY_NODE;
    this.right = right != null ? right : SortedMap.EMPTY_NODE;
  }
  copy(key, value, color, left, right) {
    return new LLRBNode(key != null ? key : this.key, value != null ? value : this.value, color != null ? color : this.color, left != null ? left : this.left, right != null ? right : this.right);
  }
  count() {
    return this.left.count() + 1 + this.right.count();
  }
  isEmpty() {
    return false;
  }
  inorderTraversal(action) {
    return this.left.inorderTraversal(action) || !!action(this.key, this.value) || this.right.inorderTraversal(action);
  }
  reverseTraversal(action) {
    return this.right.reverseTraversal(action) || action(this.key, this.value) || this.left.reverseTraversal(action);
  }
  min_() {
    if (this.left.isEmpty()) {
      return this;
    } else {
      return this.left.min_();
    }
  }
  minKey() {
    return this.min_().key;
  }
  maxKey() {
    if (this.right.isEmpty()) {
      return this.key;
    } else {
      return this.right.maxKey();
    }
  }
  insert(key, value, comparator) {
    let n = this;
    const cmp = comparator(key, n.key);
    if (cmp < 0) {
      n = n.copy(null, null, null, n.left.insert(key, value, comparator), null);
    } else if (cmp === 0) {
      n = n.copy(null, value, null, null, null);
    } else {
      n = n.copy(null, null, null, null, n.right.insert(key, value, comparator));
    }
    return n.fixUp_();
  }
  removeMin_() {
    if (this.left.isEmpty()) {
      return SortedMap.EMPTY_NODE;
    }
    let n = this;
    if (!n.left.isRed_() && !n.left.left.isRed_()) {
      n = n.moveRedLeft_();
    }
    n = n.copy(null, null, null, n.left.removeMin_(), null);
    return n.fixUp_();
  }
  remove(key, comparator) {
    let n, smallest;
    n = this;
    if (comparator(key, n.key) < 0) {
      if (!n.left.isEmpty() && !n.left.isRed_() && !n.left.left.isRed_()) {
        n = n.moveRedLeft_();
      }
      n = n.copy(null, null, null, n.left.remove(key, comparator), null);
    } else {
      if (n.left.isRed_()) {
        n = n.rotateRight_();
      }
      if (!n.right.isEmpty() && !n.right.isRed_() && !n.right.left.isRed_()) {
        n = n.moveRedRight_();
      }
      if (comparator(key, n.key) === 0) {
        if (n.right.isEmpty()) {
          return SortedMap.EMPTY_NODE;
        } else {
          smallest = n.right.min_();
          n = n.copy(smallest.key, smallest.value, null, null, n.right.removeMin_());
        }
      }
      n = n.copy(null, null, null, null, n.right.remove(key, comparator));
    }
    return n.fixUp_();
  }
  isRed_() {
    return this.color;
  }
  fixUp_() {
    let n = this;
    if (n.right.isRed_() && !n.left.isRed_()) {
      n = n.rotateLeft_();
    }
    if (n.left.isRed_() && n.left.left.isRed_()) {
      n = n.rotateRight_();
    }
    if (n.left.isRed_() && n.right.isRed_()) {
      n = n.colorFlip_();
    }
    return n;
  }
  moveRedLeft_() {
    let n = this.colorFlip_();
    if (n.right.left.isRed_()) {
      n = n.copy(null, null, null, null, n.right.rotateRight_());
      n = n.rotateLeft_();
      n = n.colorFlip_();
    }
    return n;
  }
  moveRedRight_() {
    let n = this.colorFlip_();
    if (n.left.left.isRed_()) {
      n = n.rotateRight_();
      n = n.colorFlip_();
    }
    return n;
  }
  rotateLeft_() {
    const nl = this.copy(null, null, LLRBNode.RED, null, this.right.left);
    return this.right.copy(null, null, this.color, nl, null);
  }
  rotateRight_() {
    const nr = this.copy(null, null, LLRBNode.RED, this.left.right, null);
    return this.left.copy(null, null, this.color, null, nr);
  }
  colorFlip_() {
    const left = this.left.copy(null, null, !this.left.color, null, null);
    const right = this.right.copy(null, null, !this.right.color, null, null);
    return this.copy(null, null, !this.color, left, right);
  }
  checkMaxDepth_() {
    const blackDepth = this.check_();
    return Math.pow(2, blackDepth) <= this.count() + 1;
  }
  check_() {
    if (this.isRed_() && this.left.isRed_()) {
      throw new Error("Red node has red child(" + this.key + "," + this.value + ")");
    }
    if (this.right.isRed_()) {
      throw new Error("Right child of (" + this.key + "," + this.value + ") is red");
    }
    const blackDepth = this.left.check_();
    if (blackDepth !== this.right.check_()) {
      throw new Error("Black depths differ");
    } else {
      return blackDepth + (this.isRed_() ? 0 : 1);
    }
  }
}
LLRBNode.RED = true;
LLRBNode.BLACK = false;

class LLRBEmptyNode {
  copy(key, value, color, left, right) {
    return this;
  }
  insert(key, value, comparator) {
    return new LLRBNode(key, value, null);
  }
  remove(key, comparator) {
    return this;
  }
  count() {
    return 0;
  }
  isEmpty() {
    return true;
  }
  inorderTraversal(action) {
    return false;
  }
  reverseTraversal(action) {
    return false;
  }
  minKey() {
    return null;
  }
  maxKey() {
    return null;
  }
  check_() {
    return 0;
  }
  isRed_() {
    return false;
  }
}

class SortedMap {
  constructor(comparator_, root_ = SortedMap.EMPTY_NODE) {
    this.comparator_ = comparator_;
    this.root_ = root_;
  }
  insert(key, value) {
    return new SortedMap(this.comparator_, this.root_.insert(key, value, this.comparator_).copy(null, null, LLRBNode.BLACK, null, null));
  }
  remove(key) {
    return new SortedMap(this.comparator_, this.root_.remove(key, this.comparator_).copy(null, null, LLRBNode.BLACK, null, null));
  }
  get(key) {
    let cmp;
    let node = this.root_;
    while (!node.isEmpty()) {
      cmp = this.comparator_(key, node.key);
      if (cmp === 0) {
        return node.value;
      } else if (cmp < 0) {
        node = node.left;
      } else if (cmp > 0) {
        node = node.right;
      }
    }
    return null;
  }
  getPredecessorKey(key) {
    let cmp, node = this.root_, rightParent = null;
    while (!node.isEmpty()) {
      cmp = this.comparator_(key, node.key);
      if (cmp === 0) {
        if (!node.left.isEmpty()) {
          node = node.left;
          while (!node.right.isEmpty()) {
            node = node.right;
          }
          return node.key;
        } else if (rightParent) {
          return rightParent.key;
        } else {
          return null;
        }
      } else if (cmp < 0) {
        node = node.left;
      } else if (cmp > 0) {
        rightParent = node;
        node = node.right;
      }
    }
    throw new Error("Attempted to find predecessor key for a nonexistent key.  What gives?");
  }
  isEmpty() {
    return this.root_.isEmpty();
  }
  count() {
    return this.root_.count();
  }
  minKey() {
    return this.root_.minKey();
  }
  maxKey() {
    return this.root_.maxKey();
  }
  inorderTraversal(action) {
    return this.root_.inorderTraversal(action);
  }
  reverseTraversal(action) {
    return this.root_.reverseTraversal(action);
  }
  getIterator(resultGenerator) {
    return new SortedMapIterator(this.root_, null, this.comparator_, false, resultGenerator);
  }
  getIteratorFrom(key, resultGenerator) {
    return new SortedMapIterator(this.root_, key, this.comparator_, false, resultGenerator);
  }
  getReverseIteratorFrom(key, resultGenerator) {
    return new SortedMapIterator(this.root_, key, this.comparator_, true, resultGenerator);
  }
  getReverseIterator(resultGenerator) {
    return new SortedMapIterator(this.root_, null, this.comparator_, true, resultGenerator);
  }
}
SortedMap.EMPTY_NODE = new LLRBEmptyNode;
var MAX_NODE$2;
var priorityHashText = function(priority) {
  if (typeof priority === "number") {
    return "number:" + doubleToIEEE754String(priority);
  } else {
    return "string:" + priority;
  }
};
var validatePriorityNode = function(priorityNode) {
  if (priorityNode.isLeafNode()) {
    const val = priorityNode.val();
    assert(typeof val === "string" || typeof val === "number" || typeof val === "object" && contains(val, ".sv"), "Priority must be a string or number.");
  } else {
    assert(priorityNode === MAX_NODE$2 || priorityNode.isEmpty(), "priority of unexpected type.");
  }
  assert(priorityNode === MAX_NODE$2 || priorityNode.getPriority().isEmpty(), "Priority nodes can't have a priority of their own.");
};
var __childrenNodeConstructor;

class LeafNode {
  constructor(value_, priorityNode_ = LeafNode.__childrenNodeConstructor.EMPTY_NODE) {
    this.value_ = value_;
    this.priorityNode_ = priorityNode_;
    this.lazyHash_ = null;
    assert(this.value_ !== undefined && this.value_ !== null, "LeafNode shouldn't be created with null/undefined value.");
    validatePriorityNode(this.priorityNode_);
  }
  static set __childrenNodeConstructor(val) {
    __childrenNodeConstructor = val;
  }
  static get __childrenNodeConstructor() {
    return __childrenNodeConstructor;
  }
  isLeafNode() {
    return true;
  }
  getPriority() {
    return this.priorityNode_;
  }
  updatePriority(newPriorityNode) {
    return new LeafNode(this.value_, newPriorityNode);
  }
  getImmediateChild(childName) {
    if (childName === ".priority") {
      return this.priorityNode_;
    } else {
      return LeafNode.__childrenNodeConstructor.EMPTY_NODE;
    }
  }
  getChild(path5) {
    if (pathIsEmpty(path5)) {
      return this;
    } else if (pathGetFront(path5) === ".priority") {
      return this.priorityNode_;
    } else {
      return LeafNode.__childrenNodeConstructor.EMPTY_NODE;
    }
  }
  hasChild() {
    return false;
  }
  getPredecessorChildName(childName, childNode) {
    return null;
  }
  updateImmediateChild(childName, newChildNode) {
    if (childName === ".priority") {
      return this.updatePriority(newChildNode);
    } else if (newChildNode.isEmpty() && childName !== ".priority") {
      return this;
    } else {
      return LeafNode.__childrenNodeConstructor.EMPTY_NODE.updateImmediateChild(childName, newChildNode).updatePriority(this.priorityNode_);
    }
  }
  updateChild(path5, newChildNode) {
    const front = pathGetFront(path5);
    if (front === null) {
      return newChildNode;
    } else if (newChildNode.isEmpty() && front !== ".priority") {
      return this;
    } else {
      assert(front !== ".priority" || pathGetLength(path5) === 1, ".priority must be the last token in a path");
      return this.updateImmediateChild(front, LeafNode.__childrenNodeConstructor.EMPTY_NODE.updateChild(pathPopFront(path5), newChildNode));
    }
  }
  isEmpty() {
    return false;
  }
  numChildren() {
    return 0;
  }
  forEachChild(index, action) {
    return false;
  }
  val(exportFormat) {
    if (exportFormat && !this.getPriority().isEmpty()) {
      return {
        ".value": this.getValue(),
        ".priority": this.getPriority().val()
      };
    } else {
      return this.getValue();
    }
  }
  hash() {
    if (this.lazyHash_ === null) {
      let toHash = "";
      if (!this.priorityNode_.isEmpty()) {
        toHash += "priority:" + priorityHashText(this.priorityNode_.val()) + ":";
      }
      const type = typeof this.value_;
      toHash += type + ":";
      if (type === "number") {
        toHash += doubleToIEEE754String(this.value_);
      } else {
        toHash += this.value_;
      }
      this.lazyHash_ = sha1(toHash);
    }
    return this.lazyHash_;
  }
  getValue() {
    return this.value_;
  }
  compareTo(other) {
    if (other === LeafNode.__childrenNodeConstructor.EMPTY_NODE) {
      return 1;
    } else if (other instanceof LeafNode.__childrenNodeConstructor) {
      return -1;
    } else {
      assert(other.isLeafNode(), "Unknown node type");
      return this.compareToLeafNode_(other);
    }
  }
  compareToLeafNode_(otherLeaf) {
    const otherLeafType = typeof otherLeaf.value_;
    const thisLeafType = typeof this.value_;
    const otherIndex = LeafNode.VALUE_TYPE_ORDER.indexOf(otherLeafType);
    const thisIndex = LeafNode.VALUE_TYPE_ORDER.indexOf(thisLeafType);
    assert(otherIndex >= 0, "Unknown leaf type: " + otherLeafType);
    assert(thisIndex >= 0, "Unknown leaf type: " + thisLeafType);
    if (otherIndex === thisIndex) {
      if (thisLeafType === "object") {
        return 0;
      } else {
        if (this.value_ < otherLeaf.value_) {
          return -1;
        } else if (this.value_ === otherLeaf.value_) {
          return 0;
        } else {
          return 1;
        }
      }
    } else {
      return thisIndex - otherIndex;
    }
  }
  withIndex() {
    return this;
  }
  isIndexed() {
    return true;
  }
  equals(other) {
    if (other === this) {
      return true;
    } else if (other.isLeafNode()) {
      const otherLeaf = other;
      return this.value_ === otherLeaf.value_ && this.priorityNode_.equals(otherLeaf.priorityNode_);
    } else {
      return false;
    }
  }
}
LeafNode.VALUE_TYPE_ORDER = ["object", "boolean", "number", "string"];
var nodeFromJSON$1;
var MAX_NODE$1;

class PriorityIndex extends Index {
  compare(a, b) {
    const aPriority = a.node.getPriority();
    const bPriority = b.node.getPriority();
    const indexCmp = aPriority.compareTo(bPriority);
    if (indexCmp === 0) {
      return nameCompare(a.name, b.name);
    } else {
      return indexCmp;
    }
  }
  isDefinedOn(node) {
    return !node.getPriority().isEmpty();
  }
  indexedValueChanged(oldNode, newNode) {
    return !oldNode.getPriority().equals(newNode.getPriority());
  }
  minPost() {
    return NamedNode.MIN;
  }
  maxPost() {
    return new NamedNode(MAX_NAME, new LeafNode("[PRIORITY-POST]", MAX_NODE$1));
  }
  makePost(indexValue, name3) {
    const priorityNode = nodeFromJSON$1(indexValue);
    return new NamedNode(name3, new LeafNode("[PRIORITY-POST]", priorityNode));
  }
  toString() {
    return ".priority";
  }
}
var PRIORITY_INDEX = new PriorityIndex;
var LOG_2 = Math.log(2);

class Base12Num {
  constructor(length) {
    const logBase2 = (num) => parseInt(Math.log(num) / LOG_2, 10);
    const bitMask = (bits) => parseInt(Array(bits + 1).join("1"), 2);
    this.count = logBase2(length + 1);
    this.current_ = this.count - 1;
    const mask = bitMask(this.count);
    this.bits_ = length + 1 & mask;
  }
  nextBitIsOne() {
    const result = !(this.bits_ & 1 << this.current_);
    this.current_--;
    return result;
  }
}
var buildChildSet = function(childList, cmp, keyFn, mapSortFn) {
  childList.sort(cmp);
  const buildBalancedTree = function(low, high) {
    const length = high - low;
    let namedNode;
    let key;
    if (length === 0) {
      return null;
    } else if (length === 1) {
      namedNode = childList[low];
      key = keyFn ? keyFn(namedNode) : namedNode;
      return new LLRBNode(key, namedNode.node, LLRBNode.BLACK, null, null);
    } else {
      const middle = parseInt(length / 2, 10) + low;
      const left = buildBalancedTree(low, middle);
      const right = buildBalancedTree(middle + 1, high);
      namedNode = childList[middle];
      key = keyFn ? keyFn(namedNode) : namedNode;
      return new LLRBNode(key, namedNode.node, LLRBNode.BLACK, left, right);
    }
  };
  const buildFrom12Array = function(base122) {
    let node = null;
    let root2 = null;
    let index = childList.length;
    const buildPennant = function(chunkSize, color) {
      const low = index - chunkSize;
      const high = index;
      index -= chunkSize;
      const childTree = buildBalancedTree(low + 1, high);
      const namedNode = childList[low];
      const key = keyFn ? keyFn(namedNode) : namedNode;
      attachPennant(new LLRBNode(key, namedNode.node, color, null, childTree));
    };
    const attachPennant = function(pennant) {
      if (node) {
        node.left = pennant;
        node = pennant;
      } else {
        root2 = pennant;
        node = pennant;
      }
    };
    for (let i = 0;i < base122.count; ++i) {
      const isOne = base122.nextBitIsOne();
      const chunkSize = Math.pow(2, base122.count - (i + 1));
      if (isOne) {
        buildPennant(chunkSize, LLRBNode.BLACK);
      } else {
        buildPennant(chunkSize, LLRBNode.BLACK);
        buildPennant(chunkSize, LLRBNode.RED);
      }
    }
    return root2;
  };
  const base12 = new Base12Num(childList.length);
  const root = buildFrom12Array(base12);
  return new SortedMap(mapSortFn || cmp, root);
};
var _defaultIndexMap;
var fallbackObject = {};

class IndexMap {
  constructor(indexes_, indexSet_) {
    this.indexes_ = indexes_;
    this.indexSet_ = indexSet_;
  }
  static get Default() {
    assert(fallbackObject && PRIORITY_INDEX, "ChildrenNode.ts has not been loaded");
    _defaultIndexMap = _defaultIndexMap || new IndexMap({ ".priority": fallbackObject }, { ".priority": PRIORITY_INDEX });
    return _defaultIndexMap;
  }
  get(indexKey) {
    const sortedMap = safeGet(this.indexes_, indexKey);
    if (!sortedMap) {
      throw new Error("No index defined for " + indexKey);
    }
    if (sortedMap instanceof SortedMap) {
      return sortedMap;
    } else {
      return null;
    }
  }
  hasIndex(indexDefinition) {
    return contains(this.indexSet_, indexDefinition.toString());
  }
  addIndex(indexDefinition, existingChildren) {
    assert(indexDefinition !== KEY_INDEX, "KeyIndex always exists and isn't meant to be added to the IndexMap.");
    const childList = [];
    let sawIndexedValue = false;
    const iter = existingChildren.getIterator(NamedNode.Wrap);
    let next = iter.getNext();
    while (next) {
      sawIndexedValue = sawIndexedValue || indexDefinition.isDefinedOn(next.node);
      childList.push(next);
      next = iter.getNext();
    }
    let newIndex;
    if (sawIndexedValue) {
      newIndex = buildChildSet(childList, indexDefinition.getCompare());
    } else {
      newIndex = fallbackObject;
    }
    const indexName = indexDefinition.toString();
    const newIndexSet = Object.assign({}, this.indexSet_);
    newIndexSet[indexName] = indexDefinition;
    const newIndexes = Object.assign({}, this.indexes_);
    newIndexes[indexName] = newIndex;
    return new IndexMap(newIndexes, newIndexSet);
  }
  addToIndexes(namedNode, existingChildren) {
    const newIndexes = map(this.indexes_, (indexedChildren, indexName) => {
      const index = safeGet(this.indexSet_, indexName);
      assert(index, "Missing index implementation for " + indexName);
      if (indexedChildren === fallbackObject) {
        if (index.isDefinedOn(namedNode.node)) {
          const childList = [];
          const iter = existingChildren.getIterator(NamedNode.Wrap);
          let next = iter.getNext();
          while (next) {
            if (next.name !== namedNode.name) {
              childList.push(next);
            }
            next = iter.getNext();
          }
          childList.push(namedNode);
          return buildChildSet(childList, index.getCompare());
        } else {
          return fallbackObject;
        }
      } else {
        const existingSnap = existingChildren.get(namedNode.name);
        let newChildren = indexedChildren;
        if (existingSnap) {
          newChildren = newChildren.remove(new NamedNode(namedNode.name, existingSnap));
        }
        return newChildren.insert(namedNode, namedNode.node);
      }
    });
    return new IndexMap(newIndexes, this.indexSet_);
  }
  removeFromIndexes(namedNode, existingChildren) {
    const newIndexes = map(this.indexes_, (indexedChildren) => {
      if (indexedChildren === fallbackObject) {
        return indexedChildren;
      } else {
        const existingSnap = existingChildren.get(namedNode.name);
        if (existingSnap) {
          return indexedChildren.remove(new NamedNode(namedNode.name, existingSnap));
        } else {
          return indexedChildren;
        }
      }
    });
    return new IndexMap(newIndexes, this.indexSet_);
  }
}
var EMPTY_NODE;

class ChildrenNode {
  constructor(children_, priorityNode_, indexMap_) {
    this.children_ = children_;
    this.priorityNode_ = priorityNode_;
    this.indexMap_ = indexMap_;
    this.lazyHash_ = null;
    if (this.priorityNode_) {
      validatePriorityNode(this.priorityNode_);
    }
    if (this.children_.isEmpty()) {
      assert(!this.priorityNode_ || this.priorityNode_.isEmpty(), "An empty node cannot have a priority");
    }
  }
  static get EMPTY_NODE() {
    return EMPTY_NODE || (EMPTY_NODE = new ChildrenNode(new SortedMap(NAME_COMPARATOR), null, IndexMap.Default));
  }
  isLeafNode() {
    return false;
  }
  getPriority() {
    return this.priorityNode_ || EMPTY_NODE;
  }
  updatePriority(newPriorityNode) {
    if (this.children_.isEmpty()) {
      return this;
    } else {
      return new ChildrenNode(this.children_, newPriorityNode, this.indexMap_);
    }
  }
  getImmediateChild(childName) {
    if (childName === ".priority") {
      return this.getPriority();
    } else {
      const child2 = this.children_.get(childName);
      return child2 === null ? EMPTY_NODE : child2;
    }
  }
  getChild(path5) {
    const front = pathGetFront(path5);
    if (front === null) {
      return this;
    }
    return this.getImmediateChild(front).getChild(pathPopFront(path5));
  }
  hasChild(childName) {
    return this.children_.get(childName) !== null;
  }
  updateImmediateChild(childName, newChildNode) {
    assert(newChildNode, "We should always be passing snapshot nodes");
    if (childName === ".priority") {
      return this.updatePriority(newChildNode);
    } else {
      const namedNode = new NamedNode(childName, newChildNode);
      let newChildren, newIndexMap;
      if (newChildNode.isEmpty()) {
        newChildren = this.children_.remove(childName);
        newIndexMap = this.indexMap_.removeFromIndexes(namedNode, this.children_);
      } else {
        newChildren = this.children_.insert(childName, newChildNode);
        newIndexMap = this.indexMap_.addToIndexes(namedNode, this.children_);
      }
      const newPriority = newChildren.isEmpty() ? EMPTY_NODE : this.priorityNode_;
      return new ChildrenNode(newChildren, newPriority, newIndexMap);
    }
  }
  updateChild(path5, newChildNode) {
    const front = pathGetFront(path5);
    if (front === null) {
      return newChildNode;
    } else {
      assert(pathGetFront(path5) !== ".priority" || pathGetLength(path5) === 1, ".priority must be the last token in a path");
      const newImmediateChild = this.getImmediateChild(front).updateChild(pathPopFront(path5), newChildNode);
      return this.updateImmediateChild(front, newImmediateChild);
    }
  }
  isEmpty() {
    return this.children_.isEmpty();
  }
  numChildren() {
    return this.children_.count();
  }
  val(exportFormat) {
    if (this.isEmpty()) {
      return null;
    }
    const obj = {};
    let numKeys = 0, maxKey = 0, allIntegerKeys = true;
    this.forEachChild(PRIORITY_INDEX, (key, childNode) => {
      obj[key] = childNode.val(exportFormat);
      numKeys++;
      if (allIntegerKeys && ChildrenNode.INTEGER_REGEXP_.test(key)) {
        maxKey = Math.max(maxKey, Number(key));
      } else {
        allIntegerKeys = false;
      }
    });
    if (!exportFormat && allIntegerKeys && maxKey < 2 * numKeys) {
      const array = [];
      for (const key in obj) {
        array[key] = obj[key];
      }
      return array;
    } else {
      if (exportFormat && !this.getPriority().isEmpty()) {
        obj[".priority"] = this.getPriority().val();
      }
      return obj;
    }
  }
  hash() {
    if (this.lazyHash_ === null) {
      let toHash = "";
      if (!this.getPriority().isEmpty()) {
        toHash += "priority:" + priorityHashText(this.getPriority().val()) + ":";
      }
      this.forEachChild(PRIORITY_INDEX, (key, childNode) => {
        const childHash = childNode.hash();
        if (childHash !== "") {
          toHash += ":" + key + ":" + childHash;
        }
      });
      this.lazyHash_ = toHash === "" ? "" : sha1(toHash);
    }
    return this.lazyHash_;
  }
  getPredecessorChildName(childName, childNode, index) {
    const idx = this.resolveIndex_(index);
    if (idx) {
      const predecessor = idx.getPredecessorKey(new NamedNode(childName, childNode));
      return predecessor ? predecessor.name : null;
    } else {
      return this.children_.getPredecessorKey(childName);
    }
  }
  getFirstChildName(indexDefinition) {
    const idx = this.resolveIndex_(indexDefinition);
    if (idx) {
      const minKey = idx.minKey();
      return minKey && minKey.name;
    } else {
      return this.children_.minKey();
    }
  }
  getFirstChild(indexDefinition) {
    const minKey = this.getFirstChildName(indexDefinition);
    if (minKey) {
      return new NamedNode(minKey, this.children_.get(minKey));
    } else {
      return null;
    }
  }
  getLastChildName(indexDefinition) {
    const idx = this.resolveIndex_(indexDefinition);
    if (idx) {
      const maxKey = idx.maxKey();
      return maxKey && maxKey.name;
    } else {
      return this.children_.maxKey();
    }
  }
  getLastChild(indexDefinition) {
    const maxKey = this.getLastChildName(indexDefinition);
    if (maxKey) {
      return new NamedNode(maxKey, this.children_.get(maxKey));
    } else {
      return null;
    }
  }
  forEachChild(index, action) {
    const idx = this.resolveIndex_(index);
    if (idx) {
      return idx.inorderTraversal((wrappedNode) => {
        return action(wrappedNode.name, wrappedNode.node);
      });
    } else {
      return this.children_.inorderTraversal(action);
    }
  }
  getIterator(indexDefinition) {
    return this.getIteratorFrom(indexDefinition.minPost(), indexDefinition);
  }
  getIteratorFrom(startPost, indexDefinition) {
    const idx = this.resolveIndex_(indexDefinition);
    if (idx) {
      return idx.getIteratorFrom(startPost, (key) => key);
    } else {
      const iterator = this.children_.getIteratorFrom(startPost.name, NamedNode.Wrap);
      let next = iterator.peek();
      while (next != null && indexDefinition.compare(next, startPost) < 0) {
        iterator.getNext();
        next = iterator.peek();
      }
      return iterator;
    }
  }
  getReverseIterator(indexDefinition) {
    return this.getReverseIteratorFrom(indexDefinition.maxPost(), indexDefinition);
  }
  getReverseIteratorFrom(endPost, indexDefinition) {
    const idx = this.resolveIndex_(indexDefinition);
    if (idx) {
      return idx.getReverseIteratorFrom(endPost, (key) => {
        return key;
      });
    } else {
      const iterator = this.children_.getReverseIteratorFrom(endPost.name, NamedNode.Wrap);
      let next = iterator.peek();
      while (next != null && indexDefinition.compare(next, endPost) > 0) {
        iterator.getNext();
        next = iterator.peek();
      }
      return iterator;
    }
  }
  compareTo(other) {
    if (this.isEmpty()) {
      if (other.isEmpty()) {
        return 0;
      } else {
        return -1;
      }
    } else if (other.isLeafNode() || other.isEmpty()) {
      return 1;
    } else if (other === MAX_NODE) {
      return -1;
    } else {
      return 0;
    }
  }
  withIndex(indexDefinition) {
    if (indexDefinition === KEY_INDEX || this.indexMap_.hasIndex(indexDefinition)) {
      return this;
    } else {
      const newIndexMap = this.indexMap_.addIndex(indexDefinition, this.children_);
      return new ChildrenNode(this.children_, this.priorityNode_, newIndexMap);
    }
  }
  isIndexed(index) {
    return index === KEY_INDEX || this.indexMap_.hasIndex(index);
  }
  equals(other) {
    if (other === this) {
      return true;
    } else if (other.isLeafNode()) {
      return false;
    } else {
      const otherChildrenNode = other;
      if (!this.getPriority().equals(otherChildrenNode.getPriority())) {
        return false;
      } else if (this.children_.count() === otherChildrenNode.children_.count()) {
        const thisIter = this.getIterator(PRIORITY_INDEX);
        const otherIter = otherChildrenNode.getIterator(PRIORITY_INDEX);
        let thisCurrent = thisIter.getNext();
        let otherCurrent = otherIter.getNext();
        while (thisCurrent && otherCurrent) {
          if (thisCurrent.name !== otherCurrent.name || !thisCurrent.node.equals(otherCurrent.node)) {
            return false;
          }
          thisCurrent = thisIter.getNext();
          otherCurrent = otherIter.getNext();
        }
        return thisCurrent === null && otherCurrent === null;
      } else {
        return false;
      }
    }
  }
  resolveIndex_(indexDefinition) {
    if (indexDefinition === KEY_INDEX) {
      return null;
    } else {
      return this.indexMap_.get(indexDefinition.toString());
    }
  }
}
ChildrenNode.INTEGER_REGEXP_ = /^(0|[1-9]\d*)$/;

class MaxNode extends ChildrenNode {
  constructor() {
    super(new SortedMap(NAME_COMPARATOR), ChildrenNode.EMPTY_NODE, IndexMap.Default);
  }
  compareTo(other) {
    if (other === this) {
      return 0;
    } else {
      return 1;
    }
  }
  equals(other) {
    return other === this;
  }
  getPriority() {
    return this;
  }
  getImmediateChild(childName) {
    return ChildrenNode.EMPTY_NODE;
  }
  isEmpty() {
    return false;
  }
}
var MAX_NODE = new MaxNode;
Object.defineProperties(NamedNode, {
  MIN: {
    value: new NamedNode(MIN_NAME, ChildrenNode.EMPTY_NODE)
  },
  MAX: {
    value: new NamedNode(MAX_NAME, MAX_NODE)
  }
});
KeyIndex.__EMPTY_NODE = ChildrenNode.EMPTY_NODE;
LeafNode.__childrenNodeConstructor = ChildrenNode;
setMaxNode$1(MAX_NODE);
setMaxNode(MAX_NODE);
var USE_HINZE = true;
setNodeFromJSON(nodeFromJSON);

class PathIndex extends Index {
  constructor(indexPath_) {
    super();
    this.indexPath_ = indexPath_;
    assert(!pathIsEmpty(indexPath_) && pathGetFront(indexPath_) !== ".priority", "Can't create PathIndex with empty path or .priority key");
  }
  extractChild(snap) {
    return snap.getChild(this.indexPath_);
  }
  isDefinedOn(node) {
    return !node.getChild(this.indexPath_).isEmpty();
  }
  compare(a, b) {
    const aChild = this.extractChild(a.node);
    const bChild = this.extractChild(b.node);
    const indexCmp = aChild.compareTo(bChild);
    if (indexCmp === 0) {
      return nameCompare(a.name, b.name);
    } else {
      return indexCmp;
    }
  }
  makePost(indexValue, name3) {
    const valueNode = nodeFromJSON(indexValue);
    const node = ChildrenNode.EMPTY_NODE.updateChild(this.indexPath_, valueNode);
    return new NamedNode(name3, node);
  }
  maxPost() {
    const node = ChildrenNode.EMPTY_NODE.updateChild(this.indexPath_, MAX_NODE);
    return new NamedNode(MAX_NAME, node);
  }
  toString() {
    return pathSlice(this.indexPath_, 0).join("/");
  }
}

class ValueIndex extends Index {
  compare(a, b) {
    const indexCmp = a.node.compareTo(b.node);
    if (indexCmp === 0) {
      return nameCompare(a.name, b.name);
    } else {
      return indexCmp;
    }
  }
  isDefinedOn(node) {
    return true;
  }
  indexedValueChanged(oldNode, newNode) {
    return !oldNode.equals(newNode);
  }
  minPost() {
    return NamedNode.MIN;
  }
  maxPost() {
    return NamedNode.MAX;
  }
  makePost(indexValue, name3) {
    const valueNode = nodeFromJSON(indexValue);
    return new NamedNode(name3, valueNode);
  }
  toString() {
    return ".value";
  }
}
var VALUE_INDEX = new ValueIndex;

class IndexedFilter {
  constructor(index_) {
    this.index_ = index_;
  }
  updateChild(snap, key, newChild, affectedPath, source2, optChangeAccumulator) {
    assert(snap.isIndexed(this.index_), "A node must be indexed if only a child is updated");
    const oldChild = snap.getImmediateChild(key);
    if (oldChild.getChild(affectedPath).equals(newChild.getChild(affectedPath))) {
      if (oldChild.isEmpty() === newChild.isEmpty()) {
        return snap;
      }
    }
    if (optChangeAccumulator != null) {
      if (newChild.isEmpty()) {
        if (snap.hasChild(key)) {
          optChangeAccumulator.trackChildChange(changeChildRemoved(key, oldChild));
        } else {
          assert(snap.isLeafNode(), "A child remove without an old child only makes sense on a leaf node");
        }
      } else if (oldChild.isEmpty()) {
        optChangeAccumulator.trackChildChange(changeChildAdded(key, newChild));
      } else {
        optChangeAccumulator.trackChildChange(changeChildChanged(key, newChild, oldChild));
      }
    }
    if (snap.isLeafNode() && newChild.isEmpty()) {
      return snap;
    } else {
      return snap.updateImmediateChild(key, newChild).withIndex(this.index_);
    }
  }
  updateFullNode(oldSnap, newSnap, optChangeAccumulator) {
    if (optChangeAccumulator != null) {
      if (!oldSnap.isLeafNode()) {
        oldSnap.forEachChild(PRIORITY_INDEX, (key, childNode) => {
          if (!newSnap.hasChild(key)) {
            optChangeAccumulator.trackChildChange(changeChildRemoved(key, childNode));
          }
        });
      }
      if (!newSnap.isLeafNode()) {
        newSnap.forEachChild(PRIORITY_INDEX, (key, childNode) => {
          if (oldSnap.hasChild(key)) {
            const oldChild = oldSnap.getImmediateChild(key);
            if (!oldChild.equals(childNode)) {
              optChangeAccumulator.trackChildChange(changeChildChanged(key, childNode, oldChild));
            }
          } else {
            optChangeAccumulator.trackChildChange(changeChildAdded(key, childNode));
          }
        });
      }
    }
    return newSnap.withIndex(this.index_);
  }
  updatePriority(oldSnap, newPriority) {
    if (oldSnap.isEmpty()) {
      return ChildrenNode.EMPTY_NODE;
    } else {
      return oldSnap.updatePriority(newPriority);
    }
  }
  filtersNodes() {
    return false;
  }
  getIndexedFilter() {
    return this;
  }
  getIndex() {
    return this.index_;
  }
}

class RangedFilter {
  constructor(params) {
    this.indexedFilter_ = new IndexedFilter(params.getIndex());
    this.index_ = params.getIndex();
    this.startPost_ = RangedFilter.getStartPost_(params);
    this.endPost_ = RangedFilter.getEndPost_(params);
    this.startIsInclusive_ = !params.startAfterSet_;
    this.endIsInclusive_ = !params.endBeforeSet_;
  }
  getStartPost() {
    return this.startPost_;
  }
  getEndPost() {
    return this.endPost_;
  }
  matches(node) {
    const isWithinStart = this.startIsInclusive_ ? this.index_.compare(this.getStartPost(), node) <= 0 : this.index_.compare(this.getStartPost(), node) < 0;
    const isWithinEnd = this.endIsInclusive_ ? this.index_.compare(node, this.getEndPost()) <= 0 : this.index_.compare(node, this.getEndPost()) < 0;
    return isWithinStart && isWithinEnd;
  }
  updateChild(snap, key, newChild, affectedPath, source2, optChangeAccumulator) {
    if (!this.matches(new NamedNode(key, newChild))) {
      newChild = ChildrenNode.EMPTY_NODE;
    }
    return this.indexedFilter_.updateChild(snap, key, newChild, affectedPath, source2, optChangeAccumulator);
  }
  updateFullNode(oldSnap, newSnap, optChangeAccumulator) {
    if (newSnap.isLeafNode()) {
      newSnap = ChildrenNode.EMPTY_NODE;
    }
    let filtered = newSnap.withIndex(this.index_);
    filtered = filtered.updatePriority(ChildrenNode.EMPTY_NODE);
    const self2 = this;
    newSnap.forEachChild(PRIORITY_INDEX, (key, childNode) => {
      if (!self2.matches(new NamedNode(key, childNode))) {
        filtered = filtered.updateImmediateChild(key, ChildrenNode.EMPTY_NODE);
      }
    });
    return this.indexedFilter_.updateFullNode(oldSnap, filtered, optChangeAccumulator);
  }
  updatePriority(oldSnap, newPriority) {
    return oldSnap;
  }
  filtersNodes() {
    return true;
  }
  getIndexedFilter() {
    return this.indexedFilter_;
  }
  getIndex() {
    return this.index_;
  }
  static getStartPost_(params) {
    if (params.hasStart()) {
      const startName = params.getIndexStartName();
      return params.getIndex().makePost(params.getIndexStartValue(), startName);
    } else {
      return params.getIndex().minPost();
    }
  }
  static getEndPost_(params) {
    if (params.hasEnd()) {
      const endName = params.getIndexEndName();
      return params.getIndex().makePost(params.getIndexEndValue(), endName);
    } else {
      return params.getIndex().maxPost();
    }
  }
}

class LimitedFilter {
  constructor(params) {
    this.withinDirectionalStart = (node) => this.reverse_ ? this.withinEndPost(node) : this.withinStartPost(node);
    this.withinDirectionalEnd = (node) => this.reverse_ ? this.withinStartPost(node) : this.withinEndPost(node);
    this.withinStartPost = (node) => {
      const compareRes = this.index_.compare(this.rangedFilter_.getStartPost(), node);
      return this.startIsInclusive_ ? compareRes <= 0 : compareRes < 0;
    };
    this.withinEndPost = (node) => {
      const compareRes = this.index_.compare(node, this.rangedFilter_.getEndPost());
      return this.endIsInclusive_ ? compareRes <= 0 : compareRes < 0;
    };
    this.rangedFilter_ = new RangedFilter(params);
    this.index_ = params.getIndex();
    this.limit_ = params.getLimit();
    this.reverse_ = !params.isViewFromLeft();
    this.startIsInclusive_ = !params.startAfterSet_;
    this.endIsInclusive_ = !params.endBeforeSet_;
  }
  updateChild(snap, key, newChild, affectedPath, source2, optChangeAccumulator) {
    if (!this.rangedFilter_.matches(new NamedNode(key, newChild))) {
      newChild = ChildrenNode.EMPTY_NODE;
    }
    if (snap.getImmediateChild(key).equals(newChild)) {
      return snap;
    } else if (snap.numChildren() < this.limit_) {
      return this.rangedFilter_.getIndexedFilter().updateChild(snap, key, newChild, affectedPath, source2, optChangeAccumulator);
    } else {
      return this.fullLimitUpdateChild_(snap, key, newChild, source2, optChangeAccumulator);
    }
  }
  updateFullNode(oldSnap, newSnap, optChangeAccumulator) {
    let filtered;
    if (newSnap.isLeafNode() || newSnap.isEmpty()) {
      filtered = ChildrenNode.EMPTY_NODE.withIndex(this.index_);
    } else {
      if (this.limit_ * 2 < newSnap.numChildren() && newSnap.isIndexed(this.index_)) {
        filtered = ChildrenNode.EMPTY_NODE.withIndex(this.index_);
        let iterator;
        if (this.reverse_) {
          iterator = newSnap.getReverseIteratorFrom(this.rangedFilter_.getEndPost(), this.index_);
        } else {
          iterator = newSnap.getIteratorFrom(this.rangedFilter_.getStartPost(), this.index_);
        }
        let count = 0;
        while (iterator.hasNext() && count < this.limit_) {
          const next = iterator.getNext();
          if (!this.withinDirectionalStart(next)) {
            continue;
          } else if (!this.withinDirectionalEnd(next)) {
            break;
          } else {
            filtered = filtered.updateImmediateChild(next.name, next.node);
            count++;
          }
        }
      } else {
        filtered = newSnap.withIndex(this.index_);
        filtered = filtered.updatePriority(ChildrenNode.EMPTY_NODE);
        let iterator;
        if (this.reverse_) {
          iterator = filtered.getReverseIterator(this.index_);
        } else {
          iterator = filtered.getIterator(this.index_);
        }
        let count = 0;
        while (iterator.hasNext()) {
          const next = iterator.getNext();
          const inRange = count < this.limit_ && this.withinDirectionalStart(next) && this.withinDirectionalEnd(next);
          if (inRange) {
            count++;
          } else {
            filtered = filtered.updateImmediateChild(next.name, ChildrenNode.EMPTY_NODE);
          }
        }
      }
    }
    return this.rangedFilter_.getIndexedFilter().updateFullNode(oldSnap, filtered, optChangeAccumulator);
  }
  updatePriority(oldSnap, newPriority) {
    return oldSnap;
  }
  filtersNodes() {
    return true;
  }
  getIndexedFilter() {
    return this.rangedFilter_.getIndexedFilter();
  }
  getIndex() {
    return this.index_;
  }
  fullLimitUpdateChild_(snap, childKey, childSnap, source2, changeAccumulator) {
    let cmp;
    if (this.reverse_) {
      const indexCmp = this.index_.getCompare();
      cmp = (a, b) => indexCmp(b, a);
    } else {
      cmp = this.index_.getCompare();
    }
    const oldEventCache = snap;
    assert(oldEventCache.numChildren() === this.limit_, "");
    const newChildNamedNode = new NamedNode(childKey, childSnap);
    const windowBoundary = this.reverse_ ? oldEventCache.getFirstChild(this.index_) : oldEventCache.getLastChild(this.index_);
    const inRange = this.rangedFilter_.matches(newChildNamedNode);
    if (oldEventCache.hasChild(childKey)) {
      const oldChildSnap = oldEventCache.getImmediateChild(childKey);
      let nextChild = source2.getChildAfterChild(this.index_, windowBoundary, this.reverse_);
      while (nextChild != null && (nextChild.name === childKey || oldEventCache.hasChild(nextChild.name))) {
        nextChild = source2.getChildAfterChild(this.index_, nextChild, this.reverse_);
      }
      const compareNext = nextChild == null ? 1 : cmp(nextChild, newChildNamedNode);
      const remainsInWindow = inRange && !childSnap.isEmpty() && compareNext >= 0;
      if (remainsInWindow) {
        if (changeAccumulator != null) {
          changeAccumulator.trackChildChange(changeChildChanged(childKey, childSnap, oldChildSnap));
        }
        return oldEventCache.updateImmediateChild(childKey, childSnap);
      } else {
        if (changeAccumulator != null) {
          changeAccumulator.trackChildChange(changeChildRemoved(childKey, oldChildSnap));
        }
        const newEventCache = oldEventCache.updateImmediateChild(childKey, ChildrenNode.EMPTY_NODE);
        const nextChildInRange = nextChild != null && this.rangedFilter_.matches(nextChild);
        if (nextChildInRange) {
          if (changeAccumulator != null) {
            changeAccumulator.trackChildChange(changeChildAdded(nextChild.name, nextChild.node));
          }
          return newEventCache.updateImmediateChild(nextChild.name, nextChild.node);
        } else {
          return newEventCache;
        }
      }
    } else if (childSnap.isEmpty()) {
      return snap;
    } else if (inRange) {
      if (cmp(windowBoundary, newChildNamedNode) >= 0) {
        if (changeAccumulator != null) {
          changeAccumulator.trackChildChange(changeChildRemoved(windowBoundary.name, windowBoundary.node));
          changeAccumulator.trackChildChange(changeChildAdded(childKey, childSnap));
        }
        return oldEventCache.updateImmediateChild(childKey, childSnap).updateImmediateChild(windowBoundary.name, ChildrenNode.EMPTY_NODE);
      } else {
        return snap;
      }
    } else {
      return snap;
    }
  }
}

class QueryParams {
  constructor() {
    this.limitSet_ = false;
    this.startSet_ = false;
    this.startNameSet_ = false;
    this.startAfterSet_ = false;
    this.endSet_ = false;
    this.endNameSet_ = false;
    this.endBeforeSet_ = false;
    this.limit_ = 0;
    this.viewFrom_ = "";
    this.indexStartValue_ = null;
    this.indexStartName_ = "";
    this.indexEndValue_ = null;
    this.indexEndName_ = "";
    this.index_ = PRIORITY_INDEX;
  }
  hasStart() {
    return this.startSet_;
  }
  isViewFromLeft() {
    if (this.viewFrom_ === "") {
      return this.startSet_;
    } else {
      return this.viewFrom_ === "l";
    }
  }
  getIndexStartValue() {
    assert(this.startSet_, "Only valid if start has been set");
    return this.indexStartValue_;
  }
  getIndexStartName() {
    assert(this.startSet_, "Only valid if start has been set");
    if (this.startNameSet_) {
      return this.indexStartName_;
    } else {
      return MIN_NAME;
    }
  }
  hasEnd() {
    return this.endSet_;
  }
  getIndexEndValue() {
    assert(this.endSet_, "Only valid if end has been set");
    return this.indexEndValue_;
  }
  getIndexEndName() {
    assert(this.endSet_, "Only valid if end has been set");
    if (this.endNameSet_) {
      return this.indexEndName_;
    } else {
      return MAX_NAME;
    }
  }
  hasLimit() {
    return this.limitSet_;
  }
  hasAnchoredLimit() {
    return this.limitSet_ && this.viewFrom_ !== "";
  }
  getLimit() {
    assert(this.limitSet_, "Only valid if limit has been set");
    return this.limit_;
  }
  getIndex() {
    return this.index_;
  }
  loadsAllData() {
    return !(this.startSet_ || this.endSet_ || this.limitSet_);
  }
  isDefault() {
    return this.loadsAllData() && this.index_ === PRIORITY_INDEX;
  }
  copy() {
    const copy = new QueryParams;
    copy.limitSet_ = this.limitSet_;
    copy.limit_ = this.limit_;
    copy.startSet_ = this.startSet_;
    copy.startAfterSet_ = this.startAfterSet_;
    copy.indexStartValue_ = this.indexStartValue_;
    copy.startNameSet_ = this.startNameSet_;
    copy.indexStartName_ = this.indexStartName_;
    copy.endSet_ = this.endSet_;
    copy.endBeforeSet_ = this.endBeforeSet_;
    copy.indexEndValue_ = this.indexEndValue_;
    copy.endNameSet_ = this.endNameSet_;
    copy.indexEndName_ = this.indexEndName_;
    copy.index_ = this.index_;
    copy.viewFrom_ = this.viewFrom_;
    return copy;
  }
}

class ReadonlyRestClient extends ServerActions {
  constructor(repoInfo_, onDataUpdate_, authTokenProvider_, appCheckTokenProvider_) {
    super();
    this.repoInfo_ = repoInfo_;
    this.onDataUpdate_ = onDataUpdate_;
    this.authTokenProvider_ = authTokenProvider_;
    this.appCheckTokenProvider_ = appCheckTokenProvider_;
    this.log_ = logWrapper("p:rest:");
    this.listens_ = {};
  }
  reportStats(stats) {
    throw new Error("Method not implemented.");
  }
  static getListenId_(query, tag) {
    if (tag !== undefined) {
      return "tag$" + tag;
    } else {
      assert(query._queryParams.isDefault(), "should have a tag if it's not a default query.");
      return query._path.toString();
    }
  }
  listen(query, currentHashFn, tag, onComplete) {
    const pathString = query._path.toString();
    this.log_("Listen called for " + pathString + " " + query._queryIdentifier);
    const listenId = ReadonlyRestClient.getListenId_(query, tag);
    const thisListen = {};
    this.listens_[listenId] = thisListen;
    const queryStringParameters = queryParamsToRestQueryStringParameters(query._queryParams);
    this.restRequest_(pathString + ".json", queryStringParameters, (error2, result) => {
      let data = result;
      if (error2 === 404) {
        data = null;
        error2 = null;
      }
      if (error2 === null) {
        this.onDataUpdate_(pathString, data, false, tag);
      }
      if (safeGet(this.listens_, listenId) === thisListen) {
        let status;
        if (!error2) {
          status = "ok";
        } else if (error2 === 401) {
          status = "permission_denied";
        } else {
          status = "rest_error:" + error2;
        }
        onComplete(status, null);
      }
    });
  }
  unlisten(query, tag) {
    const listenId = ReadonlyRestClient.getListenId_(query, tag);
    delete this.listens_[listenId];
  }
  get(query) {
    const queryStringParameters = queryParamsToRestQueryStringParameters(query._queryParams);
    const pathString = query._path.toString();
    const deferred = new Deferred;
    this.restRequest_(pathString + ".json", queryStringParameters, (error2, result) => {
      let data = result;
      if (error2 === 404) {
        data = null;
        error2 = null;
      }
      if (error2 === null) {
        this.onDataUpdate_(pathString, data, false, null);
        deferred.resolve(data);
      } else {
        deferred.reject(new Error(data));
      }
    });
    return deferred.promise;
  }
  refreshAuthToken(token) {
  }
  restRequest_(pathString, queryStringParameters = {}, callback) {
    queryStringParameters["format"] = "export";
    return Promise.all([
      this.authTokenProvider_.getToken(false),
      this.appCheckTokenProvider_.getToken(false)
    ]).then(([authToken, appCheckToken]) => {
      if (authToken && authToken.accessToken) {
        queryStringParameters["auth"] = authToken.accessToken;
      }
      if (appCheckToken && appCheckToken.token) {
        queryStringParameters["ac"] = appCheckToken.token;
      }
      const url = (this.repoInfo_.secure ? "https://" : "http://") + this.repoInfo_.host + pathString + "?ns=" + this.repoInfo_.namespace + querystring(queryStringParameters);
      this.log_("Sending REST request for " + url);
      const xhr = new XMLHttpRequest;
      xhr.onreadystatechange = () => {
        if (callback && xhr.readyState === 4) {
          this.log_("REST Response for " + url + " received. status:", xhr.status, "response:", xhr.responseText);
          let res = null;
          if (xhr.status >= 200 && xhr.status < 300) {
            try {
              res = jsonEval(xhr.responseText);
            } catch (e) {
              warn("Failed to parse JSON response for " + url + ": " + xhr.responseText);
            }
            callback(null, res);
          } else {
            if (xhr.status !== 401 && xhr.status !== 404) {
              warn("Got unsuccessful REST response for " + url + " Status: " + xhr.status);
            }
            callback(xhr.status);
          }
          callback = null;
        }
      };
      xhr.open("GET", url, true);
      xhr.send();
    });
  }
}

class SnapshotHolder {
  constructor() {
    this.rootNode_ = ChildrenNode.EMPTY_NODE;
  }
  getNode(path5) {
    return this.rootNode_.getChild(path5);
  }
  updateSnapshot(path5, newSnapshotNode) {
    this.rootNode_ = this.rootNode_.updateChild(path5, newSnapshotNode);
  }
}

class StatsListener {
  constructor(collection_) {
    this.collection_ = collection_;
    this.last_ = null;
  }
  get() {
    const newStats = this.collection_.get();
    const delta = Object.assign({}, newStats);
    if (this.last_) {
      each(this.last_, (stat, value) => {
        delta[stat] = delta[stat] - value;
      });
    }
    this.last_ = newStats;
    return delta;
  }
}
var FIRST_STATS_MIN_TIME = 10 * 1000;
var FIRST_STATS_MAX_TIME = 30 * 1000;
var REPORT_STATS_INTERVAL = 5 * 60 * 1000;

class StatsReporter {
  constructor(collection, server_) {
    this.server_ = server_;
    this.statsToReport_ = {};
    this.statsListener_ = new StatsListener(collection);
    const timeout = FIRST_STATS_MIN_TIME + (FIRST_STATS_MAX_TIME - FIRST_STATS_MIN_TIME) * Math.random();
    setTimeoutNonBlocking(this.reportStats_.bind(this), Math.floor(timeout));
  }
  reportStats_() {
    const stats = this.statsListener_.get();
    const reportedStats = {};
    let haveStatsToReport = false;
    each(stats, (stat, value) => {
      if (value > 0 && contains(this.statsToReport_, stat)) {
        reportedStats[stat] = value;
        haveStatsToReport = true;
      }
    });
    if (haveStatsToReport) {
      this.server_.reportStats(reportedStats);
    }
    setTimeoutNonBlocking(this.reportStats_.bind(this), Math.floor(Math.random() * 2 * REPORT_STATS_INTERVAL));
  }
}
var OperationType;
(function(OperationType2) {
  OperationType2[OperationType2["OVERWRITE"] = 0] = "OVERWRITE";
  OperationType2[OperationType2["MERGE"] = 1] = "MERGE";
  OperationType2[OperationType2["ACK_USER_WRITE"] = 2] = "ACK_USER_WRITE";
  OperationType2[OperationType2["LISTEN_COMPLETE"] = 3] = "LISTEN_COMPLETE";
})(OperationType || (OperationType = {}));

class AckUserWrite {
  constructor(path5, affectedTree, revert) {
    this.path = path5;
    this.affectedTree = affectedTree;
    this.revert = revert;
    this.type = OperationType.ACK_USER_WRITE;
    this.source = newOperationSourceUser();
  }
  operationForChild(childName) {
    if (!pathIsEmpty(this.path)) {
      assert(pathGetFront(this.path) === childName, "operationForChild called for unrelated child.");
      return new AckUserWrite(pathPopFront(this.path), this.affectedTree, this.revert);
    } else if (this.affectedTree.value != null) {
      assert(this.affectedTree.children.isEmpty(), "affectedTree should not have overlapping affected paths.");
      return this;
    } else {
      const childTree = this.affectedTree.subtree(new Path3(childName));
      return new AckUserWrite(newEmptyPath(), childTree, this.revert);
    }
  }
}

class ListenComplete {
  constructor(source2, path5) {
    this.source = source2;
    this.path = path5;
    this.type = OperationType.LISTEN_COMPLETE;
  }
  operationForChild(childName) {
    if (pathIsEmpty(this.path)) {
      return new ListenComplete(this.source, newEmptyPath());
    } else {
      return new ListenComplete(this.source, pathPopFront(this.path));
    }
  }
}

class Overwrite {
  constructor(source2, path5, snap) {
    this.source = source2;
    this.path = path5;
    this.snap = snap;
    this.type = OperationType.OVERWRITE;
  }
  operationForChild(childName) {
    if (pathIsEmpty(this.path)) {
      return new Overwrite(this.source, newEmptyPath(), this.snap.getImmediateChild(childName));
    } else {
      return new Overwrite(this.source, pathPopFront(this.path), this.snap);
    }
  }
}

class Merge {
  constructor(source2, path5, children) {
    this.source = source2;
    this.path = path5;
    this.children = children;
    this.type = OperationType.MERGE;
  }
  operationForChild(childName) {
    if (pathIsEmpty(this.path)) {
      const childTree = this.children.subtree(new Path3(childName));
      if (childTree.isEmpty()) {
        return null;
      } else if (childTree.value) {
        return new Overwrite(this.source, newEmptyPath(), childTree.value);
      } else {
        return new Merge(this.source, newEmptyPath(), childTree);
      }
    } else {
      assert(pathGetFront(this.path) === childName, "Can't get a merge for a child not on the path of the operation");
      return new Merge(this.source, pathPopFront(this.path), this.children);
    }
  }
  toString() {
    return "Operation(" + this.path + ": " + this.source.toString() + " merge: " + this.children.toString() + ")";
  }
}

class CacheNode {
  constructor(node_, fullyInitialized_, filtered_) {
    this.node_ = node_;
    this.fullyInitialized_ = fullyInitialized_;
    this.filtered_ = filtered_;
  }
  isFullyInitialized() {
    return this.fullyInitialized_;
  }
  isFiltered() {
    return this.filtered_;
  }
  isCompleteForPath(path5) {
    if (pathIsEmpty(path5)) {
      return this.isFullyInitialized() && !this.filtered_;
    }
    const childKey = pathGetFront(path5);
    return this.isCompleteForChild(childKey);
  }
  isCompleteForChild(key) {
    return this.isFullyInitialized() && !this.filtered_ || this.node_.hasChild(key);
  }
  getNode() {
    return this.node_;
  }
}

class EventGenerator {
  constructor(query_) {
    this.query_ = query_;
    this.index_ = this.query_._queryParams.getIndex();
  }
}
var emptyChildrenSingleton;
var EmptyChildren = () => {
  if (!emptyChildrenSingleton) {
    emptyChildrenSingleton = new SortedMap(stringCompare);
  }
  return emptyChildrenSingleton;
};

class ImmutableTree {
  constructor(value, children = EmptyChildren()) {
    this.value = value;
    this.children = children;
  }
  static fromObject(obj) {
    let tree = new ImmutableTree(null);
    each(obj, (childPath, childSnap) => {
      tree = tree.set(new Path3(childPath), childSnap);
    });
    return tree;
  }
  isEmpty() {
    return this.value === null && this.children.isEmpty();
  }
  findRootMostMatchingPathAndValue(relativePath, predicate) {
    if (this.value != null && predicate(this.value)) {
      return { path: newEmptyPath(), value: this.value };
    } else {
      if (pathIsEmpty(relativePath)) {
        return null;
      } else {
        const front = pathGetFront(relativePath);
        const child2 = this.children.get(front);
        if (child2 !== null) {
          const childExistingPathAndValue = child2.findRootMostMatchingPathAndValue(pathPopFront(relativePath), predicate);
          if (childExistingPathAndValue != null) {
            const fullPath = pathChild(new Path3(front), childExistingPathAndValue.path);
            return { path: fullPath, value: childExistingPathAndValue.value };
          } else {
            return null;
          }
        } else {
          return null;
        }
      }
    }
  }
  findRootMostValueAndPath(relativePath) {
    return this.findRootMostMatchingPathAndValue(relativePath, () => true);
  }
  subtree(relativePath) {
    if (pathIsEmpty(relativePath)) {
      return this;
    } else {
      const front = pathGetFront(relativePath);
      const childTree = this.children.get(front);
      if (childTree !== null) {
        return childTree.subtree(pathPopFront(relativePath));
      } else {
        return new ImmutableTree(null);
      }
    }
  }
  set(relativePath, toSet) {
    if (pathIsEmpty(relativePath)) {
      return new ImmutableTree(toSet, this.children);
    } else {
      const front = pathGetFront(relativePath);
      const child2 = this.children.get(front) || new ImmutableTree(null);
      const newChild = child2.set(pathPopFront(relativePath), toSet);
      const newChildren = this.children.insert(front, newChild);
      return new ImmutableTree(this.value, newChildren);
    }
  }
  remove(relativePath) {
    if (pathIsEmpty(relativePath)) {
      if (this.children.isEmpty()) {
        return new ImmutableTree(null);
      } else {
        return new ImmutableTree(null, this.children);
      }
    } else {
      const front = pathGetFront(relativePath);
      const child2 = this.children.get(front);
      if (child2) {
        const newChild = child2.remove(pathPopFront(relativePath));
        let newChildren;
        if (newChild.isEmpty()) {
          newChildren = this.children.remove(front);
        } else {
          newChildren = this.children.insert(front, newChild);
        }
        if (this.value === null && newChildren.isEmpty()) {
          return new ImmutableTree(null);
        } else {
          return new ImmutableTree(this.value, newChildren);
        }
      } else {
        return this;
      }
    }
  }
  get(relativePath) {
    if (pathIsEmpty(relativePath)) {
      return this.value;
    } else {
      const front = pathGetFront(relativePath);
      const child2 = this.children.get(front);
      if (child2) {
        return child2.get(pathPopFront(relativePath));
      } else {
        return null;
      }
    }
  }
  setTree(relativePath, newTree) {
    if (pathIsEmpty(relativePath)) {
      return newTree;
    } else {
      const front = pathGetFront(relativePath);
      const child2 = this.children.get(front) || new ImmutableTree(null);
      const newChild = child2.setTree(pathPopFront(relativePath), newTree);
      let newChildren;
      if (newChild.isEmpty()) {
        newChildren = this.children.remove(front);
      } else {
        newChildren = this.children.insert(front, newChild);
      }
      return new ImmutableTree(this.value, newChildren);
    }
  }
  fold(fn) {
    return this.fold_(newEmptyPath(), fn);
  }
  fold_(pathSoFar, fn) {
    const accum = {};
    this.children.inorderTraversal((childKey, childTree) => {
      accum[childKey] = childTree.fold_(pathChild(pathSoFar, childKey), fn);
    });
    return fn(pathSoFar, this.value, accum);
  }
  findOnPath(path5, f) {
    return this.findOnPath_(path5, newEmptyPath(), f);
  }
  findOnPath_(pathToFollow, pathSoFar, f) {
    const result = this.value ? f(pathSoFar, this.value) : false;
    if (result) {
      return result;
    } else {
      if (pathIsEmpty(pathToFollow)) {
        return null;
      } else {
        const front = pathGetFront(pathToFollow);
        const nextChild = this.children.get(front);
        if (nextChild) {
          return nextChild.findOnPath_(pathPopFront(pathToFollow), pathChild(pathSoFar, front), f);
        } else {
          return null;
        }
      }
    }
  }
  foreachOnPath(path5, f) {
    return this.foreachOnPath_(path5, newEmptyPath(), f);
  }
  foreachOnPath_(pathToFollow, currentRelativePath, f) {
    if (pathIsEmpty(pathToFollow)) {
      return this;
    } else {
      if (this.value) {
        f(currentRelativePath, this.value);
      }
      const front = pathGetFront(pathToFollow);
      const nextChild = this.children.get(front);
      if (nextChild) {
        return nextChild.foreachOnPath_(pathPopFront(pathToFollow), pathChild(currentRelativePath, front), f);
      } else {
        return new ImmutableTree(null);
      }
    }
  }
  foreach(f) {
    this.foreach_(newEmptyPath(), f);
  }
  foreach_(currentRelativePath, f) {
    this.children.inorderTraversal((childName, childTree) => {
      childTree.foreach_(pathChild(currentRelativePath, childName), f);
    });
    if (this.value) {
      f(currentRelativePath, this.value);
    }
  }
  foreachChild(f) {
    this.children.inorderTraversal((childName, childTree) => {
      if (childTree.value) {
        f(childName, childTree.value);
      }
    });
  }
}

class CompoundWrite {
  constructor(writeTree_) {
    this.writeTree_ = writeTree_;
  }
  static empty() {
    return new CompoundWrite(new ImmutableTree(null));
  }
}

class ChildChangeAccumulator {
  constructor() {
    this.changeMap = new Map;
  }
  trackChildChange(change) {
    const type = change.type;
    const childKey = change.childName;
    assert(type === "child_added" || type === "child_changed" || type === "child_removed", "Only child changes supported for tracking");
    assert(childKey !== ".priority", "Only non-priority child changes can be tracked.");
    const oldChange = this.changeMap.get(childKey);
    if (oldChange) {
      const oldType = oldChange.type;
      if (type === "child_added" && oldType === "child_removed") {
        this.changeMap.set(childKey, changeChildChanged(childKey, change.snapshotNode, oldChange.snapshotNode));
      } else if (type === "child_removed" && oldType === "child_added") {
        this.changeMap.delete(childKey);
      } else if (type === "child_removed" && oldType === "child_changed") {
        this.changeMap.set(childKey, changeChildRemoved(childKey, oldChange.oldSnap));
      } else if (type === "child_changed" && oldType === "child_added") {
        this.changeMap.set(childKey, changeChildAdded(childKey, change.snapshotNode));
      } else if (type === "child_changed" && oldType === "child_changed") {
        this.changeMap.set(childKey, changeChildChanged(childKey, change.snapshotNode, oldChange.oldSnap));
      } else {
        throw assertionError("Illegal combination of changes: " + change + " occurred after " + oldChange);
      }
    } else {
      this.changeMap.set(childKey, change);
    }
  }
  getChanges() {
    return Array.from(this.changeMap.values());
  }
}

class NoCompleteChildSource_ {
  getCompleteChild(childKey) {
    return null;
  }
  getChildAfterChild(index, child2, reverse) {
    return null;
  }
}
var NO_COMPLETE_CHILD_SOURCE = new NoCompleteChildSource_;

class WriteTreeCompleteChildSource {
  constructor(writes_, viewCache_, optCompleteServerCache_ = null) {
    this.writes_ = writes_;
    this.viewCache_ = viewCache_;
    this.optCompleteServerCache_ = optCompleteServerCache_;
  }
  getCompleteChild(childKey) {
    const node = this.viewCache_.eventCache;
    if (node.isCompleteForChild(childKey)) {
      return node.getNode().getImmediateChild(childKey);
    } else {
      const serverNode = this.optCompleteServerCache_ != null ? new CacheNode(this.optCompleteServerCache_, true, false) : this.viewCache_.serverCache;
      return writeTreeRefCalcCompleteChild(this.writes_, childKey, serverNode);
    }
  }
  getChildAfterChild(index, child2, reverse) {
    const completeServerData = this.optCompleteServerCache_ != null ? this.optCompleteServerCache_ : viewCacheGetCompleteServerSnap(this.viewCache_);
    const nodes = writeTreeRefCalcIndexedSlice(this.writes_, completeServerData, child2, 1, reverse, index);
    if (nodes.length === 0) {
      return null;
    } else {
      return nodes[0];
    }
  }
}

class View {
  constructor(query_, initialViewCache) {
    this.query_ = query_;
    this.eventRegistrations_ = [];
    const params = this.query_._queryParams;
    const indexFilter = new IndexedFilter(params.getIndex());
    const filter = queryParamsGetNodeFilter(params);
    this.processor_ = newViewProcessor(filter);
    const initialServerCache = initialViewCache.serverCache;
    const initialEventCache = initialViewCache.eventCache;
    const serverSnap = indexFilter.updateFullNode(ChildrenNode.EMPTY_NODE, initialServerCache.getNode(), null);
    const eventSnap = filter.updateFullNode(ChildrenNode.EMPTY_NODE, initialEventCache.getNode(), null);
    const newServerCache = new CacheNode(serverSnap, initialServerCache.isFullyInitialized(), indexFilter.filtersNodes());
    const newEventCache = new CacheNode(eventSnap, initialEventCache.isFullyInitialized(), filter.filtersNodes());
    this.viewCache_ = newViewCache(newEventCache, newServerCache);
    this.eventGenerator_ = new EventGenerator(this.query_);
  }
  get query() {
    return this.query_;
  }
}
var referenceConstructor$1;

class SyncPoint {
  constructor() {
    this.views = new Map;
  }
}
var referenceConstructor;
var syncTreeNextQueryTag_ = 1;

class SyncTree {
  constructor(listenProvider_) {
    this.listenProvider_ = listenProvider_;
    this.syncPointTree_ = new ImmutableTree(null);
    this.pendingWriteTree_ = newWriteTree();
    this.tagToQueryMap = new Map;
    this.queryToTagMap = new Map;
  }
}

class ExistingValueProvider {
  constructor(node_) {
    this.node_ = node_;
  }
  getImmediateChild(childName) {
    const child2 = this.node_.getImmediateChild(childName);
    return new ExistingValueProvider(child2);
  }
  node() {
    return this.node_;
  }
}

class DeferredValueProvider {
  constructor(syncTree, path5) {
    this.syncTree_ = syncTree;
    this.path_ = path5;
  }
  getImmediateChild(childName) {
    const childPath = pathChild(this.path_, childName);
    return new DeferredValueProvider(this.syncTree_, childPath);
  }
  node() {
    return syncTreeCalcCompleteEventCache(this.syncTree_, this.path_);
  }
}
var generateWithValues = function(values2) {
  values2 = values2 || {};
  values2["timestamp"] = values2["timestamp"] || new Date().getTime();
  return values2;
};
var resolveDeferredLeafValue = function(value, existingVal, serverValues) {
  if (!value || typeof value !== "object") {
    return value;
  }
  assert(".sv" in value, "Unexpected leaf node or priority contents");
  if (typeof value[".sv"] === "string") {
    return resolveScalarDeferredValue(value[".sv"], existingVal, serverValues);
  } else if (typeof value[".sv"] === "object") {
    return resolveComplexDeferredValue(value[".sv"], existingVal);
  } else {
    assert(false, "Unexpected server value: " + JSON.stringify(value, null, 2));
  }
};
var resolveScalarDeferredValue = function(op, existing, serverValues) {
  switch (op) {
    case "timestamp":
      return serverValues["timestamp"];
    default:
      assert(false, "Unexpected server value: " + op);
  }
};
var resolveComplexDeferredValue = function(op, existing, unused) {
  if (!op.hasOwnProperty("increment")) {
    assert(false, "Unexpected server value: " + JSON.stringify(op, null, 2));
  }
  const delta = op["increment"];
  if (typeof delta !== "number") {
    assert(false, "Unexpected increment value: " + delta);
  }
  const existingNode = existing.node();
  assert(existingNode !== null && typeof existingNode !== "undefined", "Expected ChildrenNode.EMPTY_NODE for nulls");
  if (!existingNode.isLeafNode()) {
    return delta;
  }
  const leaf = existingNode;
  const existingVal = leaf.getValue();
  if (typeof existingVal !== "number") {
    return delta;
  }
  return existingVal + delta;
};
var resolveDeferredValueTree = function(path5, node, syncTree, serverValues) {
  return resolveDeferredValue(node, new DeferredValueProvider(syncTree, path5), serverValues);
};
var resolveDeferredValueSnapshot = function(node, existing, serverValues) {
  return resolveDeferredValue(node, new ExistingValueProvider(existing), serverValues);
};

class Tree {
  constructor(name3 = "", parent = null, node = { children: {}, childCount: 0 }) {
    this.name = name3;
    this.parent = parent;
    this.node = node;
  }
}
var INVALID_KEY_REGEX_ = /[\[\].#$\/\u0000-\u001F\u007F]/;
var INVALID_PATH_REGEX_ = /[\[\].#$\u0000-\u001F\u007F]/;
var MAX_LEAF_SIZE_ = 10 * 1024 * 1024;
var isValidKey2 = function(key) {
  return typeof key === "string" && key.length !== 0 && !INVALID_KEY_REGEX_.test(key);
};
var isValidPathString = function(pathString) {
  return typeof pathString === "string" && pathString.length !== 0 && !INVALID_PATH_REGEX_.test(pathString);
};
var isValidRootPathString = function(pathString) {
  if (pathString) {
    pathString = pathString.replace(/^\/*\.info(\/|$)/, "/");
  }
  return isValidPathString(pathString);
};
var validateFirebaseData = function(errorPrefix2, data, path_) {
  const path5 = path_ instanceof Path3 ? new ValidationPath(path_, errorPrefix2) : path_;
  if (data === undefined) {
    throw new Error(errorPrefix2 + "contains undefined " + validationPathToErrorString(path5));
  }
  if (typeof data === "function") {
    throw new Error(errorPrefix2 + "contains a function " + validationPathToErrorString(path5) + " with contents = " + data.toString());
  }
  if (isInvalidJSONNumber(data)) {
    throw new Error(errorPrefix2 + "contains " + data.toString() + " " + validationPathToErrorString(path5));
  }
  if (typeof data === "string" && data.length > MAX_LEAF_SIZE_ / 3 && stringLength(data) > MAX_LEAF_SIZE_) {
    throw new Error(errorPrefix2 + "contains a string greater than " + MAX_LEAF_SIZE_ + " utf8 bytes " + validationPathToErrorString(path5) + " ('" + data.substring(0, 50) + "...')");
  }
  if (data && typeof data === "object") {
    let hasDotValue = false;
    let hasActualChild = false;
    each(data, (key, value) => {
      if (key === ".value") {
        hasDotValue = true;
      } else if (key !== ".priority" && key !== ".sv") {
        hasActualChild = true;
        if (!isValidKey2(key)) {
          throw new Error(errorPrefix2 + " contains an invalid key (" + key + ") " + validationPathToErrorString(path5) + '.  Keys must be non-empty strings and can\'t contain ".", "#", "$", "/", "[", or "]"');
        }
      }
      validationPathPush(path5, key);
      validateFirebaseData(errorPrefix2, value, path5);
      validationPathPop(path5);
    });
    if (hasDotValue && hasActualChild) {
      throw new Error(errorPrefix2 + ' contains ".value" child ' + validationPathToErrorString(path5) + " in addition to actual children.");
    }
  }
};
var validatePathString = function(fnName, argumentName, pathString, optional) {
  if (optional && pathString === undefined) {
    return;
  }
  if (!isValidPathString(pathString)) {
    throw new Error(errorPrefix(fnName, argumentName) + 'was an invalid path = "' + pathString + '". Paths must be non-empty strings and can\'t contain ".", "#", "$", "[", or "]"');
  }
};
var validateRootPathString = function(fnName, argumentName, pathString, optional) {
  if (pathString) {
    pathString = pathString.replace(/^\/*\.info(\/|$)/, "/");
  }
  validatePathString(fnName, argumentName, pathString, optional);
};
var validateUrl = function(fnName, parsedUrl) {
  const pathString = parsedUrl.path.toString();
  if (!(typeof parsedUrl.repoInfo.host === "string") || parsedUrl.repoInfo.host.length === 0 || !isValidKey2(parsedUrl.repoInfo.namespace) && parsedUrl.repoInfo.host.split(":")[0] !== "localhost" || pathString.length !== 0 && !isValidRootPathString(pathString)) {
    throw new Error(errorPrefix(fnName, "url") + 'must be a valid firebase URL and the path can\'t contain ".", "#", "$", "[", or "]".');
  }
};

class EventQueue {
  constructor() {
    this.eventLists_ = [];
    this.recursionDepth_ = 0;
  }
}
var INTERRUPT_REASON = "repo_interrupt";
var MAX_TRANSACTION_RETRIES = 25;

class Repo {
  constructor(repoInfo_, forceRestClient_, authTokenProvider_, appCheckProvider_) {
    this.repoInfo_ = repoInfo_;
    this.forceRestClient_ = forceRestClient_;
    this.authTokenProvider_ = authTokenProvider_;
    this.appCheckProvider_ = appCheckProvider_;
    this.dataUpdateCount = 0;
    this.statsListener_ = null;
    this.eventQueue_ = new EventQueue;
    this.nextWriteId_ = 1;
    this.interceptServerDataCallback_ = null;
    this.onDisconnect_ = newSparseSnapshotTree();
    this.transactionQueueTree_ = new Tree;
    this.persistentConnection_ = null;
    this.key = this.repoInfo_.toURLString();
  }
  toString() {
    return (this.repoInfo_.secure ? "https://" : "http://") + this.repoInfo_.host;
  }
}
var parseRepoInfo = function(dataURL, nodeAdmin) {
  const parsedUrl = parseDatabaseURL(dataURL), namespace = parsedUrl.namespace;
  if (parsedUrl.domain === "firebase.com") {
    fatal(parsedUrl.host + " is no longer supported. Please use <YOUR FIREBASE>.firebaseio.com instead");
  }
  if ((!namespace || namespace === "undefined") && parsedUrl.domain !== "localhost") {
    fatal("Cannot parse Firebase url. Please use https://<YOUR FIREBASE>.firebaseio.com");
  }
  if (!parsedUrl.secure) {
    warnIfPageIsSecure();
  }
  const webSocketOnly = parsedUrl.scheme === "ws" || parsedUrl.scheme === "wss";
  return {
    repoInfo: new RepoInfo(parsedUrl.host, parsedUrl.secure, namespace, webSocketOnly, nodeAdmin, "", namespace !== parsedUrl.subdomain),
    path: new Path3(parsedUrl.pathString)
  };
};
var parseDatabaseURL = function(dataURL) {
  let host = "", domain = "", subdomain = "", pathString = "", namespace = "";
  let secure = true, scheme = "https", port = 443;
  if (typeof dataURL === "string") {
    let colonInd = dataURL.indexOf("//");
    if (colonInd >= 0) {
      scheme = dataURL.substring(0, colonInd - 1);
      dataURL = dataURL.substring(colonInd + 2);
    }
    let slashInd = dataURL.indexOf("/");
    if (slashInd === -1) {
      slashInd = dataURL.length;
    }
    let questionMarkInd = dataURL.indexOf("?");
    if (questionMarkInd === -1) {
      questionMarkInd = dataURL.length;
    }
    host = dataURL.substring(0, Math.min(slashInd, questionMarkInd));
    if (slashInd < questionMarkInd) {
      pathString = decodePath(dataURL.substring(slashInd, questionMarkInd));
    }
    const queryParams = decodeQuery(dataURL.substring(Math.min(dataURL.length, questionMarkInd)));
    colonInd = host.indexOf(":");
    if (colonInd >= 0) {
      secure = scheme === "https" || scheme === "wss";
      port = parseInt(host.substring(colonInd + 1), 10);
    } else {
      colonInd = host.length;
    }
    const hostWithoutPort = host.slice(0, colonInd);
    if (hostWithoutPort.toLowerCase() === "localhost") {
      domain = "localhost";
    } else if (hostWithoutPort.split(".").length <= 2) {
      domain = hostWithoutPort;
    } else {
      const dotInd = host.indexOf(".");
      subdomain = host.substring(0, dotInd).toLowerCase();
      domain = host.substring(dotInd + 1);
      namespace = subdomain;
    }
    if ("ns" in queryParams) {
      namespace = queryParams["ns"];
    }
  }
  return {
    host,
    port,
    domain,
    subdomain,
    secure,
    scheme,
    pathString,
    namespace
  };
};
var PUSH_CHARS = "-0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz";
var nextPushId = function() {
  let lastPushTime = 0;
  const lastRandChars = [];
  return function(now) {
    const duplicateTime = now === lastPushTime;
    lastPushTime = now;
    let i;
    const timeStampChars = new Array(8);
    for (i = 7;i >= 0; i--) {
      timeStampChars[i] = PUSH_CHARS.charAt(now % 64);
      now = Math.floor(now / 64);
    }
    assert(now === 0, "Cannot push at time == 0");
    let id = timeStampChars.join("");
    if (!duplicateTime) {
      for (i = 0;i < 12; i++) {
        lastRandChars[i] = Math.floor(Math.random() * 64);
      }
    } else {
      for (i = 11;i >= 0 && lastRandChars[i] === 63; i--) {
        lastRandChars[i] = 0;
      }
      lastRandChars[i]++;
    }
    for (i = 0;i < 12; i++) {
      id += PUSH_CHARS.charAt(lastRandChars[i]);
    }
    assert(id.length === 20, "nextPushId: Length should be 20.");
    return id;
  };
}();

class DataEvent {
  constructor(eventType, eventRegistration, snapshot, prevName) {
    this.eventType = eventType;
    this.eventRegistration = eventRegistration;
    this.snapshot = snapshot;
    this.prevName = prevName;
  }
  getPath() {
    const ref2 = this.snapshot.ref;
    if (this.eventType === "value") {
      return ref2._path;
    } else {
      return ref2.parent._path;
    }
  }
  getEventType() {
    return this.eventType;
  }
  getEventRunner() {
    return this.eventRegistration.getEventRunner(this);
  }
  toString() {
    return this.getPath().toString() + ":" + this.eventType + ":" + stringify(this.snapshot.exportVal());
  }
}

class CancelEvent {
  constructor(eventRegistration, error2, path5) {
    this.eventRegistration = eventRegistration;
    this.error = error2;
    this.path = path5;
  }
  getPath() {
    return this.path;
  }
  getEventType() {
    return "cancel";
  }
  getEventRunner() {
    return this.eventRegistration.getEventRunner(this);
  }
  toString() {
    return this.path.toString() + ":cancel";
  }
}

class CallbackContext {
  constructor(snapshotCallback, cancelCallback) {
    this.snapshotCallback = snapshotCallback;
    this.cancelCallback = cancelCallback;
  }
  onValue(expDataSnapshot, previousChildName) {
    this.snapshotCallback.call(null, expDataSnapshot, previousChildName);
  }
  onCancel(error2) {
    assert(this.hasCancelCallback, "Raising a cancel event on a listener with no cancel callback");
    return this.cancelCallback.call(null, error2);
  }
  get hasCancelCallback() {
    return !!this.cancelCallback;
  }
  matches(other) {
    return this.snapshotCallback === other.snapshotCallback || this.snapshotCallback.userCallback !== undefined && this.snapshotCallback.userCallback === other.snapshotCallback.userCallback && this.snapshotCallback.context === other.snapshotCallback.context;
  }
}
class QueryImpl {
  constructor(_repo, _path, _queryParams, _orderByCalled) {
    this._repo = _repo;
    this._path = _path;
    this._queryParams = _queryParams;
    this._orderByCalled = _orderByCalled;
  }
  get key() {
    if (pathIsEmpty(this._path)) {
      return null;
    } else {
      return pathGetBack(this._path);
    }
  }
  get ref() {
    return new ReferenceImpl(this._repo, this._path);
  }
  get _queryIdentifier() {
    const obj = queryParamsGetQueryObject(this._queryParams);
    const id = ObjectToUniqueKey(obj);
    return id === "{}" ? "default" : id;
  }
  get _queryObject() {
    return queryParamsGetQueryObject(this._queryParams);
  }
  isEqual(other) {
    other = getModularInstance(other);
    if (!(other instanceof QueryImpl)) {
      return false;
    }
    const sameRepo = this._repo === other._repo;
    const samePath = pathEquals(this._path, other._path);
    const sameQueryIdentifier = this._queryIdentifier === other._queryIdentifier;
    return sameRepo && samePath && sameQueryIdentifier;
  }
  toJSON() {
    return this.toString();
  }
  toString() {
    return this._repo.toString() + pathToUrlEncodedString(this._path);
  }
}

class ReferenceImpl extends QueryImpl {
  constructor(repo, path5) {
    super(repo, path5, new QueryParams, false);
  }
  get parent() {
    const parentPath = pathParent(this._path);
    return parentPath === null ? null : new ReferenceImpl(this._repo, parentPath);
  }
  get root() {
    let ref2 = this;
    while (ref2.parent !== null) {
      ref2 = ref2.parent;
    }
    return ref2;
  }
}

class DataSnapshot {
  constructor(_node, ref2, _index) {
    this._node = _node;
    this.ref = ref2;
    this._index = _index;
  }
  get priority() {
    return this._node.getPriority().val();
  }
  get key() {
    return this.ref.key;
  }
  get size() {
    return this._node.numChildren();
  }
  child(path5) {
    const childPath = new Path3(path5);
    const childRef = child(this.ref, path5);
    return new DataSnapshot(this._node.getChild(childPath), childRef, PRIORITY_INDEX);
  }
  exists() {
    return !this._node.isEmpty();
  }
  exportVal() {
    return this._node.val(true);
  }
  forEach(action) {
    if (this._node.isLeafNode()) {
      return false;
    }
    const childrenNode = this._node;
    return !!childrenNode.forEachChild(this._index, (key, node) => {
      return action(new DataSnapshot(node, child(this.ref, key), PRIORITY_INDEX));
    });
  }
  hasChild(path5) {
    const childPath = new Path3(path5);
    return !this._node.getChild(childPath).isEmpty();
  }
  hasChildren() {
    if (this._node.isLeafNode()) {
      return false;
    } else {
      return !this._node.isEmpty();
    }
  }
  toJSON() {
    return this.exportVal();
  }
  val() {
    return this._node.val();
  }
}

class ValueEventRegistration {
  constructor(callbackContext) {
    this.callbackContext = callbackContext;
  }
  respondsTo(eventType) {
    return eventType === "value";
  }
  createEvent(change, query) {
    const index = query._queryParams.getIndex();
    return new DataEvent("value", this, new DataSnapshot(change.snapshotNode, new ReferenceImpl(query._repo, query._path), index));
  }
  getEventRunner(eventData) {
    if (eventData.getEventType() === "cancel") {
      return () => this.callbackContext.onCancel(eventData.error);
    } else {
      return () => this.callbackContext.onValue(eventData.snapshot, null);
    }
  }
  createCancelEvent(error2, path5) {
    if (this.callbackContext.hasCancelCallback) {
      return new CancelEvent(this, error2, path5);
    } else {
      return null;
    }
  }
  matches(other) {
    if (!(other instanceof ValueEventRegistration)) {
      return false;
    } else if (!other.callbackContext || !this.callbackContext) {
      return true;
    } else {
      return other.callbackContext.matches(this.callbackContext);
    }
  }
  hasAnyCallback() {
    return this.callbackContext !== null;
  }
}
syncPointSetReferenceConstructor(ReferenceImpl);
syncTreeSetReferenceConstructor(ReferenceImpl);
var FIREBASE_DATABASE_EMULATOR_HOST_VAR = "FIREBASE_DATABASE_EMULATOR_HOST";
var repos = {};
var useRestClient = false;

class Database {
  constructor(_repoInternal, app2) {
    this._repoInternal = _repoInternal;
    this.app = app2;
    this["type"] = "database";
    this._instanceStarted = false;
  }
  get _repo() {
    if (!this._instanceStarted) {
      repoStart(this._repoInternal, this.app.options.appId, this.app.options["databaseAuthVariableOverride"]);
      this._instanceStarted = true;
    }
    return this._repoInternal;
  }
  get _root() {
    if (!this._rootInternal) {
      this._rootInternal = new ReferenceImpl(this._repo, newEmptyPath());
    }
    return this._rootInternal;
  }
  _delete() {
    if (this._rootInternal !== null) {
      repoManagerDeleteRepo(this._repo, this.app.name);
      this._repoInternal = null;
      this._rootInternal = null;
    }
    return Promise.resolve();
  }
  _checkNotDeleted(apiName) {
    if (this._rootInternal === null) {
      fatal("Cannot call " + apiName + " on a deleted database.");
    }
  }
}
PersistentConnection.prototype.simpleListen = function(pathString, onComplete) {
  this.sendRequest("q", { p: pathString }, onComplete);
};
PersistentConnection.prototype.echo = function(data, onEcho) {
  this.sendRequest("echo", { d: data }, onEcho);
};
setWebSocketImpl(import_faye_websocket.default.Client);
registerDatabase("node");
// node_modules/firebase/app/dist/index.mjs
var name3 = "firebase";
var version4 = "9.23.0";
registerVersion(name3, version4, "app");

// src/database/firebase.ts
var firebaseClient = initializeApp({
  projectId: FIREBASE_PROJECT_ID,
  databaseURL: "https://hacker-news.firebaseio.com"
});
var database3 = getDatabase(firebaseClient);

// src/database/loaders/user.ts
var import_dataloader = __toESM(require_dataloader(), 1);
async function getUserRaw(username) {
  const usersRef = ref(database3, "/v0/user");
  const userRef = child(usersRef, username);
  const user = await get(userRef);
  return user.val();
}
async function getUser(username) {
  const user = await getUserRaw(username);
  if (!user) {
    throw new Error(`No user found with username: ${username}`);
  }
  return {
    username: user.id,
    createdAt: new Date(user.created * 1000).toISOString(),
    submission_ids: user.submitted,
    about: user.about,
    karma: user.karma
  };
}
async function getUsers(usernames) {
  const users = await Promise.all(usernames.map(async (username) => {
    try {
      const user = await getUser(username);
      return user;
    } catch (error2) {
      return new Error(error2?.message);
    }
  }));
  return users;
}
var userLoader = new import_dataloader.default(getUsers, {
  batchScheduleFn: (callback) => setTimeout(callback, 500)
});
// src/database/loaders/item.ts
var import_dataloader2 = __toESM(require_dataloader(), 1);
async function getItemRaw(id) {
  const itemsRef = ref(database3, "v0/item");
  const itemRef = child(itemsRef, String(id));
  const item = await get(itemRef);
  return item.val();
}
async function getItem(id) {
  const item = await getItemRaw(id);
  if (!item) {
    throw new Error(`No item found with id: ${id}`);
  }
  return {
    id: item.id,
    title: item.title,
    url: item.url,
    createdAt: new Date(item.time * 1000).toISOString(),
    text: item.text,
    children_ids: item.kids,
    score: item.score,
    dead: item.dead,
    by: item.by,
    deleted: item.deleted,
    descendants: item.descendants,
    poll: item.poll,
    parent_id: item.parent,
    parts: item.parts,
    type: item.type?.toUpperCase()
  };
}
async function getItems(ids) {
  const items = await Promise.all(ids.map(async (id) => {
    try {
      const item = await getItem(id);
      return item;
    } catch (error2) {
      return new Error(error2?.message);
    }
  }));
  return items;
}
var itemLoader = new import_dataloader2.default(getItems, {
  batchScheduleFn: (callback) => setTimeout(callback, 200)
});
// src/database/loaders/story_page.ts
var import_dataloader3 = __toESM(require_dataloader(), 1);

// src/database/util.ts
function getStoryPagePath(name4) {
  const storyPagePath = STORY_PAGES[name4];
  if (!storyPagePath) {
    throw new Error(`No page found with name: ${name4}`);
  }
  return storyPagePath;
}
var STORY_PAGES = {
  TOP: "topstories",
  NEW: "newstories",
  ASK: "askstories",
  SHOW: "showstories",
  JOB: "jobstories",
  BEST: "beststories"
};

// src/database/loaders/story_page.ts
async function getStoryPageRaw(name4) {
  const rootRef = ref(database3, "/v0");
  const storyPagePath = getStoryPagePath(name4);
  const storyPageRef = child(rootRef, storyPagePath);
  const storyPage = await get(storyPageRef);
  return storyPage.val();
}
async function getStoryPage(name4) {
  const page = await getStoryPageRaw(name4);
  return page;
}
async function getStoryPages(names) {
  const pages = await Promise.all(names.map(async (name4) => {
    try {
      const page = await getStoryPage(name4);
      return page;
    } catch (error2) {
      return new Error(error2?.message);
    }
  }));
  return pages;
}
var storyPageLoader = new import_dataloader3.default(getStoryPages, {
  batchScheduleFn: (callback) => setTimeout(callback, 500)
});
// src/schema/models.ts
var ItemEnum = enumType({
  name: "ItemEnum",
  members: ["COMMENT", "JOB", "STORY", "POLL", "POLLOPT"],
  description: "Type of items on hackernews."
});
var StoryPageEnum = enumType({
  name: "StoryPageEnum",
  members: ["NEW", "TOP", "BEST", "ASK", "JOB", "SHOW"],
  description: "Type of story page on hackernews."
});
var User = objectType({
  name: "User",
  definition(t) {
    t.nonNull.string("username");
    t.nonNull.string("createdAt");
    t.string("about");
    t.nonNull.int("karma");
    t.list.nonNull.int("submission_ids");
    t.field("submissions", {
      type: list(Item),
      async resolve(root) {
        if (!root.submission_ids?.length) {
          return [];
        }
        const results = await itemLoader.loadMany(root.submission_ids);
        return results.map((item2) => item2 instanceof Error ? null : item2);
      }
    });
  }
});
var Item = objectType({
  name: "Item",
  definition(t) {
    t.nonNull.int("id");
    t.boolean("deleted");
    t.string("by");
    t.nonNull.string("createdAt");
    t.string("text");
    t.boolean("dead");
    t.int("parent_id");
    t.field("parent", {
      type: Item,
      async resolve(root) {
        return root.parent_id ? itemLoader.load(root.parent_id) : null;
      }
    });
    t.string("poll");
    t.list.nonNull.int("children_ids");
    t.field("children", {
      type: list(Item),
      async resolve(root) {
        if (!root.children_ids?.length) {
          return [];
        }
        const results = await itemLoader.loadMany(root.children_ids);
        return results.map((item2) => item2 instanceof Error ? null : item2);
      }
    });
    t.string("url");
    t.nonNull.int("score");
    t.field("type", {
      type: ItemEnum
    });
    t.field("author", {
      type: User,
      async resolve(root) {
        return root.by ? userLoader.load(root.by) : null;
      }
    });
    t.string("title");
    t.list.string("parts");
    t.int("descendants");
  }
});

// src/schema/root.ts
var Query = queryType({
  definition(t) {
    t.field("user", {
      type: User,
      args: {
        username: nonNull(stringArg({
          description: "username of the user."
        }))
      },
      async resolve(root, { username }, ctx) {
        const user2 = await userLoader.load(username);
        return user2;
      }
    });
    t.field("item", {
      type: Item,
      args: {
        id: nonNull(intArg())
      },
      async resolve(root, { id }, ctx) {
        const item2 = await itemLoader.load(id);
        return item2;
      }
    });
    t.field("storyPage", {
      type: StoryPageEnum,
      args: {
        name: nonNull(StoryPageEnum)
      },
      async resolve(root, { name: name4 }, ctx) {
        return storyPageLoader.load(name4);
      }
    });
  }
});
var Subscribe = subscriptionType({
  definition(t) {
    t.boolean("truths", {
      subscribe() {
        return async function* () {
          while (true) {
            await new Promise((res) => setTimeout(res, 1000));
            yield Math.random() > 0.5;
          }
        }();
      },
      resolve(eventData) {
        return eventData;
      }
    });
  }
});

// src/schema/mod.ts
var schema3 = makeSchema({
  types: [Query, Subscribe, User, Item, ItemEnum, StoryPageEnum],
  outputs: {
    typegen: join5(NEXUS_GENERATED_DIRECTORY, "index.d.ts"),
    schema: join5(NEXUS_GENERATED_DIRECTORY, "schema.graphql")
  }
});

// node_modules/@graphql-tools/utils/esm/errors.js
var isGraphQLErrorLike = function(error2) {
  return error2 != null && typeof error2 === "object" && Object.keys(error2).every((key) => possibleGraphQLErrorProperties.includes(key));
};
function createGraphQLError(message, options) {
  if (options?.originalError && !(options.originalError instanceof Error) && isGraphQLErrorLike(options.originalError)) {
    options.originalError = createGraphQLError(options.originalError.message, options.originalError);
  }
  if (versionInfo.major >= 17) {
    return new GraphQLError(message, options);
  }
  return new GraphQLError(message, options?.nodes, options?.source, options?.positions, options?.path, options?.originalError, options?.extensions);
}
var possibleGraphQLErrorProperties = [
  "message",
  "locations",
  "path",
  "nodes",
  "source",
  "positions",
  "originalError",
  "name",
  "stack",
  "extensions"
];

// node_modules/@graphql-tools/utils/esm/inspect.js
function inspect25(value) {
  return formatValue2(value, []);
}
var formatValue2 = function(value, seenValues) {
  switch (typeof value) {
    case "string":
      return JSON.stringify(value);
    case "function":
      return value.name ? `[function ${value.name}]` : "[function]";
    case "object":
      return formatObjectValue2(value, seenValues);
    default:
      return String(value);
  }
};
var formatError2 = function(value) {
  if (value instanceof GraphQLError) {
    return value.toString();
  }
  return `${value.name}: ${value.message};\n ${value.stack}`;
};
var formatObjectValue2 = function(value, previouslySeenValues) {
  if (value === null) {
    return "null";
  }
  if (value instanceof Error) {
    if (value.name === "AggregateError") {
      return formatError2(value) + "\n" + formatArray2(value.errors, previouslySeenValues);
    }
    return formatError2(value);
  }
  if (previouslySeenValues.includes(value)) {
    return "[Circular]";
  }
  const seenValues = [...previouslySeenValues, value];
  if (isJSONable2(value)) {
    const jsonValue = value.toJSON();
    if (jsonValue !== value) {
      return typeof jsonValue === "string" ? jsonValue : formatValue2(jsonValue, seenValues);
    }
  } else if (Array.isArray(value)) {
    return formatArray2(value, seenValues);
  }
  return formatObject2(value, seenValues);
};
var isJSONable2 = function(value) {
  return typeof value.toJSON === "function";
};
var formatObject2 = function(object, seenValues) {
  const entries = Object.entries(object);
  if (entries.length === 0) {
    return "{}";
  }
  if (seenValues.length > MAX_RECURSIVE_DEPTH2) {
    return "[" + getObjectTag2(object) + "]";
  }
  const properties = entries.map(([key, value]) => key + ": " + formatValue2(value, seenValues));
  return "{ " + properties.join(", ") + " }";
};
var formatArray2 = function(array, seenValues) {
  if (array.length === 0) {
    return "[]";
  }
  if (seenValues.length > MAX_RECURSIVE_DEPTH2) {
    return "[Array]";
  }
  const len = array.length;
  const items = [];
  for (let i = 0;i < len; ++i) {
    items.push(formatValue2(array[i], seenValues));
  }
  return "[" + items.join(", ") + "]";
};
var getObjectTag2 = function(object) {
  const tag = Object.prototype.toString.call(object).replace(/^\[object /, "").replace(/]$/, "");
  if (tag === "Object" && typeof object.constructor === "function") {
    const name4 = object.constructor.name;
    if (typeof name4 === "string" && name4 !== "") {
      return name4;
    }
  }
  return tag;
};
var MAX_RECURSIVE_DEPTH2 = 3;

// node_modules/@graphql-tools/utils/esm/jsutils.js
function isIterableObject4(value) {
  return value != null && typeof value === "object" && (Symbol.iterator in value);
}
function isObjectLike10(value) {
  return typeof value === "object" && value !== null;
}
function isPromise3(value) {
  return value?.then != null;
}
function promiseReduce(values2, callbackFn, initialValue) {
  let accumulator = initialValue;
  for (const value of values2) {
    accumulator = isPromise3(accumulator) ? accumulator.then((resolved) => callbackFn(resolved, value)) : callbackFn(accumulator, value);
  }
  return accumulator;
}
function hasOwnProperty2(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

// node_modules/@graphql-tools/utils/esm/getArgumentValues.js
function getArgumentValues2(def, node, variableValues = {}) {
  const coercedValues = {};
  const argumentNodes = node.arguments ?? [];
  const argNodeMap = argumentNodes.reduce((prev, arg2) => ({
    ...prev,
    [arg2.name.value]: arg2
  }), {});
  for (const { name: name4, type: argType, defaultValue } of def.args) {
    const argumentNode = argNodeMap[name4];
    if (!argumentNode) {
      if (defaultValue !== undefined) {
        coercedValues[name4] = defaultValue;
      } else if (isNonNullType(argType)) {
        throw createGraphQLError(`Argument "${name4}" of required type "${inspect25(argType)}" ` + "was not provided.", {
          nodes: [node]
        });
      }
      continue;
    }
    const valueNode = argumentNode.value;
    let isNull = valueNode.kind === Kind.NULL;
    if (valueNode.kind === Kind.VARIABLE) {
      const variableName = valueNode.name.value;
      if (variableValues == null || !hasOwnProperty2(variableValues, variableName)) {
        if (defaultValue !== undefined) {
          coercedValues[name4] = defaultValue;
        } else if (isNonNullType(argType)) {
          throw createGraphQLError(`Argument "${name4}" of required type "${inspect25(argType)}" ` + `was provided the variable "\$${variableName}" which was not provided a runtime value.`, {
            nodes: [valueNode]
          });
        }
        continue;
      }
      isNull = variableValues[variableName] == null;
    }
    if (isNull && isNonNullType(argType)) {
      throw createGraphQLError(`Argument "${name4}" of non-null type "${inspect25(argType)}" ` + "must not be null.", {
        nodes: [valueNode]
      });
    }
    const coercedValue = valueFromAST(valueNode, argType, variableValues);
    if (coercedValue === undefined) {
      throw createGraphQLError(`Argument "${name4}" has invalid value ${print(valueNode)}.`, {
        nodes: [valueNode]
      });
    }
    coercedValues[name4] = coercedValue;
  }
  return coercedValues;
}

// node_modules/@graphql-tools/utils/esm/memoize.js
function memoize1(fn) {
  const memoize1cache = new WeakMap;
  return function memoized(a1) {
    const cachedValue = memoize1cache.get(a1);
    if (cachedValue === undefined) {
      const newValue = fn(a1);
      memoize1cache.set(a1, newValue);
      return newValue;
    }
    return cachedValue;
  };
}
function memoize33(fn) {
  const memoize3Cache = new WeakMap;
  return function memoized(a1, a2, a3) {
    let cache2 = memoize3Cache.get(a1);
    if (!cache2) {
      cache2 = new WeakMap;
      memoize3Cache.set(a1, cache2);
      const cache32 = new WeakMap;
      cache2.set(a2, cache32);
      const newValue = fn(a1, a2, a3);
      cache32.set(a3, newValue);
      return newValue;
    }
    let cache3 = cache2.get(a2);
    if (!cache3) {
      cache3 = new WeakMap;
      cache2.set(a2, cache3);
      const newValue = fn(a1, a2, a3);
      cache3.set(a3, newValue);
      return newValue;
    }
    const cachedValue = cache3.get(a3);
    if (cachedValue === undefined) {
      const newValue = fn(a1, a2, a3);
      cache3.set(a3, newValue);
      return newValue;
    }
    return cachedValue;
  };
}
function memoize5(fn) {
  const memoize5Cache = new WeakMap;
  return function memoized(a1, a2, a3, a4, a5) {
    let cache2 = memoize5Cache.get(a1);
    if (!cache2) {
      cache2 = new WeakMap;
      memoize5Cache.set(a1, cache2);
      const cache32 = new WeakMap;
      cache2.set(a2, cache32);
      const cache42 = new WeakMap;
      cache32.set(a3, cache42);
      const cache52 = new WeakMap;
      cache42.set(a4, cache52);
      const newValue = fn(a1, a2, a3, a4, a5);
      cache52.set(a5, newValue);
      return newValue;
    }
    let cache3 = cache2.get(a2);
    if (!cache3) {
      cache3 = new WeakMap;
      cache2.set(a2, cache3);
      const cache42 = new WeakMap;
      cache3.set(a3, cache42);
      const cache52 = new WeakMap;
      cache42.set(a4, cache52);
      const newValue = fn(a1, a2, a3, a4, a5);
      cache52.set(a5, newValue);
      return newValue;
    }
    let cache4 = cache3.get(a3);
    if (!cache4) {
      cache4 = new WeakMap;
      cache3.set(a3, cache4);
      const cache52 = new WeakMap;
      cache4.set(a4, cache52);
      const newValue = fn(a1, a2, a3, a4, a5);
      cache52.set(a5, newValue);
      return newValue;
    }
    let cache5 = cache4.get(a4);
    if (!cache5) {
      cache5 = new WeakMap;
      cache4.set(a4, cache5);
      const newValue = fn(a1, a2, a3, a4, a5);
      cache5.set(a5, newValue);
      return newValue;
    }
    const cachedValue = cache5.get(a5);
    if (cachedValue === undefined) {
      const newValue = fn(a1, a2, a3, a4, a5);
      cache5.set(a5, newValue);
      return newValue;
    }
    return cachedValue;
  };
}

// node_modules/@graphql-tools/utils/esm/rootTypes.js
function getDefinedRootType(schema4, operation, nodes) {
  const rootTypeMap = getRootTypeMap(schema4);
  const rootType = rootTypeMap.get(operation);
  if (rootType == null) {
    throw createGraphQLError(`Schema is not configured to execute ${operation} operation.`, {
      nodes
    });
  }
  return rootType;
}
var getRootTypeNames = memoize1(function getRootTypeNames2(schema4) {
  const rootTypes = getRootTypes(schema4);
  return new Set([...rootTypes].map((type) => type.name));
});
var getRootTypes = memoize1(function getRootTypes2(schema4) {
  const rootTypeMap = getRootTypeMap(schema4);
  return new Set(rootTypeMap.values());
});
var getRootTypeMap = memoize1(function getRootTypeMap2(schema4) {
  const rootTypeMap = new Map;
  const queryType3 = schema4.getQueryType();
  if (queryType3) {
    rootTypeMap.set("query", queryType3);
  }
  const mutationType3 = schema4.getMutationType();
  if (mutationType3) {
    rootTypeMap.set("mutation", mutationType3);
  }
  const subscriptionType3 = schema4.getSubscriptionType();
  if (subscriptionType3) {
    rootTypeMap.set("subscription", subscriptionType3);
  }
  return rootTypeMap;
});

// node_modules/@graphql-tools/utils/esm/mapAsyncIterator.js
function mapAsyncIterator(iterator, callback, rejectCallback) {
  let $return;
  let abruptClose;
  if (typeof iterator.return === "function") {
    $return = iterator.return;
    abruptClose = (error2) => {
      const rethrow = () => Promise.reject(error2);
      return $return.call(iterator).then(rethrow, rethrow);
    };
  }
  function mapResult(result) {
    return result.done ? result : asyncMapValue(result.value, callback).then(iteratorResult, abruptClose);
  }
  let mapReject;
  if (rejectCallback) {
    const reject = rejectCallback;
    mapReject = (error2) => asyncMapValue(error2, reject).then(iteratorResult, abruptClose);
  }
  return {
    next() {
      return iterator.next().then(mapResult, mapReject);
    },
    return() {
      return $return ? $return.call(iterator).then(mapResult, mapReject) : Promise.resolve({ value: undefined, done: true });
    },
    throw(error2) {
      if (typeof iterator.throw === "function") {
        return iterator.throw(error2).then(mapResult, mapReject);
      }
      return Promise.reject(error2).catch(abruptClose);
    },
    [Symbol.asyncIterator]() {
      return this;
    }
  };
}
var asyncMapValue = function(value, callback) {
  return new Promise((resolve) => resolve(callback(value)));
};
var iteratorResult = function(value) {
  return { value, done: false };
};

// node_modules/@graphql-tools/utils/esm/AccumulatorMap.js
class AccumulatorMap extends Map {
  get [Symbol.toStringTag]() {
    return "AccumulatorMap";
  }
  add(key, item2) {
    const group = this.get(key);
    if (group === undefined) {
      this.set(key, [item2]);
    } else {
      group.push(item2);
    }
  }
}

// node_modules/@graphql-tools/utils/esm/directives.js
var GraphQLDeferDirective = new GraphQLDirective({
  name: "defer",
  description: "Directs the executor to defer this fragment when the `if` argument is true or undefined.",
  locations: [DirectiveLocation.FRAGMENT_SPREAD, DirectiveLocation.INLINE_FRAGMENT],
  args: {
    if: {
      type: new GraphQLNonNull(GraphQLBoolean),
      description: "Deferred when true or undefined.",
      defaultValue: true
    },
    label: {
      type: GraphQLString,
      description: "Unique name"
    }
  }
});
var GraphQLStreamDirective = new GraphQLDirective({
  name: "stream",
  description: "Directs the executor to stream plural fields when the `if` argument is true or undefined.",
  locations: [DirectiveLocation.FIELD],
  args: {
    if: {
      type: new GraphQLNonNull(GraphQLBoolean),
      description: "Stream when true or undefined.",
      defaultValue: true
    },
    label: {
      type: GraphQLString,
      description: "Unique name"
    },
    initialCount: {
      defaultValue: 0,
      type: GraphQLInt,
      description: "Number of items to return immediately"
    }
  }
});

// node_modules/@graphql-tools/utils/esm/collectFields.js
var collectFieldsImpl2 = function(schema4, fragments, variableValues, runtimeType, selectionSet, fields, patches, visitedFragmentNames) {
  for (const selection of selectionSet.selections) {
    switch (selection.kind) {
      case Kind.FIELD: {
        if (!shouldIncludeNode2(variableValues, selection)) {
          continue;
        }
        fields.add(getFieldEntryKey2(selection), selection);
        break;
      }
      case Kind.INLINE_FRAGMENT: {
        if (!shouldIncludeNode2(variableValues, selection) || !doesFragmentConditionMatch2(schema4, selection, runtimeType)) {
          continue;
        }
        const defer = getDeferValues(variableValues, selection);
        if (defer) {
          const patchFields = new AccumulatorMap;
          collectFieldsImpl2(schema4, fragments, variableValues, runtimeType, selection.selectionSet, patchFields, patches, visitedFragmentNames);
          patches.push({
            label: defer.label,
            fields: patchFields
          });
        } else {
          collectFieldsImpl2(schema4, fragments, variableValues, runtimeType, selection.selectionSet, fields, patches, visitedFragmentNames);
        }
        break;
      }
      case Kind.FRAGMENT_SPREAD: {
        const fragName = selection.name.value;
        if (!shouldIncludeNode2(variableValues, selection)) {
          continue;
        }
        const defer = getDeferValues(variableValues, selection);
        if (visitedFragmentNames.has(fragName) && !defer) {
          continue;
        }
        const fragment = fragments[fragName];
        if (!fragment || !doesFragmentConditionMatch2(schema4, fragment, runtimeType)) {
          continue;
        }
        if (!defer) {
          visitedFragmentNames.add(fragName);
        }
        if (defer) {
          const patchFields = new AccumulatorMap;
          collectFieldsImpl2(schema4, fragments, variableValues, runtimeType, fragment.selectionSet, patchFields, patches, visitedFragmentNames);
          patches.push({
            label: defer.label,
            fields: patchFields
          });
        } else {
          collectFieldsImpl2(schema4, fragments, variableValues, runtimeType, fragment.selectionSet, fields, patches, visitedFragmentNames);
        }
        break;
      }
    }
  }
};
function collectFields4(schema4, fragments, variableValues, runtimeType, selectionSet) {
  const fields = new AccumulatorMap;
  const patches = [];
  collectFieldsImpl2(schema4, fragments, variableValues, runtimeType, selectionSet, fields, patches, new Set);
  return { fields, patches };
}
function shouldIncludeNode2(variableValues, node) {
  const skip = getDirectiveValues(GraphQLSkipDirective, node, variableValues);
  if (skip?.["if"] === true) {
    return false;
  }
  const include = getDirectiveValues(GraphQLIncludeDirective, node, variableValues);
  if (include?.["if"] === false) {
    return false;
  }
  return true;
}
function doesFragmentConditionMatch2(schema4, fragment, type) {
  const typeConditionNode = fragment.typeCondition;
  if (!typeConditionNode) {
    return true;
  }
  const conditionalType = typeFromAST(schema4, typeConditionNode);
  if (conditionalType === type) {
    return true;
  }
  if (isAbstractType(conditionalType)) {
    const possibleTypes = schema4.getPossibleTypes(conditionalType);
    return possibleTypes.includes(type);
  }
  return false;
}
function getFieldEntryKey2(node) {
  return node.alias ? node.alias.value : node.name.value;
}
function getDeferValues(variableValues, node) {
  const defer = getDirectiveValues(GraphQLDeferDirective, node, variableValues);
  if (!defer) {
    return;
  }
  if (defer["if"] === false) {
    return;
  }
  return {
    label: typeof defer["label"] === "string" ? defer["label"] : undefined
  };
}
var collectSubFields = memoize5(function collectSubfields3(schema4, fragments, variableValues, returnType, fieldNodes) {
  const subFieldNodes = new AccumulatorMap;
  const visitedFragmentNames = new Set;
  const subPatches = [];
  const subFieldsAndPatches = {
    fields: subFieldNodes,
    patches: subPatches
  };
  for (const node of fieldNodes) {
    if (node.selectionSet) {
      collectFieldsImpl2(schema4, fragments, variableValues, returnType, node.selectionSet, subFieldNodes, subPatches, visitedFragmentNames);
    }
  }
  return subFieldsAndPatches;
});

// node_modules/@graphql-tools/utils/esm/isAsyncIterable.js
function isAsyncIterable(value) {
  return value?.[Symbol.asyncIterator] != null;
}

// node_modules/@graphql-tools/utils/esm/Path.js
function addPath2(prev, key, typename) {
  return { prev, key, typename };
}
function pathToArray3(path5) {
  const flattened = [];
  let curr = path5;
  while (curr) {
    flattened.push(curr.key);
    curr = curr.prev;
  }
  return flattened.reverse();
}
function printPathArray3(path5) {
  return path5.map((key) => typeof key === "number" ? "[" + key.toString() + "]" : "." + key).join("");
}

// node_modules/graphql-yoga/esm/error.js
var isAggregateError = function(obj) {
  return obj != null && typeof obj === "object" && ("errors" in obj);
};
var hasToString = function(obj) {
  return obj != null && typeof obj.toString === "function";
};
function isGraphQLError(val) {
  return val instanceof GraphQLError;
}
function isOriginalGraphQLError(val) {
  if (val instanceof GraphQLError) {
    if (val.originalError != null) {
      return isOriginalGraphQLError(val.originalError);
    }
    return true;
  }
  return false;
}
function handleError(error2, maskedErrorsOpts, logger5) {
  const errors3 = new Set;
  if (isAggregateError(error2)) {
    for (const singleError of error2.errors) {
      const handledErrors = handleError(singleError, maskedErrorsOpts, logger5);
      for (const handledError of handledErrors) {
        errors3.add(handledError);
      }
    }
  } else if (maskedErrorsOpts) {
    const maskedError = maskedErrorsOpts.maskError(error2, maskedErrorsOpts.errorMessage, maskedErrorsOpts.isDev);
    if (maskedError !== error2) {
      logger5.error(error2);
    }
    errors3.add(isGraphQLError(maskedError) ? maskedError : createGraphQLError(maskedError.message, {
      originalError: maskedError
    }));
  } else if (isGraphQLError(error2)) {
    errors3.add(error2);
  } else if (error2 instanceof Error) {
    errors3.add(createGraphQLError(error2.message, {
      originalError: error2
    }));
  } else if (typeof error2 === "string") {
    errors3.add(createGraphQLError(error2, {
      extensions: {
        unexpected: true
      }
    }));
  } else if (hasToString(error2)) {
    errors3.add(createGraphQLError(error2.toString(), {
      extensions: {
        unexpected: true
      }
    }));
  } else {
    logger5.error(error2);
    errors3.add(createGraphQLError("Unexpected error.", {
      extensions: {
        http: {
          unexpected: true
        }
      }
    }));
  }
  return Array.from(errors3);
}
function getResponseInitByRespectingErrors(result, headers = {}, isApplicationJson = false) {
  let status;
  let unexpectedErrorExists = false;
  if (("extensions" in result) && result.extensions?.http) {
    if (result.extensions.http.headers) {
      Object.assign(headers, result.extensions.http.headers);
    }
    if (result.extensions.http.status) {
      status = result.extensions.http.status;
    }
  }
  if (("errors" in result) && result.errors?.length) {
    for (const error2 of result.errors) {
      if (error2.extensions?.http) {
        if (error2.extensions.http.headers) {
          Object.assign(headers, error2.extensions.http.headers);
        }
        if (isApplicationJson && error2.extensions.http.spec) {
          continue;
        }
        if (error2.extensions.http.status && (!status || error2.extensions.http.status > status)) {
          status = error2.extensions.http.status;
        }
      } else if (!isOriginalGraphQLError(error2) || error2.extensions?.unexpected) {
        unexpectedErrorExists = true;
      }
    }
  } else {
    status ||= 200;
  }
  if (!status) {
    if (unexpectedErrorExists && !("data" in result)) {
      status = 500;
    } else {
      status = 200;
    }
  }
  return {
    status,
    headers
  };
}
function areGraphQLErrors(obj) {
  return Array.isArray(obj) && obj.length > 0 && obj.some(isGraphQLError);
}

// node_modules/@graphql-yoga/logger/esm/index.js
var ansiCodes = {
  red: "\x1B[31m",
  yellow: "\x1B[33m",
  magenta: "\x1B[35m",
  cyan: "\x1B[36m",
  reset: "\x1B[0m"
};
var warnPrefix = ansiCodes.yellow + "WARN" + ansiCodes.reset;
var infoPrefix = ansiCodes.cyan + "INFO" + ansiCodes.reset;
var errorPrefix2 = ansiCodes.red + "ERR" + ansiCodes.reset;
var debugPrefix = ansiCodes.magenta + "DEBUG" + ansiCodes.reset;
var logLevelScores = {
  debug: 0,
  info: 1,
  warn: 2,
  error: 3,
  silent: 4
};
var noop = () => {
};
var consoleLog = (prefix) => (...args7) => console.log(prefix, ...args7);
var debugLog = console.debug ? (...args7) => console.debug(debugPrefix, ...args7) : consoleLog(debugPrefix);
var infoLog = console.info ? (...args7) => console.info(infoPrefix, ...args7) : consoleLog(infoPrefix);
var warnLog = console.warn ? (...args7) => console.warn(warnPrefix, ...args7) : consoleLog(warnPrefix);
var errorLog = console.error ? (...args7) => console.error(errorPrefix2, ...args7) : consoleLog(errorPrefix2);
var createLogger = (logLevel = globalThis.process?.env["DEBUG"] === "1" ? "debug" : "info") => {
  const score = logLevelScores[logLevel];
  return {
    debug: score > logLevelScores.debug ? noop : debugLog,
    info: score > logLevelScores.info ? noop : infoLog,
    warn: score > logLevelScores.warn ? noop : warnLog,
    error: score > logLevelScores.error ? noop : errorLog
  };
};

// node_modules/graphql-yoga/esm/graphiql-html.js
var graphiql_html_default = "<!doctype html><html lang=en><head><meta charset=utf-8><title>__TITLE__</title><link rel=icon href=https://raw.githubusercontent.com/dotansimha/graphql-yoga/main/website/public/favicon.ico><link rel=stylesheet href=https://unpkg.com/@graphql-yoga/graphiql@4.1.1/dist/style.css></head><body id=body class=no-focus-outline><noscript>You need to enable JavaScript to run this app.</noscript><div id=root></div><script type=module>import{renderYogaGraphiQL}from\"https://unpkg.com/@graphql-yoga/graphiql@4.1.1/dist/yoga-graphiql.es.js\";renderYogaGraphiQL(root,__OPTS__)</script></body></html>";

// node_modules/graphql-yoga/esm/plugins/use-graphiql.js
function shouldRenderGraphiQL({ headers, method }) {
  return method === "GET" && !!headers?.get("accept")?.includes("text/html");
}
function useGraphiQL(config) {
  const logger5 = config.logger ?? console;
  let graphiqlOptionsFactory;
  if (typeof config?.options === "function") {
    graphiqlOptionsFactory = config?.options;
  } else if (typeof config?.options === "object") {
    graphiqlOptionsFactory = () => config?.options;
  } else if (config?.options === false) {
    graphiqlOptionsFactory = () => false;
  } else {
    graphiqlOptionsFactory = () => ({});
  }
  const renderer = config?.render ?? renderGraphiQL;
  let urlPattern;
  const getUrlPattern = ({ URLPattern }) => {
    urlPattern ||= new URLPattern({
      pathname: config.graphqlEndpoint
    });
    return urlPattern;
  };
  return {
    async onRequest({ request, serverContext, fetchAPI, endResponse, url }) {
      if (shouldRenderGraphiQL(request) && (request.url.endsWith(config.graphqlEndpoint) || url.pathname === config.graphqlEndpoint || getUrlPattern(fetchAPI).test(url))) {
        logger5.debug(`Rendering GraphiQL`);
        const graphiqlOptions = await graphiqlOptionsFactory(request, serverContext);
        if (graphiqlOptions) {
          const graphiQLBody = await renderer({
            ...graphiqlOptions === true ? {} : graphiqlOptions
          });
          const response = new fetchAPI.Response(graphiQLBody, {
            headers: {
              "Content-Type": "text/html"
            },
            status: 200
          });
          endResponse(response);
        }
      }
    }
  };
}
var renderGraphiQL = (opts) => graphiql_html_default.replace("__TITLE__", opts?.title || "Yoga GraphiQL").replace("__OPTS__", JSON.stringify(opts ?? {}));

// node_modules/graphql-yoga/esm/plugins/use-schema.js
var useSchema = (schemaDef) => {
  if (schemaDef == null) {
    return {};
  }
  if (isSchema(schemaDef)) {
    return {
      onPluginInit({ setSchema }) {
        setSchema(schemaDef);
      }
    };
  }
  if ("then" in schemaDef) {
    let schema4;
    return {
      onRequestParse() {
        return {
          async onRequestParseDone() {
            schema4 ||= await schemaDef;
          }
        };
      },
      onEnveloped({ setSchema }) {
        if (!schema4) {
          throw new Error(`You provide a promise of a schema but it hasn't been resolved yet. Make sure you use this plugin with GraphQL Yoga.`);
        }
        setSchema(schema4);
      }
    };
  }
  const schemaByRequest = new WeakMap;
  return {
    onRequestParse({ request, serverContext }) {
      return {
        async onRequestParseDone() {
          const schema4 = await schemaDef({
            ...serverContext,
            request
          });
          schemaByRequest.set(request, schema4);
        }
      };
    },
    onEnveloped({ setSchema, context }) {
      if (context?.request == null) {
        throw new Error("Request object is not available in the context. Make sure you use this plugin with GraphQL Yoga.");
      }
      const schema4 = schemaByRequest.get(context.request);
      if (schema4 == null) {
        throw new Error(`No schema found for this request. Make sure you use this plugin with GraphQL Yoga.`);
      }
      setSchema(schema4);
    }
  };
};

// node_modules/@envelop/core/esm/document-string-map.js
var documentStringMap = new WeakMap;

// node_modules/@envelop/core/esm/utils.js
var getSubscribeArgs = function(args7) {
  return args7.length === 1 ? args7[0] : {
    schema: args7[0],
    document: args7[1],
    rootValue: args7[2],
    contextValue: args7[3],
    variableValues: args7[4],
    operationName: args7[5],
    fieldResolver: args7[6],
    subscribeFieldResolver: args7[7]
  };
};
function mapAsyncIterator2(source2, mapper) {
  const iterator = source2[Symbol.asyncIterator]();
  async function mapResult(result) {
    if (result.done) {
      return result;
    }
    try {
      return { value: await mapper(result.value), done: false };
    } catch (error2) {
      try {
        await iterator.return?.();
      } catch (_error) {
      }
      throw error2;
    }
  }
  const stream = {
    [Symbol.asyncIterator]() {
      return stream;
    },
    async next() {
      return await mapResult(await iterator.next());
    },
    async return() {
      const promise = iterator.return?.();
      return promise ? await mapResult(await promise) : { value: undefined, done: true };
    },
    async throw(error2) {
      const promise = iterator.throw?.();
      if (promise) {
        return await mapResult(await promise);
      }
      throw error2;
    }
  };
  return stream;
}
var getExecuteArgs = function(args7) {
  return args7.length === 1 ? args7[0] : {
    schema: args7[0],
    document: args7[1],
    rootValue: args7[2],
    contextValue: args7[3],
    variableValues: args7[4],
    operationName: args7[5],
    fieldResolver: args7[6],
    typeResolver: args7[7]
  };
};
function isAsyncIterable2(maybeAsyncIterable) {
  return typeof maybeAsyncIterable === "object" && maybeAsyncIterable != null && typeof maybeAsyncIterable[Symbol.asyncIterator] === "function";
}
function handleStreamOrSingleExecutionResult(payload, fn) {
  if (isAsyncIterable2(payload.result)) {
    return { onNext: fn };
  }
  fn({
    args: payload.args,
    result: payload.result,
    setResult: payload.setResult
  });
  return;
}
function finalAsyncIterator(source2, onFinal) {
  const iterator = source2[Symbol.asyncIterator]();
  let isDone = false;
  const stream = {
    [Symbol.asyncIterator]() {
      return stream;
    },
    async next() {
      const result = await iterator.next();
      if (result.done && isDone === false) {
        isDone = true;
        onFinal();
      }
      return result;
    },
    async return() {
      const promise = iterator.return?.();
      if (isDone === false) {
        isDone = true;
        onFinal();
      }
      return promise ? await promise : { done: true, value: undefined };
    },
    async throw(error2) {
      const promise = iterator.throw?.();
      if (promise) {
        return await promise;
      }
      throw error2;
    }
  };
  return stream;
}
function errorAsyncIterator(source2, onError) {
  const iterator = source2[Symbol.asyncIterator]();
  const stream = {
    [Symbol.asyncIterator]() {
      return stream;
    },
    async next() {
      try {
        return await iterator.next();
      } catch (error2) {
        onError(error2);
        return { done: true, value: undefined };
      }
    },
    async return() {
      const promise = iterator.return?.();
      return promise ? await promise : { done: true, value: undefined };
    },
    async throw(error2) {
      const promise = iterator.throw?.();
      if (promise) {
        return await promise;
      }
      throw error2;
    }
  };
  return stream;
}
var envelopIsIntrospectionSymbol = Symbol("ENVELOP_IS_INTROSPECTION");
var makeSubscribe = (subscribeFn) => (...polyArgs) => subscribeFn(getSubscribeArgs(polyArgs));
var makeExecute = (executeFn) => (...polyArgs) => executeFn(getExecuteArgs(polyArgs));

// node_modules/@envelop/core/esm/orchestrator.js
var throwEngineFunctionError = function(name4) {
  throw Error(`No \`${name4}\` function found! Register it using "useEngine" plugin.`);
};
function createEnvelopOrchestrator({ plugins: plugins4 }) {
  let schema4 = null;
  let initDone = false;
  const parse2 = () => throwEngineFunctionError("parse");
  const validate3 = () => throwEngineFunctionError("validate");
  const execute2 = () => throwEngineFunctionError("execute");
  const subscribe2 = () => throwEngineFunctionError("subscribe");
  const replaceSchema = (newSchema, ignorePluginIndex = -1) => {
    schema4 = newSchema;
    if (initDone) {
      for (const [i, plugin9] of plugins4.entries()) {
        if (i !== ignorePluginIndex) {
          plugin9.onSchemaChange && plugin9.onSchemaChange({
            schema: schema4,
            replaceSchema: (schemaToSet) => {
              replaceSchema(schemaToSet, i);
            }
          });
        }
      }
    }
  };
  const contextErrorHandlers = [];
  for (const [i, plugin9] of plugins4.entries()) {
    plugin9.onPluginInit && plugin9.onPluginInit({
      plugins: plugins4,
      addPlugin: (newPlugin) => {
        plugins4.push(newPlugin);
      },
      setSchema: (modifiedSchema) => replaceSchema(modifiedSchema, i),
      registerContextErrorHandler: (handler) => contextErrorHandlers.push(handler)
    });
  }
  const beforeCallbacks = {
    init: [],
    parse: [],
    validate: [],
    subscribe: [],
    execute: [],
    context: []
  };
  for (const { onContextBuilding, onExecute, onParse, onSubscribe, onValidate, onEnveloped } of plugins4) {
    onEnveloped && beforeCallbacks.init.push(onEnveloped);
    onContextBuilding && beforeCallbacks.context.push(onContextBuilding);
    onExecute && beforeCallbacks.execute.push(onExecute);
    onParse && beforeCallbacks.parse.push(onParse);
    onSubscribe && beforeCallbacks.subscribe.push(onSubscribe);
    onValidate && beforeCallbacks.validate.push(onValidate);
  }
  const init = (initialContext) => {
    for (const [i, onEnveloped] of beforeCallbacks.init.entries()) {
      onEnveloped({
        context: initialContext,
        extendContext: (extension) => {
          if (!initialContext) {
            return;
          }
          Object.assign(initialContext, extension);
        },
        setSchema: (modifiedSchema) => replaceSchema(modifiedSchema, i)
      });
    }
  };
  const customParse = beforeCallbacks.parse.length ? (initialContext) => (source2, parseOptions) => {
    let result = null;
    let parseFn = parse2;
    const context = initialContext;
    const afterCalls = [];
    for (const onParse of beforeCallbacks.parse) {
      const afterFn = onParse({
        context,
        extendContext: (extension) => {
          Object.assign(context, extension);
        },
        params: { source: source2, options: parseOptions },
        parseFn,
        setParseFn: (newFn) => {
          parseFn = newFn;
        },
        setParsedDocument: (newDoc) => {
          result = newDoc;
        }
      });
      afterFn && afterCalls.push(afterFn);
    }
    if (result === null) {
      try {
        result = parseFn(source2, parseOptions);
      } catch (e) {
        result = e;
      }
    }
    for (const afterCb of afterCalls) {
      afterCb({
        context,
        extendContext: (extension) => {
          Object.assign(context, extension);
        },
        replaceParseResult: (newResult) => {
          result = newResult;
        },
        result
      });
    }
    if (result === null) {
      throw new Error(`Failed to parse document.`);
    }
    if (result instanceof Error) {
      throw result;
    }
    documentStringMap.set(result, source2.toString());
    return result;
  } : () => parse2;
  const customValidate = beforeCallbacks.validate.length ? (initialContext) => (schema5, documentAST, rules, typeInfo, validationOptions) => {
    let actualRules = rules ? [...rules] : undefined;
    let validateFn = validate3;
    let result = null;
    const context = initialContext;
    const afterCalls = [];
    for (const onValidate of beforeCallbacks.validate) {
      const afterFn = onValidate({
        context,
        extendContext: (extension) => {
          Object.assign(context, extension);
        },
        params: {
          schema: schema5,
          documentAST,
          rules: actualRules,
          typeInfo,
          options: validationOptions
        },
        validateFn,
        addValidationRule: (rule) => {
          if (!actualRules) {
            actualRules = [];
          }
          actualRules.push(rule);
        },
        setValidationFn: (newFn) => {
          validateFn = newFn;
        },
        setResult: (newResults) => {
          result = newResults;
        }
      });
      afterFn && afterCalls.push(afterFn);
    }
    if (!result) {
      result = validateFn(schema5, documentAST, actualRules, typeInfo, validationOptions);
    }
    if (!result) {
      return;
    }
    const valid = result.length === 0;
    for (const afterCb of afterCalls) {
      afterCb({
        valid,
        result,
        context,
        extendContext: (extension) => {
          Object.assign(context, extension);
        },
        setResult: (newResult) => {
          result = newResult;
        }
      });
    }
    return result;
  } : () => validate3;
  const customContextFactory = beforeCallbacks.context.length ? (initialContext) => async (orchestratorCtx) => {
    const afterCalls = [];
    const context = initialContext;
    if (orchestratorCtx) {
      Object.assign(context, orchestratorCtx);
    }
    try {
      let isBreakingContextBuilding = false;
      for (const onContext of beforeCallbacks.context) {
        const afterHookResult = await onContext({
          context,
          extendContext: (extension) => {
            Object.assign(context, extension);
          },
          breakContextBuilding: () => {
            isBreakingContextBuilding = true;
          }
        });
        if (typeof afterHookResult === "function") {
          afterCalls.push(afterHookResult);
        }
        if (isBreakingContextBuilding === true) {
          break;
        }
      }
      for (const afterCb of afterCalls) {
        afterCb({
          context,
          extendContext: (extension) => {
            Object.assign(context, extension);
          }
        });
      }
      return context;
    } catch (err) {
      let error2 = err;
      for (const errorCb of contextErrorHandlers) {
        errorCb({
          context,
          error: error2,
          setError: (err2) => {
            error2 = err2;
          }
        });
      }
      throw error2;
    }
  } : (initialContext) => (orchestratorCtx) => {
    if (orchestratorCtx) {
      Object.assign(initialContext, orchestratorCtx);
    }
    return initialContext;
  };
  const useCustomSubscribe = beforeCallbacks.subscribe.length;
  const customSubscribe = useCustomSubscribe ? makeSubscribe(async (args7) => {
    let subscribeFn = subscribe2;
    const afterCalls = [];
    const subscribeErrorHandlers = [];
    const context = args7.contextValue || {};
    let result;
    for (const onSubscribe of beforeCallbacks.subscribe) {
      const after = await onSubscribe({
        subscribeFn,
        setSubscribeFn: (newSubscribeFn) => {
          subscribeFn = newSubscribeFn;
        },
        extendContext: (extension) => {
          Object.assign(context, extension);
        },
        args: args7,
        setResultAndStopExecution: (stopResult) => {
          result = stopResult;
        }
      });
      if (after) {
        if (after.onSubscribeResult) {
          afterCalls.push(after.onSubscribeResult);
        }
        if (after.onSubscribeError) {
          subscribeErrorHandlers.push(after.onSubscribeError);
        }
      }
      if (result !== undefined) {
        break;
      }
    }
    if (result === undefined) {
      result = await subscribeFn({
        ...args7,
        contextValue: context
      });
    }
    if (!result) {
      return;
    }
    const onNextHandler = [];
    const onEndHandler = [];
    for (const afterCb of afterCalls) {
      const hookResult = afterCb({
        args: args7,
        result,
        setResult: (newResult) => {
          result = newResult;
        }
      });
      if (hookResult) {
        if (hookResult.onNext) {
          onNextHandler.push(hookResult.onNext);
        }
        if (hookResult.onEnd) {
          onEndHandler.push(hookResult.onEnd);
        }
      }
    }
    if (onNextHandler.length && isAsyncIterable2(result)) {
      result = mapAsyncIterator2(result, async (result2) => {
        for (const onNext of onNextHandler) {
          await onNext({
            args: args7,
            result: result2,
            setResult: (newResult) => result2 = newResult
          });
        }
        return result2;
      });
    }
    if (onEndHandler.length && isAsyncIterable2(result)) {
      result = finalAsyncIterator(result, () => {
        for (const onEnd of onEndHandler) {
          onEnd();
        }
      });
    }
    if (subscribeErrorHandlers.length && isAsyncIterable2(result)) {
      result = errorAsyncIterator(result, (err) => {
        let error2 = err;
        for (const handler of subscribeErrorHandlers) {
          handler({
            error: error2,
            setError: (err2) => {
              error2 = err2;
            }
          });
        }
        throw error2;
      });
    }
    return result;
  }) : makeSubscribe(subscribe2);
  const useCustomExecute = beforeCallbacks.execute.length;
  const customExecute = useCustomExecute ? makeExecute(async (args7) => {
    let executeFn = execute2;
    let result;
    const afterCalls = [];
    const context = args7.contextValue || {};
    for (const onExecute of beforeCallbacks.execute) {
      const after = await onExecute({
        executeFn,
        setExecuteFn: (newExecuteFn) => {
          executeFn = newExecuteFn;
        },
        setResultAndStopExecution: (stopResult) => {
          result = stopResult;
        },
        extendContext: (extension) => {
          if (typeof extension === "object") {
            Object.assign(context, extension);
          } else {
            throw new Error(`Invalid context extension provided! Expected "object", got: "${JSON.stringify(extension)}" (${typeof extension})`);
          }
        },
        args: args7
      });
      if (after?.onExecuteDone) {
        afterCalls.push(after.onExecuteDone);
      }
      if (result !== undefined) {
        break;
      }
    }
    if (result === undefined) {
      result = await executeFn({
        ...args7,
        contextValue: context
      });
    }
    const onNextHandler = [];
    const onEndHandler = [];
    for (const afterCb of afterCalls) {
      const hookResult = await afterCb({
        args: args7,
        result,
        setResult: (newResult) => {
          result = newResult;
        }
      });
      if (hookResult) {
        if (hookResult.onNext) {
          onNextHandler.push(hookResult.onNext);
        }
        if (hookResult.onEnd) {
          onEndHandler.push(hookResult.onEnd);
        }
      }
    }
    if (onNextHandler.length && isAsyncIterable2(result)) {
      result = mapAsyncIterator2(result, async (result2) => {
        for (const onNext of onNextHandler) {
          await onNext({
            args: args7,
            result: result2,
            setResult: (newResult) => {
              result2 = newResult;
            }
          });
        }
        return result2;
      });
    }
    if (onEndHandler.length && isAsyncIterable2(result)) {
      result = finalAsyncIterator(result, () => {
        for (const onEnd of onEndHandler) {
          onEnd();
        }
      });
    }
    return result;
  }) : makeExecute(execute2);
  initDone = true;
  if (schema4) {
    for (const [i, plugin9] of plugins4.entries()) {
      plugin9.onSchemaChange && plugin9.onSchemaChange({
        schema: schema4,
        replaceSchema: (modifiedSchema) => replaceSchema(modifiedSchema, i)
      });
    }
  }
  return {
    getCurrentSchema() {
      return schema4;
    },
    init,
    parse: customParse,
    validate: customValidate,
    execute: customExecute,
    subscribe: customSubscribe,
    contextFactory: customContextFactory
  };
}

// node_modules/@envelop/core/esm/create.js
var notEmpty = function(value) {
  return value != null;
};
function envelop(options) {
  const plugins4 = options.plugins.filter(notEmpty);
  const orchestrator2 = createEnvelopOrchestrator({
    plugins: plugins4
  });
  const getEnveloped = (initialContext = {}) => {
    const typedOrchestrator = orchestrator2;
    typedOrchestrator.init(initialContext);
    return {
      parse: typedOrchestrator.parse(initialContext),
      validate: typedOrchestrator.validate(initialContext),
      contextFactory: typedOrchestrator.contextFactory(initialContext),
      execute: typedOrchestrator.execute,
      subscribe: typedOrchestrator.subscribe,
      schema: typedOrchestrator.getCurrentSchema()
    };
  };
  getEnveloped._plugins = plugins4;
  return getEnveloped;
}

// node_modules/@envelop/core/esm/plugins/use-masked-errors.js
function isGraphQLError2(error2) {
  return error2 instanceof Error && error2.name === "GraphQLError";
}
function isOriginalGraphQLError2(error2) {
  if (isGraphQLError2(error2)) {
    if (error2.originalError != null) {
      return isOriginalGraphQLError2(error2.originalError);
    }
    return true;
  }
  return false;
}
var createSerializableGraphQLError = function(message, originalError, isDev) {
  const error2 = new Error(message);
  error2.name = "GraphQLError";
  if (isDev) {
    const extensions3 = originalError instanceof Error ? { message: originalError.message, stack: originalError.stack } : { message: String(originalError) };
    Object.defineProperty(error2, "extensions", {
      get() {
        return extensions3;
      }
    });
  }
  Object.defineProperty(error2, "toJSON", {
    value() {
      return {
        message: error2.message,
        extensions: error2.extensions
      };
    }
  });
  return error2;
};
function useMaskedErrors(opts) {
  const maskError = opts?.maskError ?? defaultMaskError;
  const message = opts?.errorMessage || DEFAULT_ERROR_MESSAGE;
  const handleResult = makeHandleResult(maskError, message);
  return {
    onPluginInit(context) {
      context.registerContextErrorHandler(({ error: error2, setError }) => {
        setError(maskError(error2, message));
      });
    },
    onExecute() {
      return {
        onExecuteDone(payload) {
          return handleStreamOrSingleExecutionResult(payload, handleResult);
        }
      };
    },
    onSubscribe() {
      return {
        onSubscribeResult(payload) {
          return handleStreamOrSingleExecutionResult(payload, handleResult);
        },
        onSubscribeError({ error: error2, setError }) {
          setError(maskError(error2, message));
        }
      };
    }
  };
}
var DEFAULT_ERROR_MESSAGE = "Unexpected error.";
var createDefaultMaskError = (isDev) => (error2, message) => {
  if (isOriginalGraphQLError2(error2)) {
    return error2;
  }
  return createSerializableGraphQLError(message, error2, isDev);
};
var isDev = globalThis.process?.env?.NODE_ENV === "development";
var defaultMaskError = createDefaultMaskError(isDev);
var makeHandleResult = (maskError, message) => ({ result, setResult }) => {
  if (result.errors != null) {
    setResult({ ...result, errors: result.errors.map((error2) => maskError(error2, message)) });
  }
};

// node_modules/@envelop/core/esm/plugins/use-extend-context.js
var useExtendContext = (contextFactory) => ({
  async onContextBuilding({ context, extendContext }) {
    extendContext(await contextFactory(context));
  }
});

// node_modules/@envelop/core/esm/plugins/use-engine.js
var useEngine = (engine) => {
  return {
    onExecute: ({ setExecuteFn }) => {
      if (engine.execute) {
        setExecuteFn(engine.execute);
      }
    },
    onParse: ({ setParseFn }) => {
      if (engine.parse) {
        setParseFn(engine.parse);
      }
    },
    onValidate: ({ setValidationFn, addValidationRule }) => {
      if (engine.validate) {
        setValidationFn(engine.validate);
      }
      engine.specifiedRules?.map(addValidationRule);
    },
    onSubscribe: ({ setSubscribeFn }) => {
      if (engine.subscribe) {
        setSubscribeFn(engine.subscribe);
      }
    }
  };
};

// node_modules/value-or-promise/build/module/ValueOrPromise.js
var isPromiseLike2 = function(object) {
  return object != null && typeof object.then === "function";
};
var defaultOnRejectedFn = (reason) => {
  throw reason;
};

class ValueOrPromise {
  state;
  constructor(executor) {
    let value;
    try {
      value = executor();
    } catch (reason) {
      this.state = { status: "rejected", value: reason };
      return;
    }
    if (isPromiseLike2(value)) {
      this.state = { status: "pending", value };
      return;
    }
    this.state = { status: "fulfilled", value };
  }
  then(onFulfilled, onRejected) {
    const state = this.state;
    if (state.status === "pending") {
      return new ValueOrPromise(() => state.value.then(onFulfilled, onRejected));
    }
    const onRejectedFn = typeof onRejected === "function" ? onRejected : defaultOnRejectedFn;
    if (state.status === "rejected") {
      return new ValueOrPromise(() => onRejectedFn(state.value));
    }
    try {
      const onFulfilledFn = typeof onFulfilled === "function" ? onFulfilled : undefined;
      return onFulfilledFn === undefined ? new ValueOrPromise(() => state.value) : new ValueOrPromise(() => onFulfilledFn(state.value));
    } catch (e) {
      return new ValueOrPromise(() => onRejectedFn(e));
    }
  }
  catch(onRejected) {
    return this.then(undefined, onRejected);
  }
  resolve() {
    const state = this.state;
    if (state.status === "pending") {
      return Promise.resolve(state.value);
    }
    if (state.status === "rejected") {
      throw state.value;
    }
    return state.value;
  }
  static all(valueOrPromises) {
    let rejected = false;
    let reason;
    let containsPromise = false;
    const values2 = [];
    for (const valueOrPromise of valueOrPromises) {
      const state = valueOrPromise.state;
      if (state.status === "rejected") {
        if (rejected) {
          continue;
        }
        rejected = true;
        reason = state.value;
        continue;
      }
      if (state.status === "pending") {
        containsPromise = true;
      }
      values2.push(state.value);
    }
    if (containsPromise) {
      if (rejected) {
        Promise.all(values2).catch(() => {
        });
        return new ValueOrPromise(() => {
          throw reason;
        });
      }
      return new ValueOrPromise(() => Promise.all(values2));
    }
    return new ValueOrPromise(() => values2);
  }
}
// node_modules/@graphql-tools/executor/esm/execution/flattenAsyncIterable.js
function flattenAsyncIterable(iterable) {
  const topIterator = iterable[Symbol.asyncIterator]();
  let currentNestedIterator;
  let waitForCurrentNestedIterator;
  let done = false;
  async function next() {
    if (done) {
      return { value: undefined, done: true };
    }
    try {
      if (!currentNestedIterator) {
        if (waitForCurrentNestedIterator) {
          await waitForCurrentNestedIterator;
          return await next();
        }
        let resolve;
        waitForCurrentNestedIterator = new Promise((r) => {
          resolve = r;
        });
        const topIteratorResult = await topIterator.next();
        if (topIteratorResult.done) {
          done = true;
          return await next();
        }
        currentNestedIterator = topIteratorResult.value[Symbol.asyncIterator]();
        waitForCurrentNestedIterator = undefined;
        resolve();
        return await next();
      }
      const rememberCurrentNestedIterator = currentNestedIterator;
      const nestedIteratorResult = await currentNestedIterator.next();
      if (!nestedIteratorResult.done) {
        return nestedIteratorResult;
      }
      if (currentNestedIterator === rememberCurrentNestedIterator) {
        currentNestedIterator = undefined;
      }
      return await next();
    } catch (err) {
      done = true;
      throw err;
    }
  }
  return {
    next,
    async return() {
      done = true;
      await Promise.all([currentNestedIterator?.return?.(), topIterator.return?.()]);
      return { value: undefined, done: true };
    },
    async throw(error2) {
      done = true;
      await Promise.all([currentNestedIterator?.throw?.(error2), topIterator.throw?.(error2)]);
      throw error2;
    },
    [Symbol.asyncIterator]() {
      return this;
    }
  };
}

// node_modules/@graphql-tools/executor/esm/execution/invariant.js
function invariant12(condition, message) {
  if (!condition) {
    throw new Error(message != null ? message : "Unexpected invariant triggered.");
  }
}

// node_modules/@graphql-tools/executor/esm/execution/promiseForObject.js
async function promiseForObject(object, signal) {
  const resolvedObject = Object.create(null);
  await new Promise((resolve, reject) => {
    signal?.addEventListener("abort", () => {
      resolve();
    });
    Promise.all(Object.entries(object).map(async ([key, value]) => {
      resolvedObject[key] = await value;
    })).then(() => resolve(), reject);
  });
  return resolvedObject;
}

// node_modules/@graphql-tools/executor/esm/execution/values.js
function getVariableValues2(schema4, varDefNodes, inputs, options) {
  const errors3 = [];
  const maxErrors = options?.maxErrors;
  try {
    const coerced = coerceVariableValues(schema4, varDefNodes, inputs, (error2) => {
      if (maxErrors != null && errors3.length >= maxErrors) {
        throw createGraphQLError("Too many errors processing variables, error limit reached. Execution aborted.");
      }
      errors3.push(error2);
    });
    if (errors3.length === 0) {
      return { coerced };
    }
  } catch (error2) {
    errors3.push(error2);
  }
  return { errors: errors3 };
}
var coerceVariableValues = function(schema4, varDefNodes, inputs, onError) {
  const coercedValues = {};
  for (const varDefNode of varDefNodes) {
    const varName = varDefNode.variable.name.value;
    const varType = typeFromAST(schema4, varDefNode.type);
    if (!isInputType(varType)) {
      const varTypeStr = print(varDefNode.type);
      onError(createGraphQLError(`Variable "\$${varName}" expected value of type "${varTypeStr}" which cannot be used as an input type.`, { nodes: varDefNode.type }));
      continue;
    }
    if (!hasOwnProperty2(inputs, varName)) {
      if (varDefNode.defaultValue) {
        coercedValues[varName] = valueFromAST(varDefNode.defaultValue, varType);
      } else if (isNonNullType(varType)) {
        const varTypeStr = inspect25(varType);
        onError(createGraphQLError(`Variable "\$${varName}" of required type "${varTypeStr}" was not provided.`, {
          nodes: varDefNode
        }));
      }
      continue;
    }
    const value = inputs[varName];
    if (value === null && isNonNullType(varType)) {
      const varTypeStr = inspect25(varType);
      onError(createGraphQLError(`Variable "\$${varName}" of non-null type "${varTypeStr}" must not be null.`, {
        nodes: varDefNode
      }));
      continue;
    }
    coercedValues[varName] = coerceInputValue(value, varType, (path5, invalidValue, error2) => {
      let prefix = `Variable "\$${varName}" got invalid value ` + inspect25(invalidValue);
      if (path5.length > 0) {
        prefix += ` at "${varName}${printPathArray3(path5)}"`;
      }
      onError(createGraphQLError(prefix + "; " + error2.message, {
        nodes: varDefNode,
        originalError: error2.originalError
      }));
    });
  }
  return coercedValues;
};

// node_modules/@graphql-tools/executor/esm/execution/execute.js
function execute2(args7) {
  const exeContext = buildExecutionContext(args7);
  if (!("schema" in exeContext)) {
    return {
      errors: exeContext.map((e) => {
        Object.defineProperty(e, "extensions", {
          value: {
            ...e.extensions,
            http: {
              ...e.extensions?.["http"],
              status: 400
            }
          }
        });
        return e;
      })
    };
  }
  return executeImpl(exeContext);
}
var executeImpl = function(exeContext) {
  return new ValueOrPromise(() => executeOperation(exeContext)).then((data) => {
    const initialResult = buildResponse(data, exeContext.errors);
    if (exeContext.subsequentPayloads.size > 0) {
      return {
        initialResult: {
          ...initialResult,
          hasNext: true
        },
        subsequentResults: yieldSubsequentPayloads(exeContext)
      };
    }
    return initialResult;
  }, (error2) => {
    exeContext.errors.push(error2);
    return buildResponse(null, exeContext.errors);
  }).resolve();
};
var buildResponse = function(data, errors3) {
  return errors3.length === 0 ? { data } : { errors: errors3, data };
};
function buildExecutionContext(args7) {
  const { schema: schema4, document: document2, rootValue, contextValue, variableValues: rawVariableValues, operationName, fieldResolver, typeResolver, subscribeFieldResolver, signal } = args7;
  assertValidSchema(schema4);
  const fragments = getFragmentsFromDocument(document2);
  let operation;
  for (const definition28 of document2.definitions) {
    switch (definition28.kind) {
      case Kind.OPERATION_DEFINITION:
        if (operationName == null) {
          if (operation !== undefined) {
            return [
              createGraphQLError("Must provide operation name if query contains multiple operations.")
            ];
          }
          operation = definition28;
        } else if (definition28.name?.value === operationName) {
          operation = definition28;
        }
        break;
      default:
    }
  }
  if (operation == null) {
    if (operationName != null) {
      return [createGraphQLError(`Unknown operation named "${operationName}".`)];
    }
    return [createGraphQLError("Must provide an operation.")];
  }
  const variableDefinitions = operation.variableDefinitions ?? [];
  const coercedVariableValues = getVariableValues2(schema4, variableDefinitions, rawVariableValues ?? {}, {
    maxErrors: 50
  });
  if (coercedVariableValues.errors) {
    return coercedVariableValues.errors;
  }
  return {
    schema: schema4,
    fragments,
    rootValue,
    contextValue,
    operation,
    variableValues: coercedVariableValues.coerced,
    fieldResolver: fieldResolver ?? defaultFieldResolver2,
    typeResolver: typeResolver ?? defaultTypeResolver2,
    subscribeFieldResolver: subscribeFieldResolver ?? defaultFieldResolver2,
    subsequentPayloads: new Set,
    errors: [],
    signal
  };
}
var buildPerEventExecutionContext = function(exeContext, payload) {
  return {
    ...exeContext,
    rootValue: payload,
    subsequentPayloads: new Set,
    errors: []
  };
};
var executeOperation = function(exeContext) {
  const { operation, schema: schema4, fragments, variableValues, rootValue } = exeContext;
  const rootType = getDefinedRootType(schema4, operation.operation, [operation]);
  if (rootType == null) {
    createGraphQLError(`Schema is not configured to execute ${operation.operation} operation.`, {
      nodes: operation
    });
  }
  const { fields: rootFields, patches } = collectFields4(schema4, fragments, variableValues, rootType, operation.selectionSet);
  const path5 = undefined;
  let result;
  if (operation.operation === "mutation") {
    result = executeFieldsSerially(exeContext, rootType, rootValue, path5, rootFields);
  } else {
    result = executeFields(exeContext, rootType, rootValue, path5, rootFields);
  }
  for (const patch of patches) {
    const { label, fields: patchFields } = patch;
    executeDeferredFragment(exeContext, rootType, rootValue, patchFields, label, path5);
  }
  return result;
};
var executeFieldsSerially = function(exeContext, parentType, sourceValue, path5, fields) {
  let abortErrorThrown = false;
  return promiseReduce(fields, (results, [responseName, fieldNodes]) => {
    const fieldPath = addPath2(path5, responseName, parentType.name);
    if (exeContext.signal?.aborted) {
      results[responseName] = null;
      return results;
    }
    return new ValueOrPromise(() => executeField(exeContext, parentType, sourceValue, fieldNodes, fieldPath)).then((result) => {
      if (result === undefined) {
        return results;
      }
      results[responseName] = result;
      if (exeContext.signal?.aborted && !abortErrorThrown) {
        exeContext.errors.push(createGraphQLError("Execution aborted", {
          nodes: fieldNodes,
          path: pathToArray3(fieldPath),
          originalError: exeContext.signal?.reason
        }));
        abortErrorThrown = true;
      }
      return results;
    });
  }, Object.create(null)).resolve();
};
var executeFields = function(exeContext, parentType, sourceValue, path5, fields, asyncPayloadRecord) {
  const results = Object.create(null);
  let containsPromise = false;
  let abortErrorThrown = false;
  try {
    for (const [responseName, fieldNodes] of fields) {
      if (exeContext.signal?.aborted) {
        results[responseName] = null;
        continue;
      }
      const fieldPath = addPath2(path5, responseName, parentType.name);
      const result = executeField(exeContext, parentType, sourceValue, fieldNodes, fieldPath, asyncPayloadRecord);
      if (result !== undefined) {
        results[responseName] = result;
        if (isPromise3(result)) {
          containsPromise = true;
        }
      }
      if (exeContext.signal?.aborted && !abortErrorThrown) {
        exeContext.errors.push(createGraphQLError("Execution aborted", {
          nodes: fieldNodes,
          path: pathToArray3(fieldPath),
          originalError: exeContext.signal?.reason
        }));
        abortErrorThrown = true;
      }
    }
  } catch (error2) {
    if (containsPromise) {
      return promiseForObject(results, exeContext.signal).finally(() => {
        throw error2;
      });
    }
    throw error2;
  }
  if (!containsPromise) {
    return results;
  }
  return promiseForObject(results, exeContext.signal);
};
var executeField = function(exeContext, parentType, source2, fieldNodes, path5, asyncPayloadRecord) {
  const errors3 = asyncPayloadRecord?.errors ?? exeContext.errors;
  const fieldDef = getFieldDef2(exeContext.schema, parentType, fieldNodes[0]);
  if (!fieldDef) {
    return;
  }
  const returnType = fieldDef.type;
  const resolveFn = fieldDef.resolve ?? exeContext.fieldResolver;
  const info = buildResolveInfo(exeContext, fieldDef, fieldNodes, parentType, path5);
  try {
    const args7 = getArgumentValues2(fieldDef, fieldNodes[0], exeContext.variableValues);
    const contextValue = exeContext.contextValue;
    const result = resolveFn(source2, args7, contextValue, info);
    let completed;
    if (isPromise3(result)) {
      completed = result.then((resolved) => completeValue2(exeContext, returnType, fieldNodes, info, path5, resolved, asyncPayloadRecord));
    } else {
      completed = completeValue2(exeContext, returnType, fieldNodes, info, path5, result, asyncPayloadRecord);
    }
    if (isPromise3(completed)) {
      return completed.then(undefined, (rawError) => {
        const error2 = locatedError(rawError, fieldNodes, pathToArray3(path5));
        const handledError = handleFieldError(error2, returnType, errors3);
        filterSubsequentPayloads(exeContext, path5, asyncPayloadRecord);
        return handledError;
      });
    }
    return completed;
  } catch (rawError) {
    const error2 = locatedError(rawError, fieldNodes, pathToArray3(path5));
    const handledError = handleFieldError(error2, returnType, errors3);
    filterSubsequentPayloads(exeContext, path5, asyncPayloadRecord);
    return handledError;
  }
};
function buildResolveInfo(exeContext, fieldDef, fieldNodes, parentType, path5) {
  return {
    fieldName: fieldDef.name,
    fieldNodes,
    returnType: fieldDef.type,
    parentType,
    path: path5,
    schema: exeContext.schema,
    fragments: exeContext.fragments,
    rootValue: exeContext.rootValue,
    operation: exeContext.operation,
    variableValues: exeContext.variableValues
  };
}
var handleFieldError = function(error2, returnType, errors3) {
  if (isNonNullType(returnType)) {
    throw error2;
  }
  errors3.push(error2);
  return null;
};
var completeValue2 = function(exeContext, returnType, fieldNodes, info, path5, result, asyncPayloadRecord) {
  if (result instanceof Error) {
    throw result;
  }
  if (isNonNullType(returnType)) {
    const completed = completeValue2(exeContext, returnType.ofType, fieldNodes, info, path5, result, asyncPayloadRecord);
    if (completed === null) {
      throw new Error(`Cannot return null for non-nullable field ${info.parentType.name}.${info.fieldName}.`);
    }
    return completed;
  }
  if (result == null) {
    return null;
  }
  if (isListType(returnType)) {
    return completeListValue(exeContext, returnType, fieldNodes, info, path5, result, asyncPayloadRecord);
  }
  if (isLeafType(returnType)) {
    return completeLeafValue(returnType, result);
  }
  if (isAbstractType(returnType)) {
    return completeAbstractValue(exeContext, returnType, fieldNodes, info, path5, result, asyncPayloadRecord);
  }
  if (isObjectType(returnType)) {
    return completeObjectValue(exeContext, returnType, fieldNodes, info, path5, result, asyncPayloadRecord);
  }
  console.assert(false, "Cannot complete value of unexpected output type: " + inspect25(returnType));
};
var getStreamValues = function(exeContext, fieldNodes, path5) {
  if (typeof path5.key === "number") {
    return;
  }
  const stream = getDirectiveValues(GraphQLStreamDirective, fieldNodes[0], exeContext.variableValues);
  if (!stream) {
    return;
  }
  if (stream.if === false) {
    return;
  }
  invariant12(typeof stream["initialCount"] === "number", "initialCount must be a number");
  invariant12(stream["initialCount"] >= 0, "initialCount must be a positive integer");
  return {
    initialCount: stream["initialCount"],
    label: typeof stream["label"] === "string" ? stream["label"] : undefined
  };
};
async function completeAsyncIteratorValue(exeContext, itemType, fieldNodes, info, path5, iterator, asyncPayloadRecord) {
  exeContext.signal?.addEventListener("abort", () => {
    iterator.return?.();
    exeContext.errors.push(createGraphQLError("Execution aborted", {
      nodes: fieldNodes,
      path: pathToArray3(path5),
      originalError: exeContext.signal?.reason
    }));
  });
  const errors3 = asyncPayloadRecord?.errors ?? exeContext.errors;
  const stream = getStreamValues(exeContext, fieldNodes, path5);
  let containsPromise = false;
  const completedResults = [];
  let index = 0;
  while (true) {
    if (stream && typeof stream.initialCount === "number" && index >= stream.initialCount) {
      executeStreamIterator(index, iterator, exeContext, fieldNodes, info, itemType, path5, stream.label, asyncPayloadRecord);
      break;
    }
    const itemPath = addPath2(path5, index, undefined);
    let iteration;
    try {
      iteration = await iterator.next();
      if (iteration.done) {
        break;
      }
    } catch (rawError) {
      const error2 = locatedError(rawError, fieldNodes, pathToArray3(itemPath));
      completedResults.push(handleFieldError(error2, itemType, errors3));
      break;
    }
    if (completeListItemValue(iteration.value, completedResults, errors3, exeContext, itemType, fieldNodes, info, itemPath, asyncPayloadRecord)) {
      containsPromise = true;
    }
    index += 1;
  }
  return containsPromise ? Promise.all(completedResults) : completedResults;
}
var completeListValue = function(exeContext, returnType, fieldNodes, info, path5, result, asyncPayloadRecord) {
  const itemType = returnType.ofType;
  const errors3 = asyncPayloadRecord?.errors ?? exeContext.errors;
  if (isAsyncIterable(result)) {
    const iterator = result[Symbol.asyncIterator]();
    return completeAsyncIteratorValue(exeContext, itemType, fieldNodes, info, path5, iterator, asyncPayloadRecord);
  }
  if (!isIterableObject4(result)) {
    throw createGraphQLError(`Expected Iterable, but did not find one for field "${info.parentType.name}.${info.fieldName}".`);
  }
  const stream = getStreamValues(exeContext, fieldNodes, path5);
  let containsPromise = false;
  let previousAsyncPayloadRecord = asyncPayloadRecord;
  const completedResults = [];
  let index = 0;
  for (const item2 of result) {
    const itemPath = addPath2(path5, index, undefined);
    if (stream && typeof stream.initialCount === "number" && index >= stream.initialCount) {
      previousAsyncPayloadRecord = executeStreamField(path5, itemPath, item2, exeContext, fieldNodes, info, itemType, stream.label, previousAsyncPayloadRecord);
      index++;
      continue;
    }
    if (completeListItemValue(item2, completedResults, errors3, exeContext, itemType, fieldNodes, info, itemPath, asyncPayloadRecord)) {
      containsPromise = true;
    }
    index++;
  }
  return containsPromise ? Promise.all(completedResults) : completedResults;
};
var completeListItemValue = function(item2, completedResults, errors3, exeContext, itemType, fieldNodes, info, itemPath, asyncPayloadRecord) {
  try {
    let completedItem;
    if (isPromise3(item2)) {
      completedItem = item2.then((resolved) => completeValue2(exeContext, itemType, fieldNodes, info, itemPath, resolved, asyncPayloadRecord));
    } else {
      completedItem = completeValue2(exeContext, itemType, fieldNodes, info, itemPath, item2, asyncPayloadRecord);
    }
    if (isPromise3(completedItem)) {
      completedResults.push(completedItem.then(undefined, (rawError) => {
        const error2 = locatedError(rawError, fieldNodes, pathToArray3(itemPath));
        const handledError = handleFieldError(error2, itemType, errors3);
        filterSubsequentPayloads(exeContext, itemPath, asyncPayloadRecord);
        return handledError;
      }));
      return true;
    }
    completedResults.push(completedItem);
  } catch (rawError) {
    const error2 = locatedError(rawError, fieldNodes, pathToArray3(itemPath));
    const handledError = handleFieldError(error2, itemType, errors3);
    filterSubsequentPayloads(exeContext, itemPath, asyncPayloadRecord);
    completedResults.push(handledError);
  }
  return false;
};
var completeLeafValue = function(returnType, result) {
  let serializedResult;
  try {
    serializedResult = returnType.serialize(result);
  } catch (err) {
    if (err instanceof GraphQLError) {
      throw new Error(err.message);
    }
    throw err;
  }
  if (serializedResult == null) {
    throw new Error(`Expected \`${inspect25(returnType)}.serialize(${inspect25(result)})\` to ` + `return non-nullable value, returned: ${inspect25(serializedResult)}`);
  }
  return serializedResult;
};
var completeAbstractValue = function(exeContext, returnType, fieldNodes, info, path5, result, asyncPayloadRecord) {
  const resolveTypeFn = returnType.resolveType ?? exeContext.typeResolver;
  const contextValue = exeContext.contextValue;
  const runtimeType = resolveTypeFn(result, contextValue, info, returnType);
  if (isPromise3(runtimeType)) {
    return runtimeType.then((resolvedRuntimeType) => completeObjectValue(exeContext, ensureValidRuntimeType(resolvedRuntimeType, exeContext, returnType, fieldNodes, info, result), fieldNodes, info, path5, result, asyncPayloadRecord));
  }
  return completeObjectValue(exeContext, ensureValidRuntimeType(runtimeType, exeContext, returnType, fieldNodes, info, result), fieldNodes, info, path5, result, asyncPayloadRecord);
};
var ensureValidRuntimeType = function(runtimeTypeName, exeContext, returnType, fieldNodes, info, result) {
  if (runtimeTypeName == null) {
    throw createGraphQLError(`Abstract type "${returnType.name}" must resolve to an Object type at runtime for field "${info.parentType.name}.${info.fieldName}". Either the "${returnType.name}" type should provide a "resolveType" function or each possible type should provide an "isTypeOf" function.`, { nodes: fieldNodes });
  }
  if (isObjectType(runtimeTypeName)) {
    throw createGraphQLError("Support for returning GraphQLObjectType from resolveType was removed in graphql-js@16.0.0 please return type name instead.");
  }
  if (typeof runtimeTypeName !== "string") {
    throw createGraphQLError(`Abstract type "${returnType.name}" must resolve to an Object type at runtime for field "${info.parentType.name}.${info.fieldName}" with ` + `value ${inspect25(result)}, received "${inspect25(runtimeTypeName)}".`);
  }
  const runtimeType = exeContext.schema.getType(runtimeTypeName);
  if (runtimeType == null) {
    throw createGraphQLError(`Abstract type "${returnType.name}" was resolved to a type "${runtimeTypeName}" that does not exist inside the schema.`, { nodes: fieldNodes });
  }
  if (!isObjectType(runtimeType)) {
    throw createGraphQLError(`Abstract type "${returnType.name}" was resolved to a non-object type "${runtimeTypeName}".`, { nodes: fieldNodes });
  }
  if (!exeContext.schema.isSubType(returnType, runtimeType)) {
    throw createGraphQLError(`Runtime Object type "${runtimeType.name}" is not a possible type for "${returnType.name}".`, { nodes: fieldNodes });
  }
  return runtimeType;
};
var completeObjectValue = function(exeContext, returnType, fieldNodes, info, path5, result, asyncPayloadRecord) {
  if (returnType.isTypeOf) {
    const isTypeOf = returnType.isTypeOf(result, exeContext.contextValue, info);
    if (isPromise3(isTypeOf)) {
      return isTypeOf.then((resolvedIsTypeOf) => {
        if (!resolvedIsTypeOf) {
          throw invalidReturnTypeError(returnType, result, fieldNodes);
        }
        return collectAndExecuteSubfields(exeContext, returnType, fieldNodes, path5, result, asyncPayloadRecord);
      });
    }
    if (!isTypeOf) {
      throw invalidReturnTypeError(returnType, result, fieldNodes);
    }
  }
  return collectAndExecuteSubfields(exeContext, returnType, fieldNodes, path5, result, asyncPayloadRecord);
};
var invalidReturnTypeError = function(returnType, result, fieldNodes) {
  return createGraphQLError(`Expected value of type "${returnType.name}" but got: ${inspect25(result)}.`, {
    nodes: fieldNodes
  });
};
var collectAndExecuteSubfields = function(exeContext, returnType, fieldNodes, path5, result, asyncPayloadRecord) {
  const { fields: subFieldNodes, patches: subPatches } = collectSubfields4(exeContext, returnType, fieldNodes);
  const subFields = executeFields(exeContext, returnType, result, path5, subFieldNodes, asyncPayloadRecord);
  for (const subPatch of subPatches) {
    const { label, fields: subPatchFieldNodes } = subPatch;
    executeDeferredFragment(exeContext, returnType, result, subPatchFieldNodes, label, path5, asyncPayloadRecord);
  }
  return subFields;
};
function subscribe2(args7) {
  const exeContext = buildExecutionContext(args7);
  if (!("schema" in exeContext)) {
    return {
      errors: exeContext.map((e) => {
        Object.defineProperty(e, "extensions", {
          value: {
            ...e.extensions,
            http: {
              ...e.extensions?.["http"],
              status: 400
            }
          }
        });
        return e;
      })
    };
  }
  const resultOrStream = createSourceEventStreamImpl(exeContext);
  if (isPromise3(resultOrStream)) {
    return resultOrStream.then((resolvedResultOrStream) => mapSourceToResponse(exeContext, resolvedResultOrStream));
  }
  return mapSourceToResponse(exeContext, resultOrStream);
}
function flattenIncrementalResults(incrementalResults, signal) {
  const subsequentIterator = incrementalResults.subsequentResults;
  let initialResultSent = false;
  let done = false;
  signal?.addEventListener("abort", () => {
    done = true;
    subsequentIterator.throw?.(signal?.reason);
  });
  return {
    [Symbol.asyncIterator]() {
      return this;
    },
    next() {
      if (done) {
        return Promise.resolve({
          value: undefined,
          done
        });
      }
      if (initialResultSent) {
        return subsequentIterator.next();
      }
      initialResultSent = true;
      return Promise.resolve({
        value: incrementalResults.initialResult,
        done
      });
    },
    return() {
      done = true;
      return subsequentIterator.return();
    },
    throw(error2) {
      done = true;
      return subsequentIterator.throw(error2);
    }
  };
}
async function* ensureAsyncIterable(someExecutionResult, signal) {
  if ("initialResult" in someExecutionResult) {
    yield* flattenIncrementalResults(someExecutionResult, signal);
  } else {
    yield someExecutionResult;
  }
}
var mapSourceToResponse = function(exeContext, resultOrStream) {
  if (!isAsyncIterable(resultOrStream)) {
    return resultOrStream;
  }
  return flattenAsyncIterable(mapAsyncIterator(resultOrStream[Symbol.asyncIterator](), async (payload) => ensureAsyncIterable(await executeImpl(buildPerEventExecutionContext(exeContext, payload)), exeContext.signal), async function* (error2) {
    const wrappedError = createGraphQLError(error2.message, {
      originalError: error2,
      nodes: [exeContext.operation]
    });
    yield {
      errors: [wrappedError]
    };
  }));
};
var createSourceEventStreamImpl = function(exeContext) {
  try {
    const eventStream = executeSubscription(exeContext);
    if (isPromise3(eventStream)) {
      return eventStream.then(undefined, (error2) => ({ errors: [error2] }));
    }
    return eventStream;
  } catch (error2) {
    return { errors: [error2] };
  }
};
var executeSubscription = function(exeContext) {
  const { schema: schema4, fragments, operation, variableValues, rootValue } = exeContext;
  const rootType = schema4.getSubscriptionType();
  if (rootType == null) {
    throw createGraphQLError("Schema is not configured to execute subscription operation.", {
      nodes: operation
    });
  }
  const { fields: rootFields } = collectFields4(schema4, fragments, variableValues, rootType, operation.selectionSet);
  const [responseName, fieldNodes] = [...rootFields.entries()][0];
  const fieldName = fieldNodes[0].name.value;
  const fieldDef = getFieldDef2(schema4, rootType, fieldNodes[0]);
  if (!fieldDef) {
    throw createGraphQLError(`The subscription field "${fieldName}" is not defined.`, {
      nodes: fieldNodes
    });
  }
  const path5 = addPath2(undefined, responseName, rootType.name);
  const info = buildResolveInfo(exeContext, fieldDef, fieldNodes, rootType, path5);
  try {
    const args7 = getArgumentValues2(fieldDef, fieldNodes[0], variableValues);
    const contextValue = exeContext.contextValue;
    const resolveFn = fieldDef.subscribe ?? exeContext.subscribeFieldResolver;
    const result = resolveFn(rootValue, args7, contextValue, info);
    if (isPromise3(result)) {
      return result.then(assertEventStream).then(undefined, (error2) => {
        throw locatedError(error2, fieldNodes, pathToArray3(path5));
      });
    }
    return assertEventStream(result, exeContext.signal);
  } catch (error2) {
    throw locatedError(error2, fieldNodes, pathToArray3(path5));
  }
};
var assertEventStream = function(result, signal) {
  if (result instanceof Error) {
    throw result;
  }
  if (!isAsyncIterable(result)) {
    throw createGraphQLError("Subscription field must return Async Iterable. " + `Received: ${inspect25(result)}.`);
  }
  return {
    [Symbol.asyncIterator]() {
      const asyncIterator = result[Symbol.asyncIterator]();
      signal?.addEventListener("abort", () => {
        asyncIterator.return?.();
      });
      return asyncIterator;
    }
  };
};
var executeDeferredFragment = function(exeContext, parentType, sourceValue, fields, label, path5, parentContext) {
  const asyncPayloadRecord = new DeferredFragmentRecord({
    label,
    path: path5,
    parentContext,
    exeContext
  });
  let promiseOrData;
  try {
    promiseOrData = executeFields(exeContext, parentType, sourceValue, path5, fields, asyncPayloadRecord);
    if (isPromise3(promiseOrData)) {
      promiseOrData = promiseOrData.then(null, (e) => {
        asyncPayloadRecord.errors.push(e);
        return null;
      });
    }
  } catch (e) {
    asyncPayloadRecord.errors.push(e);
    promiseOrData = null;
  }
  asyncPayloadRecord.addData(promiseOrData);
};
var executeStreamField = function(path5, itemPath, item2, exeContext, fieldNodes, info, itemType, label, parentContext) {
  const asyncPayloadRecord = new StreamRecord({
    label,
    path: itemPath,
    parentContext,
    exeContext
  });
  let completedItem;
  try {
    try {
      if (isPromise3(item2)) {
        completedItem = item2.then((resolved) => completeValue2(exeContext, itemType, fieldNodes, info, itemPath, resolved, asyncPayloadRecord));
      } else {
        completedItem = completeValue2(exeContext, itemType, fieldNodes, info, itemPath, item2, asyncPayloadRecord);
      }
      if (isPromise3(completedItem)) {
        completedItem = completedItem.then(undefined, (rawError) => {
          const error2 = locatedError(rawError, fieldNodes, pathToArray3(itemPath));
          const handledError = handleFieldError(error2, itemType, asyncPayloadRecord.errors);
          filterSubsequentPayloads(exeContext, itemPath, asyncPayloadRecord);
          return handledError;
        });
      }
    } catch (rawError) {
      const error2 = locatedError(rawError, fieldNodes, pathToArray3(itemPath));
      completedItem = handleFieldError(error2, itemType, asyncPayloadRecord.errors);
      filterSubsequentPayloads(exeContext, itemPath, asyncPayloadRecord);
    }
  } catch (error2) {
    asyncPayloadRecord.errors.push(error2);
    filterSubsequentPayloads(exeContext, path5, asyncPayloadRecord);
    asyncPayloadRecord.addItems(null);
    return asyncPayloadRecord;
  }
  let completedItems;
  if (isPromise3(completedItem)) {
    completedItems = completedItem.then((value) => [value], (error2) => {
      asyncPayloadRecord.errors.push(error2);
      filterSubsequentPayloads(exeContext, path5, asyncPayloadRecord);
      return null;
    });
  } else {
    completedItems = [completedItem];
  }
  asyncPayloadRecord.addItems(completedItems);
  return asyncPayloadRecord;
};
async function executeStreamIteratorItem(iterator, exeContext, fieldNodes, info, itemType, asyncPayloadRecord, itemPath) {
  let item2;
  try {
    const { value, done } = await iterator.next();
    if (done) {
      asyncPayloadRecord.setIsCompletedIterator();
      return { done, value: undefined };
    }
    item2 = value;
  } catch (rawError) {
    const error2 = locatedError(rawError, fieldNodes, pathToArray3(itemPath));
    const value = handleFieldError(error2, itemType, asyncPayloadRecord.errors);
    return { done: true, value };
  }
  let completedItem;
  try {
    completedItem = completeValue2(exeContext, itemType, fieldNodes, info, itemPath, item2, asyncPayloadRecord);
    if (isPromise3(completedItem)) {
      completedItem = completedItem.then(undefined, (rawError) => {
        const error2 = locatedError(rawError, fieldNodes, pathToArray3(itemPath));
        const handledError = handleFieldError(error2, itemType, asyncPayloadRecord.errors);
        filterSubsequentPayloads(exeContext, itemPath, asyncPayloadRecord);
        return handledError;
      });
    }
    return { done: false, value: completedItem };
  } catch (rawError) {
    const error2 = locatedError(rawError, fieldNodes, pathToArray3(itemPath));
    const value = handleFieldError(error2, itemType, asyncPayloadRecord.errors);
    filterSubsequentPayloads(exeContext, itemPath, asyncPayloadRecord);
    return { done: false, value };
  }
}
async function executeStreamIterator(initialIndex, iterator, exeContext, fieldNodes, info, itemType, path5, label, parentContext) {
  let index = initialIndex;
  let previousAsyncPayloadRecord = parentContext ?? undefined;
  while (true) {
    const itemPath = addPath2(path5, index, undefined);
    const asyncPayloadRecord = new StreamRecord({
      label,
      path: itemPath,
      parentContext: previousAsyncPayloadRecord,
      iterator,
      exeContext
    });
    let iteration;
    try {
      iteration = await executeStreamIteratorItem(iterator, exeContext, fieldNodes, info, itemType, asyncPayloadRecord, itemPath);
    } catch (error2) {
      asyncPayloadRecord.errors.push(error2);
      filterSubsequentPayloads(exeContext, path5, asyncPayloadRecord);
      asyncPayloadRecord.addItems(null);
      if (iterator?.return) {
        iterator.return().catch(() => {
        });
      }
      return;
    }
    const { done, value: completedItem } = iteration;
    let completedItems;
    if (isPromise3(completedItem)) {
      completedItems = completedItem.then((value) => [value], (error2) => {
        asyncPayloadRecord.errors.push(error2);
        filterSubsequentPayloads(exeContext, path5, asyncPayloadRecord);
        return null;
      });
    } else {
      completedItems = [completedItem];
    }
    asyncPayloadRecord.addItems(completedItems);
    if (done) {
      break;
    }
    previousAsyncPayloadRecord = asyncPayloadRecord;
    index++;
  }
}
var filterSubsequentPayloads = function(exeContext, nullPath, currentAsyncRecord) {
  const nullPathArray = pathToArray3(nullPath);
  exeContext.subsequentPayloads.forEach((asyncRecord) => {
    if (asyncRecord === currentAsyncRecord) {
      return;
    }
    for (let i = 0;i < nullPathArray.length; i++) {
      if (asyncRecord.path[i] !== nullPathArray[i]) {
        return;
      }
    }
    if (isStreamPayload(asyncRecord) && asyncRecord.iterator?.return) {
      asyncRecord.iterator.return().catch(() => {
      });
    }
    exeContext.subsequentPayloads.delete(asyncRecord);
  });
};
var getCompletedIncrementalResults = function(exeContext) {
  const incrementalResults = [];
  for (const asyncPayloadRecord of exeContext.subsequentPayloads) {
    const incrementalResult = {};
    if (!asyncPayloadRecord.isCompleted) {
      continue;
    }
    exeContext.subsequentPayloads.delete(asyncPayloadRecord);
    if (isStreamPayload(asyncPayloadRecord)) {
      const items = asyncPayloadRecord.items;
      if (asyncPayloadRecord.isCompletedIterator) {
        continue;
      }
      incrementalResult.items = items;
    } else {
      const data = asyncPayloadRecord.data;
      incrementalResult.data = data ?? null;
    }
    incrementalResult.path = asyncPayloadRecord.path;
    if (asyncPayloadRecord.label) {
      incrementalResult.label = asyncPayloadRecord.label;
    }
    if (asyncPayloadRecord.errors.length > 0) {
      incrementalResult.errors = asyncPayloadRecord.errors;
    }
    incrementalResults.push(incrementalResult);
  }
  return incrementalResults;
};
var yieldSubsequentPayloads = function(exeContext) {
  let isDone = false;
  async function next() {
    if (isDone) {
      return { value: undefined, done: true };
    }
    await Promise.race(Array.from(exeContext.subsequentPayloads).map((p) => p.promise));
    if (isDone) {
      return { value: undefined, done: true };
    }
    const incremental = getCompletedIncrementalResults(exeContext);
    const hasNext = exeContext.subsequentPayloads.size > 0;
    if (!incremental.length && hasNext) {
      return next();
    }
    if (!hasNext) {
      isDone = true;
    }
    return {
      value: incremental.length ? { incremental, hasNext } : { hasNext },
      done: false
    };
  }
  function returnStreamIterators() {
    const promises = [];
    exeContext.subsequentPayloads.forEach((asyncPayloadRecord) => {
      if (isStreamPayload(asyncPayloadRecord) && asyncPayloadRecord.iterator?.return) {
        promises.push(asyncPayloadRecord.iterator.return());
      }
    });
    return Promise.all(promises);
  }
  return {
    [Symbol.asyncIterator]() {
      return this;
    },
    next,
    async return() {
      await returnStreamIterators();
      isDone = true;
      return { value: undefined, done: true };
    },
    async throw(error2) {
      await returnStreamIterators();
      isDone = true;
      return Promise.reject(error2);
    }
  };
};
var isStreamPayload = function(asyncPayload) {
  return asyncPayload.type === "stream";
};
function getFieldDef2(schema4, parentType, fieldNode) {
  const fieldName = fieldNode.name.value;
  if (fieldName === SchemaMetaFieldDef.name && schema4.getQueryType() === parentType) {
    return SchemaMetaFieldDef;
  } else if (fieldName === TypeMetaFieldDef.name && schema4.getQueryType() === parentType) {
    return TypeMetaFieldDef;
  } else if (fieldName === TypeNameMetaFieldDef.name) {
    return TypeNameMetaFieldDef;
  }
  return parentType.getFields()[fieldName];
}
var collectSubfields4 = memoize33((exeContext, returnType, fieldNodes) => collectSubFields(exeContext.schema, exeContext.fragments, exeContext.variableValues, returnType, fieldNodes));
var getFragmentsFromDocument = memoize1(function getFragmentsFromDocument2(document2) {
  const fragments = Object.create(null);
  for (const definition28 of document2.definitions) {
    if (definition28.kind === Kind.FRAGMENT_DEFINITION) {
      fragments[definition28.name.value] = definition28;
    }
  }
  return fragments;
});
var defaultTypeResolver2 = function(value, contextValue, info, abstractType) {
  if (isObjectLike10(value) && typeof value["__typename"] === "string") {
    return value["__typename"];
  }
  const possibleTypes = info.schema.getPossibleTypes(abstractType);
  const promisedIsTypeOfResults = [];
  for (let i = 0;i < possibleTypes.length; i++) {
    const type = possibleTypes[i];
    if (type.isTypeOf) {
      const isTypeOfResult = type.isTypeOf(value, contextValue, info);
      if (isPromise3(isTypeOfResult)) {
        promisedIsTypeOfResults[i] = isTypeOfResult;
      } else if (isTypeOfResult) {
        return type.name;
      }
    }
  }
  if (promisedIsTypeOfResults.length) {
    return Promise.all(promisedIsTypeOfResults).then((isTypeOfResults) => {
      for (let i = 0;i < isTypeOfResults.length; i++) {
        if (isTypeOfResults[i]) {
          return possibleTypes[i].name;
        }
      }
    });
  }
};
var defaultFieldResolver2 = function(source2, args7, contextValue, info) {
  if (isObjectLike10(source2) || typeof source2 === "function") {
    const property = source2[info.fieldName];
    if (typeof property === "function") {
      return source2[info.fieldName](args7, contextValue, info);
    }
    return property;
  }
};

class DeferredFragmentRecord {
  constructor(opts) {
    this.type = "defer";
    this.label = opts.label;
    this.path = pathToArray3(opts.path);
    this.parentContext = opts.parentContext;
    this.errors = [];
    this._exeContext = opts.exeContext;
    this._exeContext.subsequentPayloads.add(this);
    this.isCompleted = false;
    this.data = null;
    this.promise = new Promise((resolve) => {
      this._resolve = (MaybePromise) => {
        resolve(MaybePromise);
      };
    }).then((data) => {
      this.data = data;
      this.isCompleted = true;
    });
  }
  addData(data) {
    const parentData = this.parentContext?.promise;
    if (parentData) {
      this._resolve?.(parentData.then(() => data));
      return;
    }
    this._resolve?.(data);
  }
}

class StreamRecord {
  constructor(opts) {
    this.type = "stream";
    this.items = null;
    this.label = opts.label;
    this.path = pathToArray3(opts.path);
    this.parentContext = opts.parentContext;
    this.iterator = opts.iterator;
    this.errors = [];
    this._exeContext = opts.exeContext;
    this._exeContext.subsequentPayloads.add(this);
    this.isCompleted = false;
    this.items = null;
    this.promise = new Promise((resolve) => {
      this._resolve = (MaybePromise) => {
        resolve(MaybePromise);
      };
    }).then((items) => {
      this.items = items;
      this.isCompleted = true;
    });
  }
  addItems(items) {
    const parentData = this.parentContext?.promise;
    if (parentData) {
      this._resolve?.(parentData.then(() => items));
      return;
    }
    this._resolve?.(items);
  }
  setIsCompletedIterator() {
    this.isCompletedIterator = true;
  }
}

// node_modules/@graphql-tools/executor/esm/execution/normalizedExecutor.js
function normalizedExecutor(args7) {
  const operationAST = getOperationAST(args7.document, args7.operationName);
  if (operationAST == null) {
    throw new Error("Must provide an operation.");
  }
  if (operationAST.operation === "subscription") {
    return subscribe2(args7);
  }
  return new ValueOrPromise(() => execute2(args7)).then((result) => {
    if ("initialResult" in result) {
      return flattenIncrementalResults(result, args7.signal);
    }
    return result;
  }).resolve();
}

// node_modules/@whatwg-node/fetch/dist/node-ponyfill.js
var exports_node_ponyfill = {};
__export(exports_node_ponyfill, {
  fetch: () => {
    {
      return $fetch;
    }
  },
  crypto: () => {
    {
      return $crypto;
    }
  },
  createFetch: () => {
    {
      return $createFetch;
    }
  },
  btoa: () => {
    {
      return $btoa;
    }
  },
  WritableStream: () => {
    {
      return $WritableStream;
    }
  },
  URLSearchParams: () => {
    {
      return $URLSearchParams;
    }
  },
  URLPattern: () => {
    {
      return $URLPattern;
    }
  },
  URL: () => {
    {
      return $URL;
    }
  },
  TransformStream: () => {
    {
      return $TransformStream;
    }
  },
  TextEncoder: () => {
    {
      return $TextEncoder;
    }
  },
  TextDecoder: () => {
    {
      return $TextDecoder;
    }
  },
  Response: () => {
    {
      return $Response;
    }
  },
  Request: () => {
    {
      return $Request;
    }
  },
  ReadableStream: () => {
    {
      return $ReadableStream;
    }
  },
  Headers: () => {
    {
      return $Headers;
    }
  },
  FormData: () => {
    {
      return $FormData;
    }
  },
  File: () => {
    {
      return $File;
    }
  },
  Blob: () => {
    {
      return $Blob;
    }
  }
});
var createNodePonyfill = require_create_node_ponyfill();
var ponyfills = createNodePonyfill();
if (!globalThis.Deno && !process.versions.bun) {
  try {
    const nodelibcurlName = "node-libcurl";
    globalThis.libcurl = globalThis.libcurl || import.meta.require(nodelibcurlName);
  } catch (e) {
  }
}
var $fetch = ponyfills.fetch;
var $Headers = ponyfills.Headers;
var $Request = ponyfills.Request;
var $Response = ponyfills.Response;
var $FormData = ponyfills.FormData;
var $ReadableStream = ponyfills.ReadableStream;
var $WritableStream = ponyfills.WritableStream;
var $TransformStream = ponyfills.TransformStream;
var $Blob = ponyfills.Blob;
var $File = ponyfills.File;
var $crypto = ponyfills.crypto;
var $btoa = ponyfills.btoa;
var $TextEncoder = ponyfills.TextEncoder;
var $TextDecoder = ponyfills.TextDecoder;
var $URLPattern = ponyfills.URLPattern;
var $URL = ponyfills.URL;
var $URLSearchParams = ponyfills.URLSearchParams;
var $createFetch = createNodePonyfill;

// node_modules/@whatwg-node/server/esm/utils.js
function isAsyncIterable3(body) {
  return body != null && typeof body === "object" && typeof body[Symbol.asyncIterator] === "function";
}
var getPort = function(nodeRequest) {
  if (nodeRequest.socket?.localPort) {
    return nodeRequest.socket?.localPort;
  }
  const hostInHeader = nodeRequest.headers?.[":authority"] || nodeRequest.headers?.host;
  const portInHeader = hostInHeader?.split(":")?.[1];
  if (portInHeader) {
    return portInHeader;
  }
  return 80;
};
var getHostnameWithPort = function(nodeRequest) {
  if (nodeRequest.headers?.[":authority"]) {
    return nodeRequest.headers?.[":authority"];
  }
  if (nodeRequest.headers?.host) {
    return nodeRequest.headers?.host;
  }
  const port = getPort(nodeRequest);
  if (nodeRequest.hostname) {
    return nodeRequest.hostname + ":" + port;
  }
  const localIp = nodeRequest.socket?.localAddress;
  if (localIp && !localIp?.includes("::") && !localIp?.includes("ffff")) {
    return `${localIp}:${port}`;
  }
  return "localhost";
};
var buildFullUrl = function(nodeRequest) {
  const hostnameWithPort = getHostnameWithPort(nodeRequest);
  const protocol = nodeRequest.protocol || "http";
  const endpoint = nodeRequest.originalUrl || nodeRequest.url || "/graphql";
  return `${protocol}://${hostnameWithPort}${endpoint}`;
};
var isRequestBody = function(body) {
  const stringTag = body[Symbol.toStringTag];
  if (typeof body === "string" || stringTag === "Uint8Array" || stringTag === "Blob" || stringTag === "FormData" || stringTag === "URLSearchParams" || isAsyncIterable3(body)) {
    return true;
  }
  return false;
};
function normalizeNodeRequest(nodeRequest, RequestCtor) {
  const rawRequest = nodeRequest.raw || nodeRequest.req || nodeRequest;
  let fullUrl = buildFullUrl(rawRequest);
  if (nodeRequest.query) {
    const url = new $URL(fullUrl);
    for (const key in nodeRequest.query) {
      url.searchParams.set(key, nodeRequest.query[key]);
    }
    fullUrl = url.toString();
  }
  const signal = new ServerAdapterRequestAbortSignal;
  if (rawRequest.once) {
    rawRequest.once("end", () => signal.sendAbort());
    rawRequest.once("close", () => signal.sendAbort());
  }
  if (nodeRequest.method === "GET" || nodeRequest.method === "HEAD") {
    return new RequestCtor(fullUrl, {
      method: nodeRequest.method,
      headers: nodeRequest.headers,
      signal
    });
  }
  const maybeParsedBody = nodeRequest.body;
  if (maybeParsedBody != null && Object.keys(maybeParsedBody).length > 0) {
    if (isRequestBody(maybeParsedBody)) {
      return new RequestCtor(fullUrl, {
        method: nodeRequest.method,
        headers: nodeRequest.headers,
        body: maybeParsedBody,
        signal
      });
    }
    const request = new RequestCtor(fullUrl, {
      method: nodeRequest.method,
      headers: nodeRequest.headers,
      signal
    });
    if (!request.headers.get("content-type")?.includes("json")) {
      request.headers.set("content-type", "application/json; charset=utf-8");
    }
    return new Proxy(request, {
      get: (target, prop, receiver) => {
        switch (prop) {
          case "json":
            return async () => maybeParsedBody;
          case "text":
            return async () => JSON.stringify(maybeParsedBody);
          default:
            return Reflect.get(target, prop, receiver);
        }
      }
    });
  }
  return new RequestCtor(fullUrl, {
    method: nodeRequest.method,
    headers: nodeRequest.headers,
    body: rawRequest,
    signal
  });
}
function isReadable(stream) {
  return stream.read != null;
}
function isNodeRequest(request) {
  return isReadable(request);
}
function isServerResponse(stream) {
  return stream != null && stream.setHeader != null && stream.end != null && stream.once != null && stream.write != null;
}
function isFetchEvent(event) {
  return event != null && event.request != null && event.respondWith != null;
}
var configureSocket = function(rawRequest) {
  rawRequest?.socket?.setTimeout?.(0);
  rawRequest?.socket?.setNoDelay?.(true);
  rawRequest?.socket?.setKeepAlive?.(true);
};
var endResponse = function(serverResponse) {
  serverResponse.end(null, null, null);
};
async function sendAsyncIterable(serverResponse, asyncIterable) {
  for await (const chunk of asyncIterable) {
    if (!serverResponse.write(chunk)) {
      break;
    }
  }
  endResponse(serverResponse);
}
function sendNodeResponse(fetchResponse, serverResponse, nodeRequest) {
  if (serverResponse.closed || serverResponse.destroyed) {
    return;
  }
  if (!fetchResponse) {
    serverResponse.statusCode = 404;
    serverResponse.end();
    return;
  }
  serverResponse.statusCode = fetchResponse.status;
  serverResponse.statusMessage = fetchResponse.statusText;
  fetchResponse.headers.forEach((value, key) => {
    if (key === "set-cookie") {
      const setCookies = fetchResponse.headers.getSetCookie?.();
      if (setCookies) {
        serverResponse.setHeader("set-cookie", setCookies);
        return;
      }
    }
    serverResponse.setHeader(key, value);
  });
  const bufOfRes = fetchResponse._buffer;
  if (bufOfRes) {
    serverResponse.write(bufOfRes);
    endResponse(serverResponse);
    return;
  }
  const fetchBody = fetchResponse.body;
  if (fetchBody == null) {
    endResponse(serverResponse);
    return;
  }
  if (fetchBody[Symbol.toStringTag] === "Uint8Array") {
    serverResponse.write(fetchBody);
    endResponse(serverResponse);
    return;
  }
  configureSocket(nodeRequest);
  if (isReadable(fetchBody)) {
    serverResponse.once("close", () => {
      fetchBody.destroy();
    });
    fetchBody.pipe(serverResponse);
    return;
  }
  if (isAsyncIterable3(fetchBody)) {
    return sendAsyncIterable(serverResponse, fetchBody);
  }
}
function isRequestInit(val) {
  return val != null && typeof val === "object" && (("body" in val) || ("cache" in val) || ("credentials" in val) || ("headers" in val) || ("integrity" in val) || ("keepalive" in val) || ("method" in val) || ("mode" in val) || ("redirect" in val) || ("referrer" in val) || ("referrerPolicy" in val) || ("signal" in val) || ("window" in val));
}
function completeAssign(...args7) {
  const [target, ...sources] = args7.filter((arg2) => arg2 != null && typeof arg2 === "object");
  sources.forEach((source2) => {
    const descriptors = Object.getOwnPropertyNames(source2).reduce((descriptors2, key) => {
      descriptors2[key] = Object.getOwnPropertyDescriptor(source2, key);
      return descriptors2;
    }, {});
    Object.getOwnPropertySymbols(source2).forEach((sym) => {
      const descriptor = Object.getOwnPropertyDescriptor(source2, sym);
      if (descriptor.enumerable) {
        descriptors[sym] = descriptor;
      }
    });
    Object.defineProperties(target, descriptors);
  });
  return target;
}
function isPromise4(val) {
  return val?.then != null;
}
function iterateAsyncVoid(iterable, callback) {
  const iterator = iterable[Symbol.iterator]();
  let stopEarlyFlag = false;
  function stopEarlyFn() {
    stopEarlyFlag = true;
  }
  function iterate() {
    const { done: endOfIterator, value } = iterator.next();
    if (endOfIterator) {
      return;
    }
    const result$ = callback(value, stopEarlyFn);
    if (isPromise4(result$)) {
      return result$.then(() => {
        if (stopEarlyFlag) {
          return;
        }
        return iterate();
      });
    }
    if (stopEarlyFlag) {
      return;
    }
    return iterate();
  }
  return iterate();
}
function handleErrorFromRequestHandler(error2, ResponseCtor) {
  return new ResponseCtor(error2.stack || error2.message || error2.toString(), {
    status: error2.status || 500
  });
}

class ServerAdapterRequestAbortSignal extends EventTarget {
  constructor() {
    super(...arguments);
    this.aborted = false;
    this._onabort = null;
  }
  throwIfAborted() {
    if (this.aborted) {
      throw new DOMException("Aborted", "AbortError");
    }
  }
  sendAbort() {
    this.aborted = true;
    this.dispatchEvent(new Event("abort"));
  }
  get onabort() {
    return this._onabort;
  }
  set onabort(value) {
    this._onabort = value;
    if (value) {
      this.addEventListener("abort", value);
    } else {
      this.removeEventListener("abort", value);
    }
  }
}

// node_modules/@whatwg-node/server/esm/uwebsockets.js
function isUWSResponse(res) {
  return !!res.onData;
}
function getRequestFromUWSRequest({ req, res, fetchAPI }) {
  let body;
  const method = req.getMethod();
  if (method !== "get" && method !== "head") {
    body = new fetchAPI.ReadableStream({});
    const readable = body.readable;
    res.onAborted(() => {
      readable.push(null);
    });
    let multipleChunks = false;
    res.onData(function(ab, isLast) {
      const chunk = Buffer.from(ab, 0, ab.byteLength);
      if (!multipleChunks && isLast) {
        readable.push(chunk);
      } else {
        readable.push(Buffer.from(chunk));
      }
      if (isLast) {
        readable.push(null);
      }
      multipleChunks = true;
    });
  }
  const headers = new fetchAPI.Headers;
  req.forEach((key, value) => {
    headers.set(key, value);
  });
  let url = `http://localhost${req.getUrl()}`;
  const query = req.getQuery();
  if (query) {
    url += `?${query}`;
  }
  return new fetchAPI.Request(url, {
    method,
    headers,
    body,
    signal: new ServerAdapterRequestAbortSignal
  });
}
async function forwardResponseBodyToUWSResponse(uwsResponse, fetchResponse) {
  let resAborted = false;
  uwsResponse.onAborted(function() {
    resAborted = true;
  });
  for await (const chunk of fetchResponse.body) {
    if (resAborted) {
      return;
    }
    uwsResponse.cork(() => {
      uwsResponse.write(chunk);
    });
  }
  uwsResponse.cork(() => {
    uwsResponse.end();
  });
}
function sendResponseToUwsOpts(uwsResponse, fetchResponse) {
  if (!fetchResponse) {
    uwsResponse.writeStatus("404 Not Found");
    uwsResponse.end();
    return;
  }
  const bufferOfRes = fetchResponse._buffer;
  uwsResponse.cork(() => {
    uwsResponse.writeStatus(`${fetchResponse.status} ${fetchResponse.statusText}`);
    for (const [key, value] of fetchResponse.headers) {
      if (key !== "content-length") {
        if (key === "set-cookie") {
          const setCookies = fetchResponse.headers.getSetCookie?.();
          if (setCookies) {
            for (const setCookie of setCookies) {
              uwsResponse.writeHeader(key, setCookie);
            }
            continue;
          }
        }
        uwsResponse.writeHeader(key, value);
      }
    }
    if (bufferOfRes) {
      uwsResponse.end(bufferOfRes);
    }
  });
  if (bufferOfRes) {
    return;
  }
  if (!fetchResponse.body) {
    uwsResponse.end();
    return;
  }
  return forwardResponseBodyToUWSResponse(uwsResponse, fetchResponse);
}

// node_modules/@whatwg-node/server/esm/createServerAdapter.js
async function handleWaitUntils(waitUntilPromises) {
  const waitUntils = await Promise.allSettled(waitUntilPromises);
  waitUntils.forEach((waitUntil) => {
    if (waitUntil.status === "rejected") {
      console.error(waitUntil.reason);
    }
  });
}
var isRequestAccessible = function(serverContext) {
  try {
    return !!serverContext?.request;
  } catch {
    return false;
  }
};
var addWaitUntil = function(serverContext, waitUntilPromises) {
  serverContext["waitUntil"] = function(promise) {
    if (promise != null) {
      waitUntilPromises.push(promise);
    }
  };
};
var createServerAdapter = function(serverAdapterBaseObject, options) {
  const fetchAPI = {
    ...exports_node_ponyfill,
    ...options?.fetchAPI
  };
  const givenHandleRequest = typeof serverAdapterBaseObject === "function" ? serverAdapterBaseObject : serverAdapterBaseObject.handle;
  const onRequestHooks = [];
  const onResponseHooks = [];
  if (options?.plugins != null) {
    for (const plugin9 of options.plugins) {
      if (plugin9.onRequest) {
        onRequestHooks.push(plugin9.onRequest);
      }
      if (plugin9.onResponse) {
        onResponseHooks.push(plugin9.onResponse);
      }
    }
  }
  const handleRequest = onRequestHooks.length > 0 || onResponseHooks.length > 0 ? function handleRequest(request, serverContext) {
    let requestHandler = givenHandleRequest;
    let response;
    if (onRequestHooks.length === 0) {
      return handleEarlyResponse();
    }
    let url = new Proxy(EMPTY_OBJECT, {
      get(_target, prop, _receiver) {
        url = new fetchAPI.URL(request.url, "http://localhost");
        return Reflect.get(url, prop, url);
      }
    });
    const onRequestHooksIteration$ = iterateAsyncVoid(onRequestHooks, (onRequestHook, stopEarly) => onRequestHook({
      request,
      serverContext,
      fetchAPI,
      url,
      requestHandler,
      setRequestHandler(newRequestHandler) {
        requestHandler = newRequestHandler;
      },
      endResponse(newResponse) {
        response = newResponse;
        if (newResponse) {
          stopEarly();
        }
      }
    }));
    function handleResponse(response2) {
      if (onRequestHooks.length === 0) {
        return response2;
      }
      const onResponseHookPayload = {
        request,
        response: response2,
        serverContext
      };
      const onResponseHooksIteration$ = iterateAsyncVoid(onResponseHooks, (onResponseHook) => onResponseHook(onResponseHookPayload));
      if (isPromise4(onResponseHooksIteration$)) {
        return onResponseHooksIteration$.then(() => response2);
      }
      return response2;
    }
    function handleEarlyResponse() {
      if (!response) {
        const response$ = requestHandler(request, serverContext);
        if (isPromise4(response$)) {
          return response$.then(handleResponse);
        }
        return handleResponse(response$);
      }
      return handleResponse(response);
    }
    if (isPromise4(onRequestHooksIteration$)) {
      return onRequestHooksIteration$.then(handleEarlyResponse);
    }
    return handleEarlyResponse();
  } : givenHandleRequest;
  function handleNodeRequest(nodeRequest, ...ctx) {
    const serverContext = ctx.length > 1 ? completeAssign(...ctx) : ctx[0] || {};
    const request = normalizeNodeRequest(nodeRequest, fetchAPI.Request);
    return handleRequest(request, serverContext);
  }
  function requestListener(nodeRequest, serverResponse, ...ctx) {
    const waitUntilPromises = [];
    const defaultServerContext = {
      req: nodeRequest,
      res: serverResponse
    };
    addWaitUntil(defaultServerContext, waitUntilPromises);
    let response$;
    try {
      response$ = handleNodeRequest(nodeRequest, defaultServerContext, ...ctx);
    } catch (err) {
      response$ = handleErrorFromRequestHandler(err, fetchAPI.Response);
    }
    if (isPromise4(response$)) {
      return response$.catch((e) => handleErrorFromRequestHandler(e, fetchAPI.Response)).then((response) => sendNodeResponse(response, serverResponse, nodeRequest)).catch((err) => {
        console.error(`Unexpected error while handling request: ${err.message || err}`);
      });
    }
    try {
      return sendNodeResponse(response$, serverResponse, nodeRequest);
    } catch (err) {
      console.error(`Unexpected error while handling request: ${err.message || err}`);
    }
  }
  function handleUWS(res, req, ...ctx) {
    const waitUntilPromises = [];
    const defaultServerContext = {
      res,
      req
    };
    addWaitUntil(defaultServerContext, waitUntilPromises);
    const serverContext = ctx.length > 0 ? completeAssign(defaultServerContext, ...ctx) : defaultServerContext;
    const request = getRequestFromUWSRequest({
      req,
      res,
      fetchAPI
    });
    let resAborted = false;
    res.onAborted(() => {
      resAborted = true;
      request.signal.sendAbort();
    });
    let response$;
    try {
      response$ = handleRequest(request, serverContext);
    } catch (err) {
      response$ = handleErrorFromRequestHandler(err, fetchAPI.Response);
    }
    if (isPromise4(response$)) {
      return response$.catch((e) => handleErrorFromRequestHandler(e, fetchAPI.Response)).then((response) => {
        if (!resAborted) {
          return sendResponseToUwsOpts(res, response);
        }
      }).catch((err) => {
        console.error(`Unexpected error while handling request: ${err.message || err}`);
      });
    }
    try {
      return sendResponseToUwsOpts(res, response$);
    } catch (err) {
      console.error(`Unexpected error while handling request: ${err.message || err}`);
    }
  }
  function handleEvent(event, ...ctx) {
    if (!event.respondWith || !event.request) {
      throw new TypeError(`Expected FetchEvent, got ${event}`);
    }
    const serverContext = ctx.length > 0 ? Object.assign({}, event, ...ctx) : event;
    const response$ = handleRequest(event.request, serverContext);
    event.respondWith(response$);
  }
  function handleRequestWithWaitUntil(request, ...ctx) {
    const serverContext = (ctx.length > 1 ? completeAssign(...ctx) : ctx[0]) || {};
    if (serverContext.waitUntil == null) {
      const waitUntilPromises = [];
      addWaitUntil(serverContext, waitUntilPromises);
      const response$ = handleRequest(request, serverContext);
      if (waitUntilPromises.length > 0) {
        return handleWaitUntils(waitUntilPromises).then(() => response$);
      }
      return response$;
    }
    return handleRequest(request, serverContext);
  }
  const fetchFn = (input, ...maybeCtx) => {
    if (typeof input === "string" || ("href" in input)) {
      const [initOrCtx, ...restOfCtx] = maybeCtx;
      if (isRequestInit(initOrCtx)) {
        return handleRequestWithWaitUntil(new fetchAPI.Request(input, initOrCtx), ...restOfCtx);
      }
      return handleRequestWithWaitUntil(new fetchAPI.Request(input), ...maybeCtx);
    }
    return handleRequestWithWaitUntil(input, ...maybeCtx);
  };
  const genericRequestHandler = (input, ...maybeCtx) => {
    const [initOrCtxOrRes, ...restOfCtx] = maybeCtx;
    if (isNodeRequest(input)) {
      if (!isServerResponse(initOrCtxOrRes)) {
        throw new TypeError(`Expected ServerResponse, got ${initOrCtxOrRes}`);
      }
      return requestListener(input, initOrCtxOrRes, ...restOfCtx);
    }
    if (isUWSResponse(input)) {
      return handleUWS(input, initOrCtxOrRes, ...restOfCtx);
    }
    if (isServerResponse(initOrCtxOrRes)) {
      throw new TypeError("Got Node response without Node request");
    }
    if (isRequestAccessible(input)) {
      if (isFetchEvent(input)) {
        return handleEvent(input, ...maybeCtx);
      }
      return handleRequestWithWaitUntil(input.request, input, ...maybeCtx);
    }
    return fetchFn(input, ...maybeCtx);
  };
  const adapterObj = {
    handleRequest,
    fetch: fetchFn,
    handleNodeRequest,
    requestListener,
    handleEvent,
    handleUWS,
    handle: genericRequestHandler
  };
  const serverAdapter = new Proxy(genericRequestHandler, {
    has: (_, prop) => {
      return (prop in adapterObj) || (prop in genericRequestHandler) || serverAdapterBaseObject && (prop in serverAdapterBaseObject);
    },
    get: (_, prop) => {
      const adapterProp = adapterObj[prop];
      if (adapterProp) {
        if (adapterProp.bind) {
          return adapterProp.bind(adapterObj);
        }
        return adapterProp;
      }
      const handleProp = genericRequestHandler[prop];
      if (handleProp) {
        if (handleProp.bind) {
          return handleProp.bind(genericRequestHandler);
        }
        return handleProp;
      }
      if (serverAdapterBaseObject) {
        const serverAdapterBaseObjectProp = serverAdapterBaseObject[prop];
        if (serverAdapterBaseObjectProp) {
          if (serverAdapterBaseObjectProp.bind) {
            return function(...args7) {
              const returnedVal = serverAdapterBaseObject[prop](...args7);
              if (returnedVal === serverAdapterBaseObject) {
                return serverAdapter;
              }
              return returnedVal;
            };
          }
          return serverAdapterBaseObjectProp;
        }
      }
    },
    apply(_, __, args7) {
      return genericRequestHandler(...args7);
    }
  });
  return serverAdapter;
};
var EMPTY_OBJECT = {};

// node_modules/@whatwg-node/server/esm/plugins/useCors.js
function getCORSHeadersByRequestAndOptions(request, corsOptions) {
  const currentOrigin = request.headers.get("origin");
  if (corsOptions === false || currentOrigin == null) {
    return null;
  }
  const headers = {};
  if (corsOptions.origin == null || corsOptions.origin.length === 0 || corsOptions.origin.includes("*")) {
    headers["Access-Control-Allow-Origin"] = currentOrigin;
    headers["Vary"] = "Origin";
  } else if (typeof corsOptions.origin === "string") {
    headers["Access-Control-Allow-Origin"] = corsOptions.origin;
  } else if (Array.isArray(corsOptions.origin)) {
    if (corsOptions.origin.length === 1) {
      headers["Access-Control-Allow-Origin"] = corsOptions.origin[0];
    } else if (corsOptions.origin.includes(currentOrigin)) {
      headers["Access-Control-Allow-Origin"] = currentOrigin;
      headers["Vary"] = "Origin";
    } else {
      headers["Access-Control-Allow-Origin"] = "null";
    }
  }
  if (corsOptions.methods?.length) {
    headers["Access-Control-Allow-Methods"] = corsOptions.methods.join(", ");
  } else {
    const requestMethod = request.headers.get("access-control-request-method");
    if (requestMethod) {
      headers["Access-Control-Allow-Methods"] = requestMethod;
    }
  }
  if (corsOptions.allowedHeaders?.length) {
    headers["Access-Control-Allow-Headers"] = corsOptions.allowedHeaders.join(", ");
  } else {
    const requestHeaders = request.headers.get("access-control-request-headers");
    if (requestHeaders) {
      headers["Access-Control-Allow-Headers"] = requestHeaders;
      if (headers["Vary"]) {
        headers["Vary"] += ", Access-Control-Request-Headers";
      }
      headers["Vary"] = "Access-Control-Request-Headers";
    }
  }
  if (corsOptions.credentials != null) {
    if (corsOptions.credentials === true) {
      headers["Access-Control-Allow-Credentials"] = "true";
    }
  } else if (headers["Access-Control-Allow-Origin"] !== "*") {
    headers["Access-Control-Allow-Credentials"] = "true";
  }
  if (corsOptions.exposedHeaders) {
    headers["Access-Control-Expose-Headers"] = corsOptions.exposedHeaders.join(", ");
  }
  if (corsOptions.maxAge) {
    headers["Access-Control-Max-Age"] = corsOptions.maxAge.toString();
  }
  return headers;
}
async function getCORSResponseHeaders(request, corsOptionsFactory, serverContext) {
  const corsOptions = await corsOptionsFactory(request, serverContext);
  return getCORSHeadersByRequestAndOptions(request, corsOptions);
}
function useCORS(options) {
  let corsOptionsFactory = () => ({});
  if (options != null) {
    if (typeof options === "function") {
      corsOptionsFactory = options;
    } else if (typeof options === "object") {
      const corsOptions = {
        ...options
      };
      corsOptionsFactory = () => corsOptions;
    } else if (options === false) {
      corsOptionsFactory = () => false;
    }
  }
  return {
    onRequest({ request, fetchAPI, endResponse: endResponse2 }) {
      if (request.method.toUpperCase() === "OPTIONS") {
        const response = new fetchAPI.Response(null, {
          status: 204,
          headers: {
            "Content-Length": "0"
          }
        });
        endResponse2(response);
      }
    },
    async onResponse({ request, serverContext, response }) {
      const headers = await getCORSResponseHeaders(request, corsOptionsFactory, serverContext);
      if (headers != null) {
        for (const headerName in headers) {
          response.headers.set(headerName, headers[headerName]);
        }
      }
    }
  };
}

// node_modules/@whatwg-node/server/esm/plugins/useErrorHandling.js
function createDefaultErrorHandler(ResponseCtor = $Response) {
  return function defaultErrorHandler(e) {
    return new ResponseCtor(typeof e.details === "object" ? JSON.stringify(e.details) : e.stack || e.message || e.toString(), {
      status: e.statusCode || e.status || 500,
      headers: e.headers || {}
    });
  };
}
function useErrorHandling(onError) {
  return {
    onRequest({ requestHandler, setRequestHandler, fetchAPI }) {
      const errorHandler = onError || createDefaultErrorHandler(fetchAPI.Response);
      setRequestHandler(async function handlerWithErrorHandling(request, serverContext) {
        try {
          const response = await requestHandler(request, serverContext);
          return response;
        } catch (e) {
          const response = await errorHandler(e, request, serverContext);
          return response;
        }
      });
    }
  };
}

// node_modules/graphql-yoga/esm/plugins/request-parser/utils.js
function handleURLSearchParams(searchParams) {
  const operationName = searchParams.get("operationName") || undefined;
  const query = searchParams.get("query") || undefined;
  const variablesStr = searchParams.get("variables") || undefined;
  const extensionsStr = searchParams.get("extensions") || undefined;
  return {
    operationName,
    query,
    variables: variablesStr ? JSON.parse(variablesStr) : undefined,
    extensions: extensionsStr ? JSON.parse(extensionsStr) : undefined
  };
}
function parseURLSearchParams(requestBody) {
  const searchParams = new $URLSearchParams(requestBody);
  return handleURLSearchParams(searchParams);
}
function isContentTypeMatch(request, expectedContentType) {
  let contentType = request.headers.get("content-type");
  contentType = contentType?.split(",")[0] || null;
  return contentType === expectedContentType || !!contentType?.startsWith(`${expectedContentType};`);
}

// node_modules/graphql-yoga/esm/plugins/request-parser/get.js
function isGETRequest(request) {
  return request.method === "GET";
}
function parseGETRequest(request) {
  const [, queryString = ""] = request.url.split("?");
  const searchParams = new $URLSearchParams(queryString);
  return handleURLSearchParams(searchParams);
}

// node_modules/graphql-yoga/esm/plugins/request-parser/post-form-url-encoded.js
function isPOSTFormUrlEncodedRequest(request) {
  return request.method === "POST" && isContentTypeMatch(request, "application/x-www-form-urlencoded");
}
async function parsePOSTFormUrlEncodedRequest(request) {
  const requestBody = await request.text();
  return parseURLSearchParams(requestBody);
}

// node_modules/graphql-yoga/esm/plugins/request-parser/post-graphql-string.js
function isPOSTGraphQLStringRequest(request) {
  return request.method === "POST" && isContentTypeMatch(request, "application/graphql");
}
async function parsePOSTGraphQLStringRequest(request) {
  const requestBody = await request.text();
  return {
    query: requestBody
  };
}

// node_modules/graphql-yoga/esm/plugins/request-parser/post-json.js
function isPOSTJsonRequest(request) {
  return request.method === "POST" && (isContentTypeMatch(request, "application/json") || isContentTypeMatch(request, "application/graphql+json"));
}
async function parsePOSTJsonRequest(request) {
  let requestBody;
  try {
    requestBody = await request.json();
  } catch (err) {
    const extensions3 = {
      http: {
        spec: true,
        status: 400
      }
    };
    if (err instanceof Error) {
      extensions3.originalError = {
        name: err.name,
        message: err.message
      };
    }
    throw createGraphQLError("POST body sent invalid JSON.", {
      extensions: extensions3
    });
  }
  if (requestBody == null) {
    throw createGraphQLError(`POST body is expected to be object but received ${requestBody}`, {
      extensions: {
        http: {
          status: 400
        }
      }
    });
  }
  const requestBodyTypeof = typeof requestBody;
  if (requestBodyTypeof !== "object") {
    throw createGraphQLError(`POST body is expected to be object but received ${requestBodyTypeof}`, {
      extensions: {
        http: {
          status: 400
        }
      }
    });
  }
  return requestBody;
}

// node_modules/dset/dist/index.mjs
function dset(obj, keys, val) {
  keys.split && (keys = keys.split("."));
  var i = 0, l = keys.length, t = obj, x, k;
  while (i < l) {
    k = keys[i++];
    if (k === "__proto__" || k === "constructor" || k === "prototype")
      break;
    t = t[k] = i === l ? val : typeof (x = t[k]) === typeof keys ? x : keys[i] * 0 !== 0 || !!~("" + keys[i]).indexOf(".") ? {} : [];
  }
}

// node_modules/graphql-yoga/esm/plugins/request-parser/post-multipart.js
function isPOSTMultipartRequest(request) {
  return request.method === "POST" && isContentTypeMatch(request, "multipart/form-data");
}
async function parsePOSTMultipartRequest(request) {
  let requestBody;
  try {
    requestBody = await request.formData();
  } catch (e) {
    if (e instanceof Error && e.message.startsWith("File size limit exceeded: ")) {
      throw createGraphQLError(e.message, {
        extensions: {
          http: {
            status: 413
          }
        }
      });
    }
    throw e;
  }
  const operationsStr = requestBody.get("operations");
  if (!operationsStr) {
    throw createGraphQLError('Missing multipart form field "operations"');
  }
  if (typeof operationsStr !== "string") {
    throw createGraphQLError('Multipart form field "operations" must be a string');
  }
  let operations;
  try {
    operations = JSON.parse(operationsStr);
  } catch (err) {
    throw createGraphQLError('Multipart form field "operations" must be a valid JSON string');
  }
  const mapStr = requestBody.get("map");
  if (mapStr != null) {
    if (typeof mapStr !== "string") {
      throw createGraphQLError('Multipart form field "map" must be a string');
    }
    let map2;
    try {
      map2 = JSON.parse(mapStr);
    } catch (err) {
      throw createGraphQLError('Multipart form field "map" must be a valid JSON string');
    }
    for (const fileIndex in map2) {
      const file = requestBody.get(fileIndex);
      const keys = map2[fileIndex];
      for (const key of keys) {
        dset(operations, key, file);
      }
    }
  }
  return operations;
}

// node_modules/graphql-yoga/esm/plugins/request-validation/use-check-graphql-query-params.js
function assertInvalidParams(params) {
  if (params == null || typeof params !== "object") {
    throw createGraphQLError('Invalid "params" in the request body', {
      extensions: {
        http: {
          spec: true,
          status: 400
        }
      }
    });
  }
  for (const paramKey in params) {
    if (params[paramKey] == null) {
      continue;
    }
    if (!expectedParameters.has(paramKey)) {
      throw createGraphQLError(`Unexpected parameter "${paramKey}" in the request body.`, {
        extensions: {
          http: {
            status: 400
          }
        }
      });
    }
  }
}
function checkGraphQLQueryParams(params) {
  if (!isObject3(params)) {
    throw createGraphQLError(`Expected params to be an object but given ${extendedTypeof(params)}.`, {
      extensions: {
        http: {
          status: 400,
          headers: {
            Allow: "GET, POST"
          }
        }
      }
    });
  }
  assertInvalidParams(params);
  if (params.query == null) {
    throw createGraphQLError("Must provide query string.", {
      extensions: {
        http: {
          spec: true,
          status: 400,
          headers: {
            Allow: "GET, POST"
          }
        }
      }
    });
  }
  const queryType3 = extendedTypeof(params.query);
  if (queryType3 !== "string") {
    throw createGraphQLError(`Expected "query" param to be a string, but given ${queryType3}.`, {
      extensions: {
        http: {
          status: 400,
          headers: {
            Allow: "GET, POST"
          }
        }
      }
    });
  }
  const variablesParamType = extendedTypeof(params.variables);
  if (!["object", "null", "undefined"].includes(variablesParamType)) {
    throw createGraphQLError(`Expected "variables" param to be empty or an object, but given ${variablesParamType}.`, {
      extensions: {
        http: {
          status: 400,
          headers: {
            Allow: "GET, POST"
          }
        }
      }
    });
  }
  const extensionsParamType = extendedTypeof(params.extensions);
  if (!["object", "null", "undefined"].includes(extensionsParamType)) {
    throw createGraphQLError(`Expected "extensions" param to be empty or an object, but given ${extensionsParamType}.`, {
      extensions: {
        http: {
          status: 400,
          headers: {
            Allow: "GET, POST"
          }
        }
      }
    });
  }
  return params;
}
function useCheckGraphQLQueryParams() {
  return {
    onParams({ params }) {
      checkGraphQLQueryParams(params);
    }
  };
}
var extendedTypeof = function(val) {
  if (val === null) {
    return "null";
  }
  if (Array.isArray(val)) {
    return "array";
  }
  return typeof val;
};
var isObject3 = function(val) {
  return extendedTypeof(val) === "object";
};
var expectedParameters = new Set(["query", "variables", "operationName", "extensions"]);

// node_modules/graphql-yoga/esm/plugins/request-validation/use-check-method-for-graphql.js
function isValidMethodForGraphQL(method) {
  return method === "GET" || method === "POST";
}
function useCheckMethodForGraphQL() {
  return {
    onRequestParse({ request }) {
      if (!isValidMethodForGraphQL(request.method)) {
        throw createGraphQLError("GraphQL only supports GET and POST requests.", {
          extensions: {
            http: {
              status: 405,
              headers: {
                Allow: "GET, POST"
              }
            }
          }
        });
      }
    }
  };
}

// node_modules/graphql-yoga/esm/plugins/request-validation/use-http-validation-error.js
function useHTTPValidationError() {
  return {
    onValidate() {
      return ({ valid, result }) => {
        if (!valid) {
          for (const error2 of result) {
            error2.extensions.http = {
              ...error2.extensions.http,
              spec: error2.extensions.http?.spec ?? true,
              status: error2.extensions.http?.status ?? 400
            };
          }
        }
      };
    }
  };
}

// node_modules/graphql-yoga/esm/plugins/request-validation/use-limit-batching.js
function useLimitBatching(limit) {
  return {
    onRequestParse() {
      return {
        onRequestParseDone({ requestParserResult }) {
          if (Array.isArray(requestParserResult)) {
            if (!limit) {
              throw createGraphQLError(`Batching is not supported.`, {
                extensions: {
                  http: {
                    status: 400
                  }
                }
              });
            }
            if (requestParserResult.length > limit) {
              throw createGraphQLError(`Batching is limited to ${limit} operations per request.`, {
                extensions: {
                  http: {
                    status: 413
                  }
                }
              });
            }
          }
        }
      };
    }
  };
}

// node_modules/graphql-yoga/esm/plugins/request-validation/use-prevent-mutation-via-get.js
function assertMutationViaGet(method, document2, operationName) {
  const operation = document2 ? getOperationAST(document2, operationName) ?? undefined : undefined;
  if (!operation) {
    throw createGraphQLError("Could not determine what operation to execute.", {
      extensions: {
        http: {
          status: 400
        }
      }
    });
  }
  if (operation.operation === "mutation" && method === "GET") {
    throw createGraphQLError("Can only perform a mutation operation from a POST request.", {
      extensions: {
        http: {
          status: 405,
          headers: {
            Allow: "POST"
          }
        }
      }
    });
  }
}
function usePreventMutationViaGET() {
  return {
    onParse() {
      return ({ result, context: {
        request,
        params: { operationName } = {}
      } }) => {
        if (!request) {
          return;
        }
        if (result instanceof Error) {
          if (result instanceof GraphQLError) {
            result.extensions.http = {
              spec: true,
              status: 400
            };
          }
          throw result;
        }
        assertMutationViaGet(request.method, result, operationName);
      };
    }
  };
}

// node_modules/graphql-yoga/esm/plugins/use-health-check.js
function useHealthCheck({ id = Date.now().toString(), logger: logger5 = console, endpoint = "/health" } = {}) {
  return {
    onRequest({ endResponse: endResponse2, fetchAPI, request }) {
      if (request.url.endsWith(endpoint)) {
        logger5.debug("Responding Health Check");
        const response = new fetchAPI.Response(null, {
          status: 200,
          headers: {
            "x-yoga-id": id
          }
        });
        endResponse2(response);
      }
    }
  };
}

// node_modules/lru-cache/dist/mjs/index.js
var perf = typeof performance === "object" && performance && typeof performance.now === "function" ? performance : Date;
var warned = new Set;
var PROCESS = typeof process === "object" && !!process ? process : {};
var emitWarning = (msg, type, code, fn) => {
  typeof PROCESS.emitWarning === "function" ? PROCESS.emitWarning(msg, type, code, fn) : console.error(`[${code}] ${type}: ${msg}`);
};
var AC = globalThis.AbortController;
var AS = globalThis.AbortSignal;
if (typeof AC === "undefined") {
  AS = class AbortSignal {
    onabort;
    _onabort = [];
    reason;
    aborted = false;
    addEventListener(_, fn) {
      this._onabort.push(fn);
    }
  };
  AC = class AbortController2 {
    constructor() {
      warnACPolyfill();
    }
    signal = new AS;
    abort(reason) {
      if (this.signal.aborted)
        return;
      this.signal.reason = reason;
      this.signal.aborted = true;
      for (const fn of this.signal._onabort) {
        fn(reason);
      }
      this.signal.onabort?.(reason);
    }
  };
  let printACPolyfillWarning = PROCESS.env?.LRU_CACHE_IGNORE_AC_WARNING !== "1";
  const warnACPolyfill = () => {
    if (!printACPolyfillWarning)
      return;
    printACPolyfillWarning = false;
    emitWarning("AbortController is not defined. If using lru-cache in node 14, load an AbortController polyfill from the `node-abort-controller` package. A minimal polyfill is provided for use by LRUCache.fetch(), but it should not be relied upon in other contexts (eg, passing it to other APIs that use AbortController/AbortSignal might have undesirable effects). You may disable this with LRU_CACHE_IGNORE_AC_WARNING=1 in the env.", "NO_ABORT_CONTROLLER", "ENOTSUP", warnACPolyfill);
  };
}
var shouldWarn = (code) => !warned.has(code);
var TYPE = Symbol("type");
var isPosInt = (n) => n && n === Math.floor(n) && n > 0 && isFinite(n);
var getUintArray = (max) => !isPosInt(max) ? null : max <= Math.pow(2, 8) ? Uint8Array : max <= Math.pow(2, 16) ? Uint16Array : max <= Math.pow(2, 32) ? Uint32Array : max <= Number.MAX_SAFE_INTEGER ? ZeroArray : null;

class ZeroArray extends Array {
  constructor(size) {
    super(size);
    this.fill(0);
  }
}

class Stack {
  heap;
  length;
  static #constructing = false;
  static create(max) {
    const HeapCls = getUintArray(max);
    if (!HeapCls)
      return [];
    Stack.#constructing = true;
    const s = new Stack(max, HeapCls);
    Stack.#constructing = false;
    return s;
  }
  constructor(max, HeapCls) {
    if (!Stack.#constructing) {
      throw new TypeError("instantiate Stack using Stack.create(n)");
    }
    this.heap = new HeapCls(max);
    this.length = 0;
  }
  push(n) {
    this.heap[this.length++] = n;
  }
  pop() {
    return this.heap[--this.length];
  }
}

class LRUCache {
  #max;
  #maxSize;
  #dispose;
  #disposeAfter;
  #fetchMethod;
  ttl;
  ttlResolution;
  ttlAutopurge;
  updateAgeOnGet;
  updateAgeOnHas;
  allowStale;
  noDisposeOnSet;
  noUpdateTTL;
  maxEntrySize;
  sizeCalculation;
  noDeleteOnFetchRejection;
  noDeleteOnStaleGet;
  allowStaleOnFetchAbort;
  allowStaleOnFetchRejection;
  ignoreFetchAbort;
  #size;
  #calculatedSize;
  #keyMap;
  #keyList;
  #valList;
  #next;
  #prev;
  #head;
  #tail;
  #free;
  #disposed;
  #sizes;
  #starts;
  #ttls;
  #hasDispose;
  #hasFetchMethod;
  #hasDisposeAfter;
  static unsafeExposeInternals(c) {
    return {
      starts: c.#starts,
      ttls: c.#ttls,
      sizes: c.#sizes,
      keyMap: c.#keyMap,
      keyList: c.#keyList,
      valList: c.#valList,
      next: c.#next,
      prev: c.#prev,
      get head() {
        return c.#head;
      },
      get tail() {
        return c.#tail;
      },
      free: c.#free,
      isBackgroundFetch: (p) => c.#isBackgroundFetch(p),
      backgroundFetch: (k, index, options, context) => c.#backgroundFetch(k, index, options, context),
      moveToTail: (index) => c.#moveToTail(index),
      indexes: (options) => c.#indexes(options),
      rindexes: (options) => c.#rindexes(options),
      isStale: (index) => c.#isStale(index)
    };
  }
  get max() {
    return this.#max;
  }
  get maxSize() {
    return this.#maxSize;
  }
  get calculatedSize() {
    return this.#calculatedSize;
  }
  get size() {
    return this.#size;
  }
  get fetchMethod() {
    return this.#fetchMethod;
  }
  get dispose() {
    return this.#dispose;
  }
  get disposeAfter() {
    return this.#disposeAfter;
  }
  constructor(options) {
    const { max = 0, ttl, ttlResolution = 1, ttlAutopurge, updateAgeOnGet, updateAgeOnHas, allowStale, dispose, disposeAfter, noDisposeOnSet, noUpdateTTL, maxSize = 0, maxEntrySize = 0, sizeCalculation, fetchMethod, noDeleteOnFetchRejection, noDeleteOnStaleGet, allowStaleOnFetchRejection, allowStaleOnFetchAbort, ignoreFetchAbort } = options;
    if (max !== 0 && !isPosInt(max)) {
      throw new TypeError("max option must be a nonnegative integer");
    }
    const UintArray = max ? getUintArray(max) : Array;
    if (!UintArray) {
      throw new Error("invalid max value: " + max);
    }
    this.#max = max;
    this.#maxSize = maxSize;
    this.maxEntrySize = maxEntrySize || this.#maxSize;
    this.sizeCalculation = sizeCalculation;
    if (this.sizeCalculation) {
      if (!this.#maxSize && !this.maxEntrySize) {
        throw new TypeError("cannot set sizeCalculation without setting maxSize or maxEntrySize");
      }
      if (typeof this.sizeCalculation !== "function") {
        throw new TypeError("sizeCalculation set to non-function");
      }
    }
    if (fetchMethod !== undefined && typeof fetchMethod !== "function") {
      throw new TypeError("fetchMethod must be a function if specified");
    }
    this.#fetchMethod = fetchMethod;
    this.#hasFetchMethod = !!fetchMethod;
    this.#keyMap = new Map;
    this.#keyList = new Array(max).fill(undefined);
    this.#valList = new Array(max).fill(undefined);
    this.#next = new UintArray(max);
    this.#prev = new UintArray(max);
    this.#head = 0;
    this.#tail = 0;
    this.#free = Stack.create(max);
    this.#size = 0;
    this.#calculatedSize = 0;
    if (typeof dispose === "function") {
      this.#dispose = dispose;
    }
    if (typeof disposeAfter === "function") {
      this.#disposeAfter = disposeAfter;
      this.#disposed = [];
    } else {
      this.#disposeAfter = undefined;
      this.#disposed = undefined;
    }
    this.#hasDispose = !!this.#dispose;
    this.#hasDisposeAfter = !!this.#disposeAfter;
    this.noDisposeOnSet = !!noDisposeOnSet;
    this.noUpdateTTL = !!noUpdateTTL;
    this.noDeleteOnFetchRejection = !!noDeleteOnFetchRejection;
    this.allowStaleOnFetchRejection = !!allowStaleOnFetchRejection;
    this.allowStaleOnFetchAbort = !!allowStaleOnFetchAbort;
    this.ignoreFetchAbort = !!ignoreFetchAbort;
    if (this.maxEntrySize !== 0) {
      if (this.#maxSize !== 0) {
        if (!isPosInt(this.#maxSize)) {
          throw new TypeError("maxSize must be a positive integer if specified");
        }
      }
      if (!isPosInt(this.maxEntrySize)) {
        throw new TypeError("maxEntrySize must be a positive integer if specified");
      }
      this.#initializeSizeTracking();
    }
    this.allowStale = !!allowStale;
    this.noDeleteOnStaleGet = !!noDeleteOnStaleGet;
    this.updateAgeOnGet = !!updateAgeOnGet;
    this.updateAgeOnHas = !!updateAgeOnHas;
    this.ttlResolution = isPosInt(ttlResolution) || ttlResolution === 0 ? ttlResolution : 1;
    this.ttlAutopurge = !!ttlAutopurge;
    this.ttl = ttl || 0;
    if (this.ttl) {
      if (!isPosInt(this.ttl)) {
        throw new TypeError("ttl must be a positive integer if specified");
      }
      this.#initializeTTLTracking();
    }
    if (this.#max === 0 && this.ttl === 0 && this.#maxSize === 0) {
      throw new TypeError("At least one of max, maxSize, or ttl is required");
    }
    if (!this.ttlAutopurge && !this.#max && !this.#maxSize) {
      const code = "LRU_CACHE_UNBOUNDED";
      if (shouldWarn(code)) {
        warned.add(code);
        const msg = "TTL caching without ttlAutopurge, max, or maxSize can result in unbounded memory consumption.";
        emitWarning(msg, "UnboundedCacheWarning", code, LRUCache);
      }
    }
  }
  getRemainingTTL(key) {
    return this.#keyMap.has(key) ? Infinity : 0;
  }
  #initializeTTLTracking() {
    const ttls = new ZeroArray(this.#max);
    const starts = new ZeroArray(this.#max);
    this.#ttls = ttls;
    this.#starts = starts;
    this.#setItemTTL = (index, ttl, start = perf.now()) => {
      starts[index] = ttl !== 0 ? start : 0;
      ttls[index] = ttl;
      if (ttl !== 0 && this.ttlAutopurge) {
        const t = setTimeout(() => {
          if (this.#isStale(index)) {
            this.delete(this.#keyList[index]);
          }
        }, ttl + 1);
        if (t.unref) {
          t.unref();
        }
      }
    };
    this.#updateItemAge = (index) => {
      starts[index] = ttls[index] !== 0 ? perf.now() : 0;
    };
    this.#statusTTL = (status, index) => {
      if (ttls[index]) {
        const ttl = ttls[index];
        const start = starts[index];
        status.ttl = ttl;
        status.start = start;
        status.now = cachedNow || getNow();
        const age = status.now - start;
        status.remainingTTL = ttl - age;
      }
    };
    let cachedNow = 0;
    const getNow = () => {
      const n = perf.now();
      if (this.ttlResolution > 0) {
        cachedNow = n;
        const t = setTimeout(() => cachedNow = 0, this.ttlResolution);
        if (t.unref) {
          t.unref();
        }
      }
      return n;
    };
    this.getRemainingTTL = (key) => {
      const index = this.#keyMap.get(key);
      if (index === undefined) {
        return 0;
      }
      const ttl = ttls[index];
      const start = starts[index];
      if (ttl === 0 || start === 0) {
        return Infinity;
      }
      const age = (cachedNow || getNow()) - start;
      return ttl - age;
    };
    this.#isStale = (index) => {
      return ttls[index] !== 0 && starts[index] !== 0 && (cachedNow || getNow()) - starts[index] > ttls[index];
    };
  }
  #updateItemAge = () => {
  };
  #statusTTL = () => {
  };
  #setItemTTL = () => {
  };
  #isStale = () => false;
  #initializeSizeTracking() {
    const sizes = new ZeroArray(this.#max);
    this.#calculatedSize = 0;
    this.#sizes = sizes;
    this.#removeItemSize = (index) => {
      this.#calculatedSize -= sizes[index];
      sizes[index] = 0;
    };
    this.#requireSize = (k, v, size, sizeCalculation) => {
      if (this.#isBackgroundFetch(v)) {
        return 0;
      }
      if (!isPosInt(size)) {
        if (sizeCalculation) {
          if (typeof sizeCalculation !== "function") {
            throw new TypeError("sizeCalculation must be a function");
          }
          size = sizeCalculation(v, k);
          if (!isPosInt(size)) {
            throw new TypeError("sizeCalculation return invalid (expect positive integer)");
          }
        } else {
          throw new TypeError("invalid size value (must be positive integer). When maxSize or maxEntrySize is used, sizeCalculation or size must be set.");
        }
      }
      return size;
    };
    this.#addItemSize = (index, size, status) => {
      sizes[index] = size;
      if (this.#maxSize) {
        const maxSize = this.#maxSize - sizes[index];
        while (this.#calculatedSize > maxSize) {
          this.#evict(true);
        }
      }
      this.#calculatedSize += sizes[index];
      if (status) {
        status.entrySize = size;
        status.totalCalculatedSize = this.#calculatedSize;
      }
    };
  }
  #removeItemSize = (_i) => {
  };
  #addItemSize = (_i, _s, _st) => {
  };
  #requireSize = (_k, _v, size, sizeCalculation) => {
    if (size || sizeCalculation) {
      throw new TypeError("cannot set size without setting maxSize or maxEntrySize on cache");
    }
    return 0;
  };
  *#indexes({ allowStale = this.allowStale } = {}) {
    if (this.#size) {
      for (let i = this.#tail;; ) {
        if (!this.#isValidIndex(i)) {
          break;
        }
        if (allowStale || !this.#isStale(i)) {
          yield i;
        }
        if (i === this.#head) {
          break;
        } else {
          i = this.#prev[i];
        }
      }
    }
  }
  *#rindexes({ allowStale = this.allowStale } = {}) {
    if (this.#size) {
      for (let i = this.#head;; ) {
        if (!this.#isValidIndex(i)) {
          break;
        }
        if (allowStale || !this.#isStale(i)) {
          yield i;
        }
        if (i === this.#tail) {
          break;
        } else {
          i = this.#next[i];
        }
      }
    }
  }
  #isValidIndex(index) {
    return index !== undefined && this.#keyMap.get(this.#keyList[index]) === index;
  }
  *entries() {
    for (const i of this.#indexes()) {
      if (this.#valList[i] !== undefined && this.#keyList[i] !== undefined && !this.#isBackgroundFetch(this.#valList[i])) {
        yield [this.#keyList[i], this.#valList[i]];
      }
    }
  }
  *rentries() {
    for (const i of this.#rindexes()) {
      if (this.#valList[i] !== undefined && this.#keyList[i] !== undefined && !this.#isBackgroundFetch(this.#valList[i])) {
        yield [this.#keyList[i], this.#valList[i]];
      }
    }
  }
  *keys() {
    for (const i of this.#indexes()) {
      const k = this.#keyList[i];
      if (k !== undefined && !this.#isBackgroundFetch(this.#valList[i])) {
        yield k;
      }
    }
  }
  *rkeys() {
    for (const i of this.#rindexes()) {
      const k = this.#keyList[i];
      if (k !== undefined && !this.#isBackgroundFetch(this.#valList[i])) {
        yield k;
      }
    }
  }
  *values() {
    for (const i of this.#indexes()) {
      const v = this.#valList[i];
      if (v !== undefined && !this.#isBackgroundFetch(this.#valList[i])) {
        yield this.#valList[i];
      }
    }
  }
  *rvalues() {
    for (const i of this.#rindexes()) {
      const v = this.#valList[i];
      if (v !== undefined && !this.#isBackgroundFetch(this.#valList[i])) {
        yield this.#valList[i];
      }
    }
  }
  [Symbol.iterator]() {
    return this.entries();
  }
  find(fn, getOptions = {}) {
    for (const i of this.#indexes()) {
      const v = this.#valList[i];
      const value = this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;
      if (value === undefined)
        continue;
      if (fn(value, this.#keyList[i], this)) {
        return this.get(this.#keyList[i], getOptions);
      }
    }
  }
  forEach(fn, thisp = this) {
    for (const i of this.#indexes()) {
      const v = this.#valList[i];
      const value = this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;
      if (value === undefined)
        continue;
      fn.call(thisp, value, this.#keyList[i], this);
    }
  }
  rforEach(fn, thisp = this) {
    for (const i of this.#rindexes()) {
      const v = this.#valList[i];
      const value = this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;
      if (value === undefined)
        continue;
      fn.call(thisp, value, this.#keyList[i], this);
    }
  }
  purgeStale() {
    let deleted = false;
    for (const i of this.#rindexes({ allowStale: true })) {
      if (this.#isStale(i)) {
        this.delete(this.#keyList[i]);
        deleted = true;
      }
    }
    return deleted;
  }
  dump() {
    const arr = [];
    for (const i of this.#indexes({ allowStale: true })) {
      const key = this.#keyList[i];
      const v = this.#valList[i];
      const value = this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;
      if (value === undefined || key === undefined)
        continue;
      const entry = { value };
      if (this.#ttls && this.#starts) {
        entry.ttl = this.#ttls[i];
        const age = perf.now() - this.#starts[i];
        entry.start = Math.floor(Date.now() - age);
      }
      if (this.#sizes) {
        entry.size = this.#sizes[i];
      }
      arr.unshift([key, entry]);
    }
    return arr;
  }
  load(arr) {
    this.clear();
    for (const [key, entry] of arr) {
      if (entry.start) {
        const age = Date.now() - entry.start;
        entry.start = perf.now() - age;
      }
      this.set(key, entry.value, entry);
    }
  }
  set(k, v, setOptions = {}) {
    if (v === undefined) {
      this.delete(k);
      return this;
    }
    const { ttl = this.ttl, start, noDisposeOnSet = this.noDisposeOnSet, sizeCalculation = this.sizeCalculation, status } = setOptions;
    let { noUpdateTTL = this.noUpdateTTL } = setOptions;
    const size = this.#requireSize(k, v, setOptions.size || 0, sizeCalculation);
    if (this.maxEntrySize && size > this.maxEntrySize) {
      if (status) {
        status.set = "miss";
        status.maxEntrySizeExceeded = true;
      }
      this.delete(k);
      return this;
    }
    let index = this.#size === 0 ? undefined : this.#keyMap.get(k);
    if (index === undefined) {
      index = this.#size === 0 ? this.#tail : this.#free.length !== 0 ? this.#free.pop() : this.#size === this.#max ? this.#evict(false) : this.#size;
      this.#keyList[index] = k;
      this.#valList[index] = v;
      this.#keyMap.set(k, index);
      this.#next[this.#tail] = index;
      this.#prev[index] = this.#tail;
      this.#tail = index;
      this.#size++;
      this.#addItemSize(index, size, status);
      if (status)
        status.set = "add";
      noUpdateTTL = false;
    } else {
      this.#moveToTail(index);
      const oldVal = this.#valList[index];
      if (v !== oldVal) {
        if (this.#hasFetchMethod && this.#isBackgroundFetch(oldVal)) {
          oldVal.__abortController.abort(new Error("replaced"));
          const { __staleWhileFetching: s } = oldVal;
          if (s !== undefined && !noDisposeOnSet) {
            if (this.#hasDispose) {
              this.#dispose?.(s, k, "set");
            }
            if (this.#hasDisposeAfter) {
              this.#disposed?.push([s, k, "set"]);
            }
          }
        } else if (!noDisposeOnSet) {
          if (this.#hasDispose) {
            this.#dispose?.(oldVal, k, "set");
          }
          if (this.#hasDisposeAfter) {
            this.#disposed?.push([oldVal, k, "set"]);
          }
        }
        this.#removeItemSize(index);
        this.#addItemSize(index, size, status);
        this.#valList[index] = v;
        if (status) {
          status.set = "replace";
          const oldValue = oldVal && this.#isBackgroundFetch(oldVal) ? oldVal.__staleWhileFetching : oldVal;
          if (oldValue !== undefined)
            status.oldValue = oldValue;
        }
      } else if (status) {
        status.set = "update";
      }
    }
    if (ttl !== 0 && !this.#ttls) {
      this.#initializeTTLTracking();
    }
    if (this.#ttls) {
      if (!noUpdateTTL) {
        this.#setItemTTL(index, ttl, start);
      }
      if (status)
        this.#statusTTL(status, index);
    }
    if (!noDisposeOnSet && this.#hasDisposeAfter && this.#disposed) {
      const dt = this.#disposed;
      let task;
      while (task = dt?.shift()) {
        this.#disposeAfter?.(...task);
      }
    }
    return this;
  }
  pop() {
    try {
      while (this.#size) {
        const val = this.#valList[this.#head];
        this.#evict(true);
        if (this.#isBackgroundFetch(val)) {
          if (val.__staleWhileFetching) {
            return val.__staleWhileFetching;
          }
        } else if (val !== undefined) {
          return val;
        }
      }
    } finally {
      if (this.#hasDisposeAfter && this.#disposed) {
        const dt = this.#disposed;
        let task;
        while (task = dt?.shift()) {
          this.#disposeAfter?.(...task);
        }
      }
    }
  }
  #evict(free) {
    const head = this.#head;
    const k = this.#keyList[head];
    const v = this.#valList[head];
    if (this.#hasFetchMethod && this.#isBackgroundFetch(v)) {
      v.__abortController.abort(new Error("evicted"));
    } else if (this.#hasDispose || this.#hasDisposeAfter) {
      if (this.#hasDispose) {
        this.#dispose?.(v, k, "evict");
      }
      if (this.#hasDisposeAfter) {
        this.#disposed?.push([v, k, "evict"]);
      }
    }
    this.#removeItemSize(head);
    if (free) {
      this.#keyList[head] = undefined;
      this.#valList[head] = undefined;
      this.#free.push(head);
    }
    if (this.#size === 1) {
      this.#head = this.#tail = 0;
      this.#free.length = 0;
    } else {
      this.#head = this.#next[head];
    }
    this.#keyMap.delete(k);
    this.#size--;
    return head;
  }
  has(k, hasOptions = {}) {
    const { updateAgeOnHas = this.updateAgeOnHas, status } = hasOptions;
    const index = this.#keyMap.get(k);
    if (index !== undefined) {
      const v = this.#valList[index];
      if (this.#isBackgroundFetch(v) && v.__staleWhileFetching === undefined) {
        return false;
      }
      if (!this.#isStale(index)) {
        if (updateAgeOnHas) {
          this.#updateItemAge(index);
        }
        if (status) {
          status.has = "hit";
          this.#statusTTL(status, index);
        }
        return true;
      } else if (status) {
        status.has = "stale";
        this.#statusTTL(status, index);
      }
    } else if (status) {
      status.has = "miss";
    }
    return false;
  }
  peek(k, peekOptions = {}) {
    const { allowStale = this.allowStale } = peekOptions;
    const index = this.#keyMap.get(k);
    if (index !== undefined && (allowStale || !this.#isStale(index))) {
      const v = this.#valList[index];
      return this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;
    }
  }
  #backgroundFetch(k, index, options, context) {
    const v = index === undefined ? undefined : this.#valList[index];
    if (this.#isBackgroundFetch(v)) {
      return v;
    }
    const ac = new AC;
    const { signal } = options;
    signal?.addEventListener("abort", () => ac.abort(signal.reason), {
      signal: ac.signal
    });
    const fetchOpts = {
      signal: ac.signal,
      options,
      context
    };
    const cb = (v2, updateCache = false) => {
      const { aborted } = ac.signal;
      const ignoreAbort = options.ignoreFetchAbort && v2 !== undefined;
      if (options.status) {
        if (aborted && !updateCache) {
          options.status.fetchAborted = true;
          options.status.fetchError = ac.signal.reason;
          if (ignoreAbort)
            options.status.fetchAbortIgnored = true;
        } else {
          options.status.fetchResolved = true;
        }
      }
      if (aborted && !ignoreAbort && !updateCache) {
        return fetchFail(ac.signal.reason);
      }
      const bf2 = p;
      if (this.#valList[index] === p) {
        if (v2 === undefined) {
          if (bf2.__staleWhileFetching) {
            this.#valList[index] = bf2.__staleWhileFetching;
          } else {
            this.delete(k);
          }
        } else {
          if (options.status)
            options.status.fetchUpdated = true;
          this.set(k, v2, fetchOpts.options);
        }
      }
      return v2;
    };
    const eb = (er) => {
      if (options.status) {
        options.status.fetchRejected = true;
        options.status.fetchError = er;
      }
      return fetchFail(er);
    };
    const fetchFail = (er) => {
      const { aborted } = ac.signal;
      const allowStaleAborted = aborted && options.allowStaleOnFetchAbort;
      const allowStale = allowStaleAborted || options.allowStaleOnFetchRejection;
      const noDelete = allowStale || options.noDeleteOnFetchRejection;
      const bf2 = p;
      if (this.#valList[index] === p) {
        const del = !noDelete || bf2.__staleWhileFetching === undefined;
        if (del) {
          this.delete(k);
        } else if (!allowStaleAborted) {
          this.#valList[index] = bf2.__staleWhileFetching;
        }
      }
      if (allowStale) {
        if (options.status && bf2.__staleWhileFetching !== undefined) {
          options.status.returnedStale = true;
        }
        return bf2.__staleWhileFetching;
      } else if (bf2.__returned === bf2) {
        throw er;
      }
    };
    const pcall = (res, rej) => {
      const fmp = this.#fetchMethod?.(k, v, fetchOpts);
      if (fmp && fmp instanceof Promise) {
        fmp.then((v2) => res(v2 === undefined ? undefined : v2), rej);
      }
      ac.signal.addEventListener("abort", () => {
        if (!options.ignoreFetchAbort || options.allowStaleOnFetchAbort) {
          res(undefined);
          if (options.allowStaleOnFetchAbort) {
            res = (v2) => cb(v2, true);
          }
        }
      });
    };
    if (options.status)
      options.status.fetchDispatched = true;
    const p = new Promise(pcall).then(cb, eb);
    const bf = Object.assign(p, {
      __abortController: ac,
      __staleWhileFetching: v,
      __returned: undefined
    });
    if (index === undefined) {
      this.set(k, bf, { ...fetchOpts.options, status: undefined });
      index = this.#keyMap.get(k);
    } else {
      this.#valList[index] = bf;
    }
    return bf;
  }
  #isBackgroundFetch(p) {
    if (!this.#hasFetchMethod)
      return false;
    const b = p;
    return !!b && b instanceof Promise && b.hasOwnProperty("__staleWhileFetching") && b.__abortController instanceof AC;
  }
  async fetch(k, fetchOptions = {}) {
    const {
      allowStale = this.allowStale,
      updateAgeOnGet = this.updateAgeOnGet,
      noDeleteOnStaleGet = this.noDeleteOnStaleGet,
      ttl = this.ttl,
      noDisposeOnSet = this.noDisposeOnSet,
      size = 0,
      sizeCalculation = this.sizeCalculation,
      noUpdateTTL = this.noUpdateTTL,
      noDeleteOnFetchRejection = this.noDeleteOnFetchRejection,
      allowStaleOnFetchRejection = this.allowStaleOnFetchRejection,
      ignoreFetchAbort = this.ignoreFetchAbort,
      allowStaleOnFetchAbort = this.allowStaleOnFetchAbort,
      context,
      forceRefresh = false,
      status,
      signal
    } = fetchOptions;
    if (!this.#hasFetchMethod) {
      if (status)
        status.fetch = "get";
      return this.get(k, {
        allowStale,
        updateAgeOnGet,
        noDeleteOnStaleGet,
        status
      });
    }
    const options = {
      allowStale,
      updateAgeOnGet,
      noDeleteOnStaleGet,
      ttl,
      noDisposeOnSet,
      size,
      sizeCalculation,
      noUpdateTTL,
      noDeleteOnFetchRejection,
      allowStaleOnFetchRejection,
      allowStaleOnFetchAbort,
      ignoreFetchAbort,
      status,
      signal
    };
    let index = this.#keyMap.get(k);
    if (index === undefined) {
      if (status)
        status.fetch = "miss";
      const p = this.#backgroundFetch(k, index, options, context);
      return p.__returned = p;
    } else {
      const v = this.#valList[index];
      if (this.#isBackgroundFetch(v)) {
        const stale = allowStale && v.__staleWhileFetching !== undefined;
        if (status) {
          status.fetch = "inflight";
          if (stale)
            status.returnedStale = true;
        }
        return stale ? v.__staleWhileFetching : v.__returned = v;
      }
      const isStale = this.#isStale(index);
      if (!forceRefresh && !isStale) {
        if (status)
          status.fetch = "hit";
        this.#moveToTail(index);
        if (updateAgeOnGet) {
          this.#updateItemAge(index);
        }
        if (status)
          this.#statusTTL(status, index);
        return v;
      }
      const p = this.#backgroundFetch(k, index, options, context);
      const hasStale = p.__staleWhileFetching !== undefined;
      const staleVal = hasStale && allowStale;
      if (status) {
        status.fetch = isStale ? "stale" : "refresh";
        if (staleVal && isStale)
          status.returnedStale = true;
      }
      return staleVal ? p.__staleWhileFetching : p.__returned = p;
    }
  }
  get(k, getOptions = {}) {
    const { allowStale = this.allowStale, updateAgeOnGet = this.updateAgeOnGet, noDeleteOnStaleGet = this.noDeleteOnStaleGet, status } = getOptions;
    const index = this.#keyMap.get(k);
    if (index !== undefined) {
      const value = this.#valList[index];
      const fetching = this.#isBackgroundFetch(value);
      if (status)
        this.#statusTTL(status, index);
      if (this.#isStale(index)) {
        if (status)
          status.get = "stale";
        if (!fetching) {
          if (!noDeleteOnStaleGet) {
            this.delete(k);
          }
          if (status && allowStale)
            status.returnedStale = true;
          return allowStale ? value : undefined;
        } else {
          if (status && allowStale && value.__staleWhileFetching !== undefined) {
            status.returnedStale = true;
          }
          return allowStale ? value.__staleWhileFetching : undefined;
        }
      } else {
        if (status)
          status.get = "hit";
        if (fetching) {
          return value.__staleWhileFetching;
        }
        this.#moveToTail(index);
        if (updateAgeOnGet) {
          this.#updateItemAge(index);
        }
        return value;
      }
    } else if (status) {
      status.get = "miss";
    }
  }
  #connect(p, n) {
    this.#prev[n] = p;
    this.#next[p] = n;
  }
  #moveToTail(index) {
    if (index !== this.#tail) {
      if (index === this.#head) {
        this.#head = this.#next[index];
      } else {
        this.#connect(this.#prev[index], this.#next[index]);
      }
      this.#connect(this.#tail, index);
      this.#tail = index;
    }
  }
  delete(k) {
    let deleted = false;
    if (this.#size !== 0) {
      const index = this.#keyMap.get(k);
      if (index !== undefined) {
        deleted = true;
        if (this.#size === 1) {
          this.clear();
        } else {
          this.#removeItemSize(index);
          const v = this.#valList[index];
          if (this.#isBackgroundFetch(v)) {
            v.__abortController.abort(new Error("deleted"));
          } else if (this.#hasDispose || this.#hasDisposeAfter) {
            if (this.#hasDispose) {
              this.#dispose?.(v, k, "delete");
            }
            if (this.#hasDisposeAfter) {
              this.#disposed?.push([v, k, "delete"]);
            }
          }
          this.#keyMap.delete(k);
          this.#keyList[index] = undefined;
          this.#valList[index] = undefined;
          if (index === this.#tail) {
            this.#tail = this.#prev[index];
          } else if (index === this.#head) {
            this.#head = this.#next[index];
          } else {
            this.#next[this.#prev[index]] = this.#next[index];
            this.#prev[this.#next[index]] = this.#prev[index];
          }
          this.#size--;
          this.#free.push(index);
        }
      }
    }
    if (this.#hasDisposeAfter && this.#disposed?.length) {
      const dt = this.#disposed;
      let task;
      while (task = dt?.shift()) {
        this.#disposeAfter?.(...task);
      }
    }
    return deleted;
  }
  clear() {
    for (const index of this.#rindexes({ allowStale: true })) {
      const v = this.#valList[index];
      if (this.#isBackgroundFetch(v)) {
        v.__abortController.abort(new Error("deleted"));
      } else {
        const k = this.#keyList[index];
        if (this.#hasDispose) {
          this.#dispose?.(v, k, "delete");
        }
        if (this.#hasDisposeAfter) {
          this.#disposed?.push([v, k, "delete"]);
        }
      }
    }
    this.#keyMap.clear();
    this.#valList.fill(undefined);
    this.#keyList.fill(undefined);
    if (this.#ttls && this.#starts) {
      this.#ttls.fill(0);
      this.#starts.fill(0);
    }
    if (this.#sizes) {
      this.#sizes.fill(0);
    }
    this.#head = 0;
    this.#tail = 0;
    this.#free.length = 0;
    this.#calculatedSize = 0;
    this.#size = 0;
    if (this.#hasDisposeAfter && this.#disposed) {
      const dt = this.#disposed;
      let task;
      while (task = dt?.shift()) {
        this.#disposeAfter?.(...task);
      }
    }
  }
}

// node_modules/graphql-yoga/esm/utils/create-lru-cache.js
function createLRUCache({ max = DEFAULT_MAX, ttl = DEFAULT_TTL } = {}) {
  return new LRUCache({ max, ttl });
}
var DEFAULT_MAX = 1024;
var DEFAULT_TTL = 3600000;

// node_modules/graphql-yoga/esm/plugins/use-parser-and-validation-cache.js
function useParserAndValidationCache({ documentCache = createLRUCache(), errorCache = createLRUCache(), validationCache = true }) {
  const validationCacheByRules = createLRUCache();
  return {
    onParse({ params, setParsedDocument }) {
      const strDocument = params.source.toString();
      const document2 = documentCache.get(strDocument);
      if (document2) {
        setParsedDocument(document2);
        return;
      }
      const parserError = errorCache.get(strDocument);
      if (parserError) {
        throw parserError;
      }
      return ({ result }) => {
        if (result != null) {
          if (result instanceof Error) {
            errorCache.set(strDocument, result);
          } else {
            documentCache.set(strDocument, result);
          }
        }
      };
    },
    onValidate({
      params: { schema: schema4, documentAST, rules },
      setResult
    }) {
      if (schema4 == null) {
        return;
      }
      if (validationCache !== false) {
        const rulesKey = rules?.map((rule) => rule.name).join(",") || "";
        let validationCacheBySchema = validationCacheByRules.get(rulesKey);
        if (!validationCacheBySchema) {
          validationCacheBySchema = new WeakMap;
          validationCacheByRules.set(rulesKey, validationCacheBySchema);
        }
        let validationCacheByDocument = validationCacheBySchema.get(schema4);
        if (!validationCacheByDocument) {
          validationCacheByDocument = new WeakMap;
          validationCacheBySchema.set(schema4, validationCacheByDocument);
        }
        const cachedResult = validationCacheByDocument.get(documentAST);
        if (cachedResult) {
          setResult(cachedResult);
          return;
        }
        return ({ result }) => {
          if (result != null) {
            validationCacheByDocument?.set(documentAST, result);
          }
        };
      }
    }
  };
}

// node_modules/graphql-yoga/esm/plugins/use-request-parser.js
function useRequestParser(options) {
  const matchFn = options.match || DEFAULT_MATCHER;
  return {
    onRequestParse({ request, setRequestParser }) {
      if (matchFn(request)) {
        setRequestParser(options.parse);
      }
    }
  };
}
var DEFAULT_MATCHER = () => true;

// node_modules/graphql-yoga/esm/plugins/result-processor/accept.js
function getMediaTypesForRequestInOrder(request) {
  const accepts = (request.headers.get("accept") || "*/*").replace(/\s/g, "").toLowerCase().split(",");
  const mediaTypes = [];
  for (const accept of accepts) {
    const [mediaType, ...params] = accept.split(";");
    const charset = params?.find((param) => param.includes("charset=")) || "charset=utf-8";
    if (charset !== "charset=utf-8") {
      continue;
    }
    mediaTypes.push(mediaType);
  }
  return mediaTypes.reverse();
}
function isMatchingMediaType(askedMediaType, processorMediaType) {
  const [askedPre, askedSuf] = askedMediaType.split("/");
  const [pre, suf] = processorMediaType.split("/");
  if ((pre === "*" || pre === askedPre) && (suf === "*" || suf === askedSuf)) {
    return true;
  }
  return false;
}

// node_modules/graphql-yoga/esm/plugins/result-processor/stringify.js
function jsonStringifyResultWithoutInternals(result) {
  if (Array.isArray(result)) {
    return `[${result.map((r) => {
      const sanitizedResult2 = omitInternalsFromResultErrors(r);
      const stringifier2 = r.stringify || JSON.stringify;
      return stringifier2(sanitizedResult2);
    }).join(",")}]`;
  }
  const sanitizedResult = omitInternalsFromResultErrors(result);
  const stringifier = result.stringify || JSON.stringify;
  return stringifier(sanitizedResult);
}
function omitInternalsFromResultErrors(result) {
  if (result.errors?.length || result.extensions?.http) {
    const newResult = { ...result };
    newResult.errors &&= newResult.errors.map(omitInternalsFromError);
    if (newResult.extensions) {
      const { http, ...extensions3 } = result.extensions;
      newResult.extensions = Object.keys(extensions3).length ? extensions3 : undefined;
    }
    return newResult;
  }
  return result;
}
var omitInternalsFromError = function(err) {
  if (isGraphQLError(err)) {
    const serializedError = ("toJSON" in err) && typeof err.toJSON === "function" ? err.toJSON() : Object(err);
    const { http, unexpected, ...extensions3 } = serializedError.extensions || {};
    return createGraphQLError(err.message, {
      nodes: err.nodes,
      source: err.source,
      positions: err.positions,
      path: err.path,
      originalError: omitInternalsFromError(err.originalError || undefined),
      extensions: Object.keys(extensions3).length ? extensions3 : undefined
    });
  }
  return err;
};

// node_modules/graphql-yoga/esm/plugins/result-processor/multipart.js
function processMultipartResult(result, fetchAPI) {
  const headersInit = {
    Connection: "keep-alive",
    "Content-Type": 'multipart/mixed; boundary="-"',
    "Transfer-Encoding": "chunked"
  };
  const responseInit = getResponseInitByRespectingErrors(result, headersInit);
  let iterator;
  const textEncoder = new fetchAPI.TextEncoder;
  const readableStream = new fetchAPI.ReadableStream({
    start(controller) {
      if (isAsyncIterable2(result)) {
        iterator = result[Symbol.asyncIterator]();
      } else {
        let finished = false;
        iterator = {
          next: () => {
            if (finished) {
              return Promise.resolve({ done: true, value: null });
            }
            finished = true;
            return Promise.resolve({ done: false, value: result });
          }
        };
      }
      controller.enqueue(textEncoder.encode(`---`));
    },
    async pull(controller) {
      const { done, value } = await iterator.next();
      if (value != null) {
        controller.enqueue(textEncoder.encode("\r\n"));
        controller.enqueue(textEncoder.encode("Content-Type: application/json; charset=utf-8"));
        controller.enqueue(textEncoder.encode("\r\n"));
        const chunk = jsonStringifyResultWithoutInternals(value);
        const encodedChunk = textEncoder.encode(chunk);
        controller.enqueue(textEncoder.encode("Content-Length: " + encodedChunk.byteLength));
        controller.enqueue(textEncoder.encode("\r\n"));
        controller.enqueue(textEncoder.encode("\r\n"));
        controller.enqueue(encodedChunk);
        controller.enqueue(textEncoder.encode("\r\n"));
        controller.enqueue(textEncoder.encode("---"));
      }
      if (done) {
        controller.enqueue(textEncoder.encode("--\r\n"));
        controller.close();
      }
    },
    async cancel(e) {
      await iterator.return?.(e);
    }
  });
  return new fetchAPI.Response(readableStream, responseInit);
}

// node_modules/graphql-yoga/esm/plugins/result-processor/regular.js
function processRegularResult(executionResult, fetchAPI, acceptedHeader) {
  if (isAsyncIterable(executionResult)) {
    return new fetchAPI.Response(null, {
      status: 406,
      statusText: "Not Acceptable",
      headers: {
        accept: "application/json; charset=utf-8, application/graphql-response+json; charset=utf-8"
      }
    });
  }
  const headersInit = {
    "Content-Type": acceptedHeader + "; charset=utf-8"
  };
  const responseInit = getResponseInitByRespectingErrors(executionResult, headersInit, acceptedHeader === "application/json" && !Array.isArray(executionResult) && areGraphQLErrors(executionResult.errors) && executionResult.errors.some((err) => !err.extensions.originalError || isGraphQLError(err.extensions.originalError)));
  const responseBody = jsonStringifyResultWithoutInternals(executionResult);
  return new fetchAPI.Response(responseBody, responseInit);
}

// node_modules/graphql-yoga/esm/plugins/result-processor/sse.js
function getSSEProcessor() {
  return function processSSEResult(result, fetchAPI) {
    let pingIntervalMs = 12000;
    if (globalThis.process?.env?.NODE_ENV === "test") {
      pingIntervalMs = 300;
    }
    const headersInit = {
      "Content-Type": "text/event-stream",
      Connection: "keep-alive",
      "Cache-Control": "no-cache",
      "Content-Encoding": "none"
    };
    const responseInit = getResponseInitByRespectingErrors(result, headersInit, true);
    let iterator;
    let pingInterval;
    const textEncoder = new fetchAPI.TextEncoder;
    const readableStream = new fetchAPI.ReadableStream({
      start(controller) {
        controller.enqueue(textEncoder.encode(":\n\n"));
        pingInterval = setInterval(() => {
          if (!controller.desiredSize) {
            clearInterval(pingInterval);
            return;
          }
          controller.enqueue(textEncoder.encode(":\n\n"));
        }, pingIntervalMs);
        if (isAsyncIterable2(result)) {
          iterator = result[Symbol.asyncIterator]();
        } else {
          let finished = false;
          iterator = {
            next: () => {
              if (finished) {
                return Promise.resolve({ done: true, value: null });
              }
              finished = true;
              return Promise.resolve({ done: false, value: result });
            }
          };
        }
      },
      async pull(controller) {
        const { done, value } = await iterator.next();
        if (value != null) {
          controller.enqueue(textEncoder.encode(`event: next\n`));
          const chunk = jsonStringifyResultWithoutInternals(value);
          controller.enqueue(textEncoder.encode(`data: ${chunk}\n\n`));
        }
        if (done) {
          controller.enqueue(textEncoder.encode(`event: complete\n\n`));
          clearInterval(pingInterval);
          controller.close();
        }
      },
      async cancel(e) {
        clearInterval(pingInterval);
        await iterator.return?.(e);
      }
    });
    return new fetchAPI.Response(readableStream, responseInit);
  };
}

// node_modules/graphql-yoga/esm/plugins/use-result-processor.js
var getSSEProcessorConfig = function() {
  return {
    mediaTypes: ["text/event-stream"],
    asyncIterables: true,
    processResult: getSSEProcessor()
  };
};
function useResultProcessors() {
  const isSubscriptionRequestMap = new WeakMap;
  const sse2 = getSSEProcessorConfig();
  const defaultList = [sse2, multipart2, regular2];
  const subscriptionList = [sse2, regular2];
  return {
    onSubscribe({ args: { contextValue } }) {
      if (contextValue.request) {
        isSubscriptionRequestMap.set(contextValue.request, true);
      }
    },
    onResultProcess({ request, result, acceptableMediaTypes, setResultProcessor }) {
      const isSubscriptionRequest = isSubscriptionRequestMap.get(request);
      const processorConfigList = isSubscriptionRequest ? subscriptionList : defaultList;
      const requestMediaTypes = getMediaTypesForRequestInOrder(request);
      const isAsyncIterableResult = isAsyncIterable2(result);
      for (const resultProcessorConfig of processorConfigList) {
        for (const requestMediaType of requestMediaTypes) {
          if (isAsyncIterableResult && !resultProcessorConfig.asyncIterables) {
            continue;
          }
          for (const processorMediaType of resultProcessorConfig.mediaTypes) {
            acceptableMediaTypes.push(processorMediaType);
            if (isMatchingMediaType(processorMediaType, requestMediaType)) {
              setResultProcessor(resultProcessorConfig.processResult, processorMediaType);
            }
          }
        }
      }
    }
  };
}
var multipart2 = {
  mediaTypes: ["multipart/mixed"],
  asyncIterables: true,
  processResult: processMultipartResult
};
var regular2 = {
  mediaTypes: ["application/graphql-response+json", "application/json"],
  asyncIterables: false,
  processResult: processRegularResult
};

// node_modules/graphql-yoga/esm/landing-page-html.js
var landing_page_html_default = `<!doctype html><html lang=en><head><meta charset=utf-8><title>Welcome to GraphQL Yoga</title><link rel=icon href=https://raw.githubusercontent.com/dotansimha/graphql-yoga/main/website/public/favicon.ico><style>body,html{padding:0;margin:0;height:100%;font-family:Inter,-apple-system,BlinkMacSystemFont,'Segoe UI',Roboto,Oxygen,Ubuntu,Cantarell,'Fira Sans','Droid Sans','Helvetica Neue',sans-serif;color:#fff;background-color:#000}main>section.hero{display:flex;height:90vh;justify-content:center;align-items:center;flex-direction:column}.logo{display:flex;align-items:center}.buttons{margin-top:24px}h1{font-size:80px}h2{color:#888;max-width:50%;margin-top:0;text-align:center}a{color:#fff;text-decoration:none;margin-left:10px;margin-right:10px;font-weight:700;transition:color .3s ease;padding:4px;overflow:visible}a.graphiql:hover{color:rgba(255,0,255,.7)}a.docs:hover{color:rgba(28,200,238,.7)}a.tutorial:hover{color:rgba(125,85,245,.7)}svg{margin-right:24px}.not-what-your-looking-for{margin-top:5vh}.not-what-your-looking-for>*{margin-left:auto;margin-right:auto}.not-what-your-looking-for>p{text-align:center}.not-what-your-looking-for>h2{color:#464646}.not-what-your-looking-for>p{max-width:600px;line-height:1.3em}.not-what-your-looking-for>pre{max-width:300px}</style></head><body id=body><main><section class=hero><div class=logo><div><svg xmlns=http://www.w3.org/2000/svg viewBox="-0.41 0.445 472.812 499.811" height=150><defs><linearGradient id=paint0_linear_1677_11483 x1=16 y1=14 x2=87.2132 y2=44.5982 gradientUnits=userSpaceOnUse gradientTransform="matrix(8.139854, 0, 0, 8.139854, -130.346407, -113.25101)"><stop stop-color=#7433FF /><stop offset=1 stop-color=#FFA3FD /></linearGradient><linearGradient id=paint1_linear_1677_11483 x1=16 y1=14 x2=87.2132 y2=44.5982 gradientUnits=userSpaceOnUse gradientTransform="matrix(8.139854, 0, 0, 8.139854, -130.346407, -113.25101)"><stop stop-color=#7433FF /><stop offset=1 stop-color=#FFA3FD /></linearGradient><linearGradient id=paint2_linear_1677_11483 x1=16 y1=14 x2=87.2132 y2=44.5982 gradientUnits=userSpaceOnUse gradientTransform="matrix(8.139854, 0, 0, 8.139854, -130.346407, -113.25101)"><stop stop-color=#7433FF /><stop offset=1 stop-color=#FFA3FD /></linearGradient><linearGradient id=paint3_linear_1677_11483 x1=16 y1=14 x2=87.2132 y2=44.5982 gradientUnits=userSpaceOnUse><stop stop-color=#7433FF /><stop offset=1 stop-color=#FFA3FD /></linearGradient><linearGradient id=paint4_linear_1677_11483 x1=16 y1=14 x2=87.2132 y2=44.5982 gradientUnits=userSpaceOnUse><stop stop-color=#7433FF /><stop offset=1 stop-color=#FFA3FD /></linearGradient><linearGradient id=paint5_linear_1677_11483 x1=16 y1=14 x2=87.2132 y2=44.5982 gradientUnits=userSpaceOnUse><stop stop-color=#7433FF /><stop offset=1 stop-color=#FFA3FD /></linearGradient><filter id=filter0_f_1677_11483 x=23 y=-25 width=100 height=100 filterUnits=userSpaceOnUse color-interpolation-filters=sRGB><feFlood flood-opacity=0 result=BackgroundImageFix /><feBlend mode=normal in=SourceGraphic in2=BackgroundImageFix result=shape /><feGaussianBlur stdDeviation=12 result=effect1_foregroundBlur_1677_11483 /></filter><filter id=filter1_f_1677_11483 x=-24 y=19 width=100 height=100 filterUnits=userSpaceOnUse color-interpolation-filters=sRGB><feFlood flood-opacity=0 result=BackgroundImageFix /><feBlend mode=normal in=SourceGraphic in2=BackgroundImageFix result=shape /><feGaussianBlur stdDeviation=12 result=effect1_foregroundBlur_1677_11483 /></filter><linearGradient id=paint6_linear_1677_11483 x1=30 y1=28 x2=66.1645 y2=44.4363 gradientUnits=userSpaceOnUse gradientTransform="matrix(8.139854, 0, 0, 8.139854, -130.346407, -113.25101)"><stop stop-color=#7433FF /><stop offset=1 stop-color=#FFA3FD /></linearGradient><filter id=filter2_f_1677_11483 x=-12 y=-44 width=100 height=100 filterUnits=userSpaceOnUse color-interpolation-filters=sRGB><feFlood flood-opacity=0 result=BackgroundImageFix /><feBlend mode=normal in=SourceGraphic in2=BackgroundImageFix result=shape /><feGaussianBlur stdDeviation=12 result=effect1_foregroundBlur_1677_11483 /></filter><filter id=filter3_f_1677_11483 x=13 y=19 width=100 height=100 filterUnits=userSpaceOnUse color-interpolation-filters=sRGB><feFlood flood-opacity=0 result=BackgroundImageFix /><feBlend mode=normal in=SourceGraphic in2=BackgroundImageFix result=shape /><feGaussianBlur stdDeviation=12 result=effect1_foregroundBlur_1677_11483 /></filter></defs><mask id=mask0_1677_11483 style=mask-type:alpha maskUnits=userSpaceOnUse x=16 y=14 width=58 height=62><path d="M21 25.3501C21.7279 25.3501 22.4195 25.5056 23.0433 25.7853L42.1439 14.8C43.0439 14.3 44.1439 14 45.1439 14C46.2439 14 47.2439 14.3 48.1439 14.8L64.5439 24.3C63.3439 25.1 62.4439 26.3 61.8439 27.7L45.9438 18.5C45.6439 18.3 45.344 18.3 45.0441 18.3C44.7441 18.3 44.4439 18.4 44.1439 18.5L25.8225 29.0251C25.9382 29.4471 26 29.8914 26 30.3501C26 33.1115 23.7614 35.3501 21 35.3501C18.2386 35.3501 16 33.1115 16 30.3501C16 27.5887 18.2386 25.3501 21 25.3501Z" fill=url(#paint3_linear_1677_11483) /><path d="M67.2438 35.0329C65.3487 34.3219 64 32.4934 64 30.35C64 27.5886 66.2386 25.35 69 25.35C71.7614 25.35 74 27.5886 74 30.35C74 32.1825 73.0142 33.7848 71.5439 34.6554V55.2C71.5439 57.4 70.3439 59.4 68.5439 60.5L52.1439 69.9C52.1439 68.4 51.6438 66.9 50.7438 65.8L66.3439 56.8C66.9439 56.5 67.2438 55.9 67.2438 55.2V35.0329Z" fill=url(#paint4_linear_1677_11483) /><path d="M49.8439 69.1055C49.9458 69.5034 50 69.9204 50 70.3501C50 73.1115 47.7614 75.3501 45 75.3501C42.5102 75.3501 40.4454 73.5302 40.0633 71.1481L21.8439 60.6C19.9439 59.5 18.8439 57.5 18.8439 55.3V36.8C19.5439 37 20.3439 37.2 21.0439 37.2C21.7439 37.2 22.4439 37.1 23.0439 36.9V55.3C23.0439 56 23.4438 56.6 23.9438 56.9L41.3263 66.9583C42.2398 65.9694 43.5476 65.3501 45 65.3501C47.3291 65.3501 49.2862 66.9426 49.8419 69.0981L49.8436 69.0997L49.8439 69.1055Z" fill=url(#paint5_linear_1677_11483) /></mask><mask id=mask1_1677_11483 style=mask-type:alpha maskUnits=userSpaceOnUse x=30 y=28 width=30 height=30><path fill-rule=evenodd clip-rule=evenodd d="M49.3945 32.3945C49.3945 34.7088 47.5796 38.5469 45 38.5469C42.4271 38.5469 40.6055 34.7112 40.6055 32.3945C40.6055 29.9714 42.5769 28 45 28C47.4231 28 49.3945 29.9714 49.3945 32.3945ZM35.332 49.0433V48.2148C35.332 42.8117 37.8535 41.0004 39.8796 39.545L39.8801 39.5447C40.3928 39.1767 40.8604 38.8404 41.2488 38.4742C42.3293 39.6642 43.626 40.3047 45 40.3047C46.3752 40.3047 47.6725 39.6642 48.7529 38.4754C49.1408 38.841 49.6078 39.1773 50.1199 39.5447L50.1204 39.545C52.1465 41.0004 54.668 42.8117 54.668 48.2148V49.0433L53.8406 49.092C49.9848 49.3185 46.8646 46.9002 45 43.5777C43.1159 46.935 39.9847 49.318 36.1594 49.092L35.332 49.0433ZM58.1463 51.0747L58.1463 51.0746C57.0179 50.891 50.0128 49.7507 45.0007 55.693C40.0116 49.7553 33.1965 50.8592 31.9095 51.0677L31.9095 51.0677C31.7906 51.087 31.7189 51.0986 31.7002 51.0963C31.7005 51.0969 31.7011 51.1045 31.7023 51.1187C31.726 51.4003 31.9682 54.2745 34.0566 56.2422L30 58H60L55.8956 56.2422C57.8537 54.4764 58.1396 52.2685 58.2508 51.4092V51.4091C58.2697 51.2628 58.2836 51.1556 58.2998 51.0963C58.2881 51.0977 58.2356 51.0892 58.1463 51.0747ZM40.4836 50.104C42.3956 49.3212 43.6746 48.1737 45 46.61C46.332 48.1841 47.6159 49.3259 49.5164 50.104C49.5356 50.1425 49.5557 50.1805 49.5756 50.2182C49.5793 50.2253 49.583 50.2323 49.5867 50.2393C48.0911 50.8127 46.4264 51.825 45.0047 53.1444C43.5906 51.8221 41.9673 50.8196 40.4256 50.2153C40.4455 50.1784 40.4648 50.1415 40.4836 50.104Z" fill=black /></mask><path d="M 40.59 93.095 C 46.517 93.095 52.14 94.365 57.22 96.635 L 212.7 7.22 C 220.025 3.149 228.978 0.706 237.12 0.706 C 246.073 0.706 254.213 3.149 261.54 7.22 L 395.032 84.547 C 385.264 91.059 377.939 100.827 373.055 112.224 L 243.631 37.338 C 241.19 35.71 238.747 35.71 236.305 35.71 C 233.863 35.71 231.42 36.523 228.978 37.338 L 79.84 123.009 C 80.786 126.443 81.29 130.058 81.29 133.793 C 81.29 156.269 63.065 174.493 40.59 174.493 C 18.116 174.493 -0.109 156.269 -0.109 133.793 C -0.109 111.32 18.116 93.095 40.59 93.095 Z" fill=url(#paint0_linear_1677_11483) /><path d="M 417.01 171.913 C 401.585 166.126 390.603 151.238 390.603 133.793 C 390.603 111.32 408.83 93.095 431.303 93.095 C 453.777 93.095 472.001 111.32 472.001 133.793 C 472.001 148.706 463.976 161.755 452.011 168.835 L 452.011 336.07 C 452.011 353.977 442.243 370.258 427.591 379.21 L 294.098 455.726 C 294.098 443.516 290.029 431.306 282.703 422.353 L 409.683 349.093 C 414.568 346.651 417.01 341.767 417.01 336.07 L 417.01 171.913 Z" fill=url(#paint1_linear_1677_11483) /><path d="M 275.376 449.253 C 276.206 452.495 276.646 455.889 276.646 459.389 C 276.646 481.863 258.422 500.087 235.947 500.087 C 215.679 500.087 198.87 485.272 195.761 465.883 L 47.46 380.025 C 31.995 371.071 23.041 354.792 23.041 336.884 L 23.041 186.296 C 28.738 187.923 35.25 189.553 40.948 189.553 C 46.646 189.553 52.345 188.738 57.228 187.111 L 57.228 336.884 C 57.228 342.582 60.485 347.465 64.554 349.908 L 206.042 431.777 C 213.481 423.728 224.127 418.689 235.947 418.689 C 254.905 418.689 270.833 431.656 275.36 449.196 L 275.376 449.214 L 275.376 449.253 Z" fill=url(#paint2_linear_1677_11483) /><g mask=url(#mask0_1677_11483) transform="matrix(8.139854, 0, 0, 8.139854, -130.346375, -113.251038)"><g filter=url(#filter0_f_1677_11483)><circle cx=73 cy=25 r=26 fill=#ED2E7E /></g><g filter=url(#filter1_f_1677_11483)><circle cx=26 cy=69 r=26 fill=#1CC8EE /></g></g><path fill-rule=evenodd clip-rule=evenodd d="M 271.713 150.431 C 271.713 169.275 256.948 200.517 235.947 200.517 C 215.003 200.517 200.172 169.292 200.172 150.431 C 200.172 130.708 216.225 114.666 235.947 114.666 C 255.67 114.666 271.713 130.708 271.713 150.431 Z M 157.251 285.952 L 157.251 279.212 C 157.251 235.233 177.771 220.485 194.27 208.641 C 198.447 205.644 202.247 202.901 205.414 199.923 C 214.204 209.608 224.763 214.826 235.947 214.826 C 247.138 214.826 257.697 209.608 266.496 199.931 C 269.653 202.911 273.456 205.644 277.622 208.641 C 294.114 220.485 314.642 235.233 314.642 279.212 L 314.642 285.952 L 307.912 286.351 C 276.525 288.191 251.128 268.509 235.947 241.468 C 220.611 268.795 195.126 288.191 163.981 286.351 L 157.251 285.952 Z M 342.953 302.492 C 333.771 300.994 276.751 291.715 235.955 340.082 C 195.345 291.749 139.865 300.734 129.389 302.436 C 128.428 302.59 127.841 302.688 127.687 302.665 C 127.687 302.673 127.695 302.729 127.702 302.85 C 127.897 305.138 129.867 328.532 146.872 344.55 L 113.849 358.862 L 358.044 358.862 L 324.639 344.55 C 340.576 330.177 342.905 312.202 343.807 305.212 C 343.962 304.022 344.077 303.153 344.206 302.665 C 344.108 302.68 343.686 302.606 342.953 302.492 Z M 199.188 294.59 C 214.751 288.215 225.161 278.879 235.947 266.15 C 246.788 278.96 257.241 288.255 272.707 294.59 C 272.869 294.898 273.031 295.207 273.196 295.518 C 273.219 295.574 273.252 295.631 273.285 295.688 C 261.107 300.361 247.555 308.598 235.989 319.334 C 224.477 308.573 211.258 300.417 198.715 295.493 C 198.87 295.191 199.033 294.891 199.188 294.59 Z" fill=url(#paint6_linear_1677_11483) /><g mask=url(#mask1_1677_11483) transform="matrix(8.139854, 0, 0, 8.139854, -130.346375, -113.251038)"><g filter=url(#filter2_f_1677_11483)><circle cx=38 cy=6 r=26 fill=#ED2E7E /></g><g filter=url(#filter3_f_1677_11483)><circle cx=63 cy=69 r=26 fill=#1CC8EE /></g></g></svg></div><h1>GraphQL Yoga</h1></div><h2>The batteries-included cross-platform GraphQL Server.</h2><div class=buttons><a href=https://www.the-guild.dev/graphql/yoga-server/docs class=docs>Read the Docs</a> <a href=https://www.the-guild.dev/graphql/yoga-server/tutorial/basic class=tutorial>Start the Tutorial </a><a href=__GRAPHIQL_LINK__ class=graphiql>Visit GraphiQL</a></div></section><section class=not-what-your-looking-for><h2>Not the page you are looking for? \uD83D\uDC40</h2><p>This page is shown be default whenever a 404 is hit.<br>You can disable this by behavior via the <code>landingPage</code> option.</p><pre>
          <code>
import { createYoga } from 'graphql-yoga';

const yoga = createYoga({
  landingPage: false
})
          </code>
        </pre><p>If you expected this page to be the GraphQL route, you need to configure Yoga. Currently, the GraphQL route is configured to be on <code>__GRAPHIQL_LINK__</code>.</p><pre>
          <code>
import { createYoga } from 'graphql-yoga';

const yoga = createYoga({
  graphqlEndpoint: '__REQUEST_PATH__',
})
          </code>
        </pre></section></main></body></html>`;

// node_modules/graphql-yoga/esm/plugins/use-unhandled-route.js
function useUnhandledRoute(args7) {
  let urlPattern;
  function getUrlPattern({ URLPattern }) {
    urlPattern ||= new URLPattern({
      pathname: args7.graphqlEndpoint
    });
    return urlPattern;
  }
  return {
    onRequest({ request, fetchAPI, endResponse: endResponse2, url }) {
      if (!request.url.endsWith(args7.graphqlEndpoint) && url.pathname !== args7.graphqlEndpoint && !getUrlPattern(fetchAPI).test(url)) {
        if (args7.showLandingPage === true && request.method === "GET" && !!request.headers?.get("accept")?.includes("text/html")) {
          endResponse2(new fetchAPI.Response(landing_page_html_default.replace(/__GRAPHIQL_LINK__/g, args7.graphqlEndpoint).replace(/__REQUEST_PATH__/g, url.pathname), {
            status: 200,
            statusText: "OK",
            headers: {
              "Content-Type": "text/html"
            }
          }));
          return;
        }
        endResponse2(new fetchAPI.Response("", {
          status: 404,
          statusText: "Not Found"
        }));
      }
    }
  };
}

// node_modules/graphql-yoga/esm/process-request.js
async function processResult({ request, result, fetchAPI, onResultProcessHooks }) {
  let resultProcessor;
  const acceptableMediaTypes = [];
  let acceptedMediaType = "*/*";
  for (const onResultProcessHook of onResultProcessHooks) {
    await onResultProcessHook({
      request,
      acceptableMediaTypes,
      result,
      setResult(newResult) {
        result = newResult;
      },
      resultProcessor,
      setResultProcessor(newResultProcessor, newAcceptedMimeType) {
        resultProcessor = newResultProcessor;
        acceptedMediaType = newAcceptedMimeType;
      }
    });
  }
  if (!resultProcessor) {
    return new fetchAPI.Response(null, {
      status: 406,
      statusText: "Not Acceptable",
      headers: {
        accept: acceptableMediaTypes.join("; charset=utf-8, ")
      }
    });
  }
  return resultProcessor(result, fetchAPI, acceptedMediaType);
}
async function processRequest({ params, enveloped }) {
  const document2 = enveloped.parse(params.query);
  const errors3 = enveloped.validate(enveloped.schema, document2);
  if (errors3.length > 0) {
    return { errors: errors3 };
  }
  const contextValue = await enveloped.contextFactory();
  const executionArgs = {
    schema: enveloped.schema,
    document: document2,
    contextValue,
    variableValues: params.variables,
    operationName: params.operationName
  };
  const operation = getOperationAST(document2, params.operationName);
  const executeFn = operation?.operation === "subscription" ? enveloped.subscribe : enveloped.execute;
  return executeFn(executionArgs);
}

// node_modules/graphql-yoga/esm/utils/mask-error.js
var maskError = (error8, message, isDev2 = globalThis.process?.env?.NODE_ENV === "development") => {
  if (isGraphQLError(error8)) {
    if (error8.originalError) {
      if (error8.originalError.name === "GraphQLError") {
        return error8;
      }
      const extensions3 = {
        ...error8.extensions,
        unexpected: true
      };
      if (isDev2) {
        extensions3.originalError = {
          message: error8.originalError.message,
          stack: error8.originalError.stack
        };
      }
      return createGraphQLError(message, {
        nodes: error8.nodes,
        source: error8.source,
        positions: error8.positions,
        path: error8.path,
        extensions: extensions3
      });
    }
    return error8;
  }
  return createGraphQLError(message, {
    extensions: {
      unexpected: true,
      originalError: isDev2 ? error8 instanceof Error ? {
        message: error8.message,
        stack: error8.stack
      } : error8 : undefined
    }
  });
};

// node_modules/graphql-yoga/esm/server.js
function createYoga(options) {
  const server2 = new YogaServer(options);
  return createServerAdapter(server2, {
    fetchAPI: server2.fetchAPI,
    plugins: server2["plugins"]
  });
}

class YogaServer {
  constructor(options) {
    this.handle = async (request, serverContext) => {
      let url = new Proxy({}, {
        get: (_target, prop, _receiver) => {
          url = new this.fetchAPI.URL(request.url, "http://localhost");
          return Reflect.get(url, prop, url);
        }
      });
      let requestParser;
      const onRequestParseDoneList = [];
      for (const onRequestParse of this.onRequestParseHooks) {
        const onRequestParseResult = await onRequestParse({
          request,
          url,
          requestParser,
          serverContext,
          setRequestParser(parser) {
            requestParser = parser;
          }
        });
        if (onRequestParseResult?.onRequestParseDone != null) {
          onRequestParseDoneList.push(onRequestParseResult.onRequestParseDone);
        }
      }
      this.logger.debug(`Parsing request to extract GraphQL parameters`);
      if (!requestParser) {
        return new this.fetchAPI.Response(null, {
          status: 415,
          statusText: "Unsupported Media Type"
        });
      }
      let requestParserResult = await requestParser(request);
      for (const onRequestParseDone of onRequestParseDoneList) {
        await onRequestParseDone({
          requestParserResult,
          setRequestParserResult(newParams) {
            requestParserResult = newParams;
          }
        });
      }
      const result = await (Array.isArray(requestParserResult) ? Promise.all(requestParserResult.map((params) => this.getResultForParams({
        params,
        request
      }, serverContext))) : this.getResultForParams({
        params: requestParserResult,
        request
      }, serverContext));
      return processResult({
        request,
        result,
        fetchAPI: this.fetchAPI,
        onResultProcessHooks: this.onResultProcessHooks
      });
    };
    this.id = options?.id ?? "yoga";
    this.fetchAPI = {
      ...exports_node_ponyfill
    };
    if (options?.fetchAPI) {
      for (const key in options.fetchAPI) {
        if (options.fetchAPI[key]) {
          this.fetchAPI[key] = options.fetchAPI[key];
        }
      }
    }
    const logger6 = options?.logging == null ? true : options.logging;
    this.logger = typeof logger6 === "boolean" ? logger6 === true ? createLogger() : createLogger("silent") : typeof logger6 === "string" ? createLogger(logger6) : logger6;
    const maskErrorFn = typeof options?.maskedErrors === "object" && options.maskedErrors.maskError || maskError;
    const maskedErrorSet = new WeakSet;
    this.maskedErrorsOpts = options?.maskedErrors === false ? null : {
      errorMessage: "Unexpected error.",
      ...typeof options?.maskedErrors === "object" ? options.maskedErrors : {},
      maskError: (error9, message) => {
        if (maskedErrorSet.has(error9)) {
          return error9;
        }
        const newError = maskErrorFn(error9, message, this.maskedErrorsOpts?.isDev);
        if (newError !== error9) {
          this.logger.error(error9);
        }
        maskedErrorSet.add(newError);
        return newError;
      }
    };
    const maskedErrors = this.maskedErrorsOpts == null ? null : this.maskedErrorsOpts;
    let batchingLimit = 0;
    if (options?.batching) {
      if (typeof options.batching === "boolean") {
        batchingLimit = 10;
      } else {
        batchingLimit = options.batching.limit ?? 10;
      }
    }
    this.graphqlEndpoint = options?.graphqlEndpoint || "/graphql";
    const graphqlEndpoint = this.graphqlEndpoint;
    this.plugins = [
      useEngine({
        parse,
        validate: validate2,
        execute: normalizedExecutor,
        subscribe: normalizedExecutor,
        specifiedRules
      }),
      !!options?.schema && useSchema(options.schema),
      options?.context != null && useExtendContext((initialContext) => {
        if (options?.context) {
          if (typeof options.context === "function") {
            return options.context(initialContext);
          }
          return options.context;
        }
        return {};
      }),
      useHealthCheck({
        id: this.id,
        logger: this.logger,
        endpoint: options?.healthCheckEndpoint
      }),
      options?.cors !== false && useCORS(options?.cors),
      options?.graphiql !== false && useGraphiQL({
        graphqlEndpoint,
        options: options?.graphiql,
        render: options?.renderGraphiQL,
        logger: this.logger
      }),
      useRequestParser({
        match: isGETRequest,
        parse: parseGETRequest
      }),
      useRequestParser({
        match: isPOSTJsonRequest,
        parse: parsePOSTJsonRequest
      }),
      options?.multipart !== false && useRequestParser({
        match: isPOSTMultipartRequest,
        parse: parsePOSTMultipartRequest
      }),
      useRequestParser({
        match: isPOSTGraphQLStringRequest,
        parse: parsePOSTGraphQLStringRequest
      }),
      useRequestParser({
        match: isPOSTFormUrlEncodedRequest,
        parse: parsePOSTFormUrlEncodedRequest
      }),
      useResultProcessors(),
      useErrorHandling((error9, request) => {
        const errors3 = handleError(error9, this.maskedErrorsOpts, this.logger);
        const result = {
          errors: errors3
        };
        return processResult({
          request,
          result,
          fetchAPI: this.fetchAPI,
          onResultProcessHooks: this.onResultProcessHooks
        });
      }),
      ...options?.plugins ?? [],
      {
        onPluginInit({ addPlugin }) {
          if (options?.parserAndValidationCache !== false) {
            addPlugin(useParserAndValidationCache(!options?.parserAndValidationCache || options?.parserAndValidationCache === true ? {} : options?.parserAndValidationCache));
          }
          addPlugin(useLimitBatching(batchingLimit));
          addPlugin(useCheckGraphQLQueryParams());
          addPlugin(useUnhandledRoute({
            graphqlEndpoint,
            showLandingPage: options?.landingPage ?? true
          }));
          addPlugin(useCheckMethodForGraphQL());
          addPlugin(usePreventMutationViaGET());
          if (maskedErrors) {
            addPlugin(useMaskedErrors(maskedErrors));
          }
          addPlugin(useHTTPValidationError());
        }
      }
    ];
    this.getEnveloped = envelop({
      plugins: this.plugins
    });
    this.plugins = this.getEnveloped._plugins;
    this.onRequestParseHooks = [];
    this.onParamsHooks = [];
    this.onResultProcessHooks = [];
    for (const plugin9 of this.plugins) {
      if (plugin9) {
        if (plugin9.onYogaInit) {
          plugin9.onYogaInit({
            yoga: this
          });
        }
        if (plugin9.onRequestParse) {
          this.onRequestParseHooks.push(plugin9.onRequestParse);
        }
        if (plugin9.onParams) {
          this.onParamsHooks.push(plugin9.onParams);
        }
        if (plugin9.onResultProcess) {
          this.onResultProcessHooks.push(plugin9.onResultProcess);
        }
      }
    }
  }
  async getResultForParams({ params, request }, ...args7) {
    try {
      let result;
      for (const onParamsHook of this.onParamsHooks) {
        await onParamsHook({
          params,
          request,
          setParams(newParams) {
            params = newParams;
          },
          setResult(newResult) {
            result = newResult;
          },
          fetchAPI: this.fetchAPI
        });
      }
      if (result == null) {
        const serverContext = args7[0];
        const initialContext = {
          ...serverContext,
          request,
          params
        };
        const enveloped = this.getEnveloped(initialContext);
        this.logger.debug(`Processing GraphQL Parameters`);
        result = await processRequest({
          params,
          enveloped
        });
        this.logger.debug(`Processing GraphQL Parameters done.`);
      }
      return result;
    } catch (error9) {
      const errors3 = handleError(error9, this.maskedErrorsOpts, this.logger);
      const result = {
        errors: errors3
      };
      return result;
    }
  }
}

// src/server.ts
var yoga = createYoga({ schema: schema3 });
Bun.serve({
  port: SERVER_PORT,
  fetch: yoga
});
console.log(`\uD83D\uDE80 Server ready!`);
